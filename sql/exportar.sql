--------------------------------------------------------
--  Arquivo criado - TerÃ§a-feira-Abril-15-2014   
--------------------------------------------------------
DROP TABLE "SEMAD"."ORGAO_GESTOR_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."AGENCIA_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."AGENCIA_ESTAGIO_EMAIL" cascade constraints;
DROP TABLE "SEMAD"."AGENTE_SETORIAL_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."BOLSA_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."CONTRATO_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."CURSO_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."ITEM_PAGAMENTO_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."ITEM_PAG_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."ORGAO_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."PAGAMENTO_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."RECESSO_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."SELECAO_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."SOLICITACAO_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."SUPERVISOR_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."TIPO_PAG_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."TIPO_VAGA_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."VAGAS_ESTAGIO" cascade constraints;
DROP TABLE "SEMAD"."ESTAGIARIO" cascade constraints;
DROP TABLE "SEMAD"."ESTAGIARIO_CONTRATO" cascade constraints;
DROP TABLE "SEMAD"."ESTAGIARIO_SELECAO" cascade constraints;
DROP TABLE "SEMAD"."ESTAGIARIO_VAGA" cascade constraints;
DROP TABLE "SEMAD"."UNIDADE_ORG" cascade constraints;
DROP TABLE "SEMAD"."USUARIO" cascade constraints;
DROP TABLE "SEMAD"."INSTITUICAO_ENSINO" cascade constraints;
DROP TABLE "SEMAD"."AREA_CONHECIMENTO_GE" cascade constraints;
DROP TABLE "SEMAD"."CONTRATO_CP" cascade constraints;
DROP TABLE "SEMAD"."OFERTA_VAGA" cascade constraints;
DROP TABLE "SEMAD"."CONSELHO_PROFISSIONAL" cascade constraints;
DROP TABLE "SEMAD"."FUNCIONARIO_PE" cascade constraints;
DROP TABLE "SEMAD"."PESSOA_FISICA" cascade constraints;
DROP TABLE "SEMAD"."VAGAS_RECRUTAMENTO" cascade constraints;
DROP TABLE "SEMAD"."PESSOA" cascade constraints;
DROP TABLE "SEMAD"."CAMPO" cascade constraints;
DROP TABLE "SEMAD"."TABELA" cascade constraints;
DROP TABLE "SEMAD"."VALOR_HISTORICO" cascade constraints;
DROP TABLE "SEMAD"."TRANSFERENCIA_VAGAS" cascade constraints;
DROP TABLE "SEMAD"."AVALIACAO_COORDENADOR" cascade constraints;
DROP SYNONYM "PUBLIC"."DUAL";
DROP SYNONYM "PUBLIC"."DBMS_LOCK";
DROP SYNONYM "PUBLIC"."DBMS_OUTPUT";
DROP SYNONYM "PUBLIC"."DBMS_RANDOM";
DROP SYNONYM "PUBLIC"."DBMS_SQL";
DROP SYNONYM "PUBLIC"."DBMS_UTILITY";
DROP SYNONYM "PUBLIC"."DBMS_LOB";
DROP SYNONYM "PUBLIC"."PLITBLM";
DROP SYNONYM "PUBLIC"."UTL_COMPRESS";
DROP SYNONYM "PUBLIC"."UTL_FILE";
DROP SYNONYM "OSMUNDO"."AVALIACAO_COORDENADOR";
DROP SYNONYM "OSMUNDO"."F_G_PK_PLAQUETA_INATIVADA";
DROP SYNONYM "OSMUNDO"."V_ENTRADA_ESTOQUE_3";
DROP SEQUENCE "SEMAD"."S_ORGAO_GESTOR_ESTAGIO";
DROP SEQUENCE "SEMAD"."S_AGENCIA_ESTAGIO";
DROP SEQUENCE "SEMAD"."S_AGENTE_SETORIAL_ESTAGIO";
DROP SEQUENCE "SEMAD"."S_BOLSA_ESTAGIO";
DROP SEQUENCE "SEMAD"."S_CONTRATO_ESTAGIO";
DROP SEQUENCE "SEMAD"."S_CURSO_ESTAGIO";
DROP SEQUENCE "SEMAD"."S_ITEM_PAGAMENTO_ESTAGIO";
DROP SEQUENCE "SEMAD"."S_ORGAO_ESTAGIO";
DROP SEQUENCE "SEMAD"."S_PAGAMENTO_ESTAGIO";
DROP SEQUENCE "SEMAD"."S_QUADRO_VAGAS_ESTAGIO";
DROP SEQUENCE "SEMAD"."S_RECESSO_ESTAGIO";
DROP SEQUENCE "SEMAD"."S_RECRUTAMENTO_ESTAGIO";
DROP SEQUENCE "SEMAD"."S_SELECAO_ESTAGIO";
DROP SEQUENCE "SEMAD"."S_SOLICITACAO_ESTAGIO";
DROP SEQUENCE "OSMUNDO"."DBOBJECTID_SEQUENCE";
DROP VIEW "SEMAD"."V_ESTAGIARIO";
DROP VIEW "SEMAD"."V_ESTAGIARIO_2";
DROP VIEW "OSMUNDO"."MGV_ALL_CATALOGS";
DROP VIEW "OSMUNDO"."MGV_ALL_SCHEMA";
DROP VIEW "OSMUNDO"."MGV_ALL_TABLES";
DROP VIEW "OSMUNDO"."MGV_ALL_VIEWS";
DROP VIEW "SEMAD"."V_ENTRADA_ESTOQUE_3";
DROP FUNCTION "SEMAD"."F_G_PK_ORGAO_GESTOR_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_COD_CONTRATO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_COD_QUADRO_VAGAS_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_COD_RECESSO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_COD_RECRUTAMENTO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_COD_SELECAO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_COD_SOLICITACAO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_COD_TRANSFERENCIA_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_AGENCIA_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_AGENTE_SETORIAL_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_BOLSA_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_CONTRATO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_CURSO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_ITEM_PAGAMENTO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_ORGAO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_PAGAMENTO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_QUADRO_VAGAS_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_RECESSO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_RECRUTAMENTO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_SELECAO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_SOLICITACAO_ESTAGIO";
DROP FUNCTION "SEMAD"."F_G_PK_ESTAGIARIO_VAGA";
DROP FUNCTION "SEMAD"."F_AVS_BUSCA_CAMPO";
DROP FUNCTION "SEMAD"."F_AVS_BUSCA_TABELA";
DROP FUNCTION "SEMAD"."F_AVS_CADASTRA_TRANSACAO";
DROP FUNCTION "SEMAD"."F_G_PK_VALOR_HISTORICO";
DROP FUNCTION "SEMAD"."F_G_PK_PLAQUETA_INATIVADA";
DROP PACKAGE "OSMUNDO"."ARHP8170";
DROP PACKAGE "OSMUNDO"."MD_META";
DROP PACKAGE "OSMUNDO"."MIGRATION";
DROP PACKAGE "OSMUNDO"."MIGRATION_REPORT";
DROP PACKAGE "OSMUNDO"."MIGRATION_TRANSFORMER";
DROP PACKAGE "OSMUNDO"."OFS";
DROP PACKAGE "OSMUNDO"."OFS_COMPRESS";
DROP PACKAGE "OSMUNDO"."OFS_PRIVATE";
DROP PACKAGE BODY "OSMUNDO"."ARHP8170";
DROP PACKAGE BODY "OSMUNDO"."MD_META";
DROP PACKAGE BODY "OSMUNDO"."MIGRATION";
DROP PACKAGE BODY "OSMUNDO"."MIGRATION_REPORT";
DROP PACKAGE BODY "OSMUNDO"."MIGRATION_TRANSFORMER";
DROP PACKAGE BODY "OSMUNDO"."OFS";
DROP PACKAGE BODY "OSMUNDO"."OFS_COMPRESS";
DROP PACKAGE BODY "OSMUNDO"."OFS_PRIVATE";
DROP PROCEDURE "OSMUNDO"."PROC_LE_ARQUIVO";
DROP TYPE "OSMUNDO"."MIGR_FILTER";
DROP TYPE "OSMUNDO"."NAMELIST";
DROP TYPE "OSMUNDO"."OBJECTIDLIST";
DROP TYPE "OSMUNDO"."MIGR_FILTER_SET";
DROP TYPE "OSMUNDO"."MIGR_REPORT_DETAIL_ROW";
DROP TYPE "OSMUNDO"."MIGR_REPORT_DETAIL_TABLE";
DROP TYPE "OSMUNDO"."MIGR_REPORT_SUM_ROW";
DROP TYPE "OSMUNDO"."MIGR_REPORT_SUM_TABLE";
DROP TYPE "OSMUNDO"."NAME_AND_COUNT_ARRAY";
DROP TYPE "OSMUNDO"."NAME_AND_COUNT_T";
--------------------------------------------------------
--  DDL for Type MIGR_FILTER
--------------------------------------------------------

  CREATE OR REPLACE TYPE "OSMUNDO"."MIGR_FILTER" IS OBJECT (
  FILTER_TYPE INTEGER, -- Filter Types are 0-> ALL, 1->NAMELIST, 2->WHERE CLAUSE, 3->OBJECTID LIST
  OBJTYPE VARCHAR2(40),
  OBJECTIDS OBJECTIDLIST,
  NAMES NAMELIST,
  WHERECLAUSE VARCHAR2(1000));

/
--------------------------------------------------------
--  DDL for Type NAMELIST
--------------------------------------------------------

  CREATE OR REPLACE TYPE "OSMUNDO"."NAMELIST" IS TABLE OF VARCHAR2(40);

/
--------------------------------------------------------
--  DDL for Type OBJECTIDLIST
--------------------------------------------------------

  CREATE OR REPLACE TYPE "OSMUNDO"."OBJECTIDLIST" IS TABLE OF INTEGER;

/
--------------------------------------------------------
--  DDL for Type MIGR_FILTER_SET
--------------------------------------------------------

  CREATE OR REPLACE TYPE "OSMUNDO"."MIGR_FILTER_SET" IS TABLE OF MIGR_FILTER;

/
--------------------------------------------------------
--  DDL for Type MIGR_REPORT_DETAIL_ROW
--------------------------------------------------------

  CREATE OR REPLACE TYPE "OSMUNDO"."MIGR_REPORT_DETAIL_ROW" AS OBJECT
 (CAPTURED_ID            NUMBER(38),
  CAPTURED_NAME          VARCHAR2(4000),
  CONVERTED_NAME          VARCHAR2(4000),
  CAPTURED_TYPE          VARCHAR2(4000),
  CONVERTED_TYPE          VARCHAR2(4000),
  CAPTURE_STATUS         VARCHAR2(20),
  CONVERT_STATUS         VARCHAR2(20),
  GENERATE_STATUS        VARCHAR2(20),
  LOGTEXT               VARCHAR2(4000)
 );
 

/
--------------------------------------------------------
--  DDL for Type MIGR_REPORT_DETAIL_TABLE
--------------------------------------------------------

  CREATE OR REPLACE TYPE "OSMUNDO"."MIGR_REPORT_DETAIL_TABLE" AS TABLE OF MIGR_REPORT_DETAIL_ROW;

/
--------------------------------------------------------
--  DDL for Type MIGR_REPORT_SUM_ROW
--------------------------------------------------------

  CREATE OR REPLACE TYPE "OSMUNDO"."MIGR_REPORT_SUM_ROW" AS OBJECT
       (LABEL           VARCHAR2(50),
	    SCHEMA_SUM      NUMBER,
        TABLE_SUM       NUMBER,
		INDEX_SUM       NUMBER,
		CONSTRAINT_SUM  NUMBER,
		VIEW_SUM        NUMBER,
		TRIGGER_SUM     NUMBER,
		SP_SUM          NUMBER		
        );

/
--------------------------------------------------------
--  DDL for Type MIGR_REPORT_SUM_TABLE
--------------------------------------------------------

  CREATE OR REPLACE TYPE "OSMUNDO"."MIGR_REPORT_SUM_TABLE" AS TABLE OF MIGR_REPORT_SUM_ROW;

/
--------------------------------------------------------
--  DDL for Type NAME_AND_COUNT_ARRAY
--------------------------------------------------------

  CREATE OR REPLACE TYPE "OSMUNDO"."NAME_AND_COUNT_ARRAY" IS VARRAY(30) OF name_and_count_t;
 

/
--------------------------------------------------------
--  DDL for Type NAME_AND_COUNT_T
--------------------------------------------------------

  CREATE OR REPLACE TYPE "OSMUNDO"."NAME_AND_COUNT_T" IS OBJECT (
  OBJECT_NAME varchar2(30),
  UPDATE_COUNT INTEGER);
 

/
--------------------------------------------------------
--  DDL for Sequence S_ORGAO_GESTOR_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_ORGAO_GESTOR_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 201 CACHE 20 NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence S_AGENCIA_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_AGENCIA_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 181 CACHE 20 NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence S_AGENTE_SETORIAL_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_AGENTE_SETORIAL_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 39 NOCACHE  NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence S_BOLSA_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_BOLSA_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 81 CACHE 20 NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence S_CONTRATO_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_CONTRATO_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 361 CACHE 20 NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence S_CURSO_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_CURSO_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 261 CACHE 20 NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence S_ITEM_PAGAMENTO_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_ITEM_PAGAMENTO_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 101 CACHE 20 NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence S_ORGAO_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_ORGAO_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 361 CACHE 20 NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence S_PAGAMENTO_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_PAGAMENTO_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence S_QUADRO_VAGAS_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_QUADRO_VAGAS_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 461 CACHE 20 NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence S_RECESSO_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_RECESSO_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 25 NOCACHE  NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence S_RECRUTAMENTO_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_RECRUTAMENTO_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 321 CACHE 20 NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence S_SELECAO_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_SELECAO_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 87 NOCACHE  NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence S_SOLICITACAO_ESTAGIO
--------------------------------------------------------

   CREATE SEQUENCE  "SEMAD"."S_SOLICITACAO_ESTAGIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 113 NOCACHE  NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Sequence DBOBJECTID_SEQUENCE
--------------------------------------------------------

   CREATE SEQUENCE  "OSMUNDO"."DBOBJECTID_SEQUENCE"  MINVALUE 1 MAXVALUE 999999999999999999999999 INCREMENT BY 50 START WITH 1 CACHE 50 NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Table ORGAO_GESTOR_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."ORGAO_GESTOR_ESTAGIO" 
   (	"ID_ORGAO_GESTOR_ESTAGIO" NUMBER(*,0), 
	"TX_ORGAO_GESTOR_ESTAGIO" VARCHAR2(255 BYTE), 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"ID_UNIDADE_ORG" NUMBER(*,0), 
	"TX_CNPJ" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."ORGAO_GESTOR_ESTAGIO"."ID_UNIDADE_ORG" IS 'Identificador Ãºnico de uma unidade organizacional.';
--------------------------------------------------------
--  DDL for Table AGENCIA_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."AGENCIA_ESTAGIO" 
   (	"ID_AGENCIA_ESTAGIO" NUMBER(*,0), 
	"TX_AGENCIA_ESTAGIO" VARCHAR2(255 BYTE), 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"TX_SIGLA" VARCHAR2(20 BYTE), 
	"TX_CNPJ" VARCHAR2(20 BYTE), 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"TX_EMAIL" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."AGENCIA_ESTAGIO"."ID_USUARIO_CADASTRO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."AGENCIA_ESTAGIO"."ID_USUARIO_ATUALIZACAO" IS 'CÃ³digo do usuÃ¡rio do BD.';
--------------------------------------------------------
--  DDL for Table AGENCIA_ESTAGIO_EMAIL
--------------------------------------------------------

  CREATE TABLE "SEMAD"."AGENCIA_ESTAGIO_EMAIL" 
   (	"ID_AGENCIA_ESTAGIO" NUMBER, 
	"NB_AGENCIA_ESTAGIO_EMAIL" NUMBER, 
	"TX_AGENCIA_EMAIL" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Table AGENTE_SETORIAL_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."AGENTE_SETORIAL_ESTAGIO" 
   (	"ID_USUARIO" NUMBER, 
	"ID_SETORIAL_ESTAGIO" NUMBER(*,0), 
	"DT_CADASTRO" DATE, 
	"DT_ATULIZACAO" DATE, 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"TX_EMAIL" VARCHAR2(100 BYTE), 
	"TX_CARGO_FUNCAO" VARCHAR2(100 BYTE), 
	"TX_CONTATO" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."AGENTE_SETORIAL_ESTAGIO"."ID_USUARIO" IS 'CÃ³digo do usuÃ¡rio do BD.';
--------------------------------------------------------
--  DDL for Table BOLSA_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."BOLSA_ESTAGIO" 
   (	"ID_BOLSA_ESTAGIO" NUMBER(*,0), 
	"TX_BOLSA_ESTAGIO" VARCHAR2(255 BYTE), 
	"NB_VALOR" NUMBER(12,2)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Table CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."CONTRATO_ESTAGIO" 
   (	"ID_PESSOA_ESTAGIARIO" NUMBER(*,0), 
	"ID_CONTRATO" NUMBER(*,0), 
	"ID_ORGAO_GESTOR_ESTAGIO" NUMBER(*,0), 
	"ID_ORGAO_ESTAGIO" NUMBER(*,0), 
	"ID_QUADRO_VAGAS_ESTAGIO" NUMBER(*,0), 
	"ID_CURSO_ESTAGIO" NUMBER(*,0), 
	"ID_PESSOA_SUPERVISOR" NUMBER(*,0), 
	"ID_INSTITUICAO_ENSINO" NUMBER(*,0), 
	"ID_BOLSA_ESTAGIO" NUMBER(*,0), 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"DT_INICIO_VIGENCIA" DATE, 
	"DT_DESLIGAMENTO" DATE, 
	"DT_FIM_VIGENCIA" DATE, 
	"NB_INICIO_HORARIO" VARCHAR2(20 BYTE), 
	"NB_FIM_HORARIO" VARCHAR2(20 BYTE), 
	"TX_PLANO_ATIVIDADE" VARCHAR2(2000 BYTE), 
	"CS_TIPO" NUMBER(*,0), 
	"TX_TCE" VARCHAR2(20 BYTE), 
	"ID_UNIDADE_ORG" NUMBER(*,0), 
	"ID_SELECAO_ESTAGIO" NUMBER(*,0), 
	"ID_RECRUTAMENTO_ESTAGIO" NUMBER(*,0), 
	"NB_VAGAS_RECRUTAMENTO" NUMBER(*,0), 
	"NB_CANDIDATO" NUMBER(*,0), 
	"CS_TIPO_VAGA_ESTAGIO" NUMBER(*,0), 
	"CS_PERIODO" NUMBER(*,0), 
	"CS_HORARIO_CURSO" NUMBER(*,0), 
	"ID_AGENCIA_ESTAGIO" NUMBER(*,0), 
	"TX_EMAIL" VARCHAR2(255 BYTE), 
	"TX_TELEFONE" VARCHAR2(255 BYTE), 
	"TX_ENDERECO" VARCHAR2(255 BYTE), 
	"TX_CODIGO" VARCHAR2(20 BYTE), 
	"ID_USUARIO_CADASTRO" NUMBER(*,0), 
	"ID_USUARIO_ATUALIZACAO" NUMBER(*,0), 
	"CS_SELECAO" NUMBER(*,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."CONTRATO_ESTAGIO"."ID_PESSOA_ESTAGIARIO" IS 'Ã o identificador Ãºnico das pessoa fÃ­sicas.';
 
   COMMENT ON COLUMN "SEMAD"."CONTRATO_ESTAGIO"."ID_PESSOA_SUPERVISOR" IS 'Ã o identificador Ãºnico das pessoa fÃ­sicas.';
 
   COMMENT ON COLUMN "SEMAD"."CONTRATO_ESTAGIO"."CS_TIPO" IS '1 - Contrato Inicial
2 - Aditivo Contratual';
 
   COMMENT ON COLUMN "SEMAD"."CONTRATO_ESTAGIO"."ID_UNIDADE_ORG" IS 'Identificador Ãºnico de uma unidade organizacional.';
 
   COMMENT ON COLUMN "SEMAD"."CONTRATO_ESTAGIO"."CS_PERIODO" IS '1 - 1 ano
2 - 2 ano
3 - 3 ano
4 - 4 ano
5 - 5 ano
6 - 1 perÃ­odo
7 - 2 periodo
8 - 3 periodo
9 - 4 perÃ­odo
10 - 5 periodo
11 - 6 periodo
12 - 7 perÃ­odo
13 - 8 periodo
14 - 9 periodo
15 - 10 perÃ­odo';
 
   COMMENT ON COLUMN "SEMAD"."CONTRATO_ESTAGIO"."CS_HORARIO_CURSO" IS '1 - ManhÃ£
2 - Tarde
3 - Noite';
 
   COMMENT ON COLUMN "SEMAD"."CONTRATO_ESTAGIO"."CS_SELECAO" IS '1 - Com seleÃ§Ã£o 2 - Sem seleÃ§Ã£o';
--------------------------------------------------------
--  DDL for Table CURSO_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."CURSO_ESTAGIO" 
   (	"ID_CURSO_ESTAGIO" NUMBER(*,0), 
	"TX_CURSO_ESTAGIO" VARCHAR2(255 BYTE), 
	"CS_AREA_CONHECIMENTO" NUMBER(*,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Table ITEM_PAGAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."ITEM_PAGAMENTO_ESTAGIO" 
   (	"ID_ITEM_PAGAMENTO_ESTAGIO" NUMBER(*,0), 
	"TX_CODIGO" VARCHAR2(20 BYTE), 
	"TX_DESCRICAO" VARCHAR2(255 BYTE), 
	"TX_SIGLA" VARCHAR2(20 BYTE), 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"CS_TIPO" NUMBER(*,0), 
	"CS_SITUACAO" NUMBER(*,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."ITEM_PAGAMENTO_ESTAGIO"."CS_TIPO" IS '1 - CrÃ©dito
2 - DÃ©bito
3 - Informativo';
 
   COMMENT ON COLUMN "SEMAD"."ITEM_PAGAMENTO_ESTAGIO"."CS_SITUACAO" IS '1 - Ativo
2 - Desativado';
--------------------------------------------------------
--  DDL for Table ITEM_PAG_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."ITEM_PAG_ESTAGIO" 
   (	"ID_PAGAMENTO_ESTAGIO" NUMBER(*,0), 
	"ID_ITEM_PAGAMENTO_ESTAGIO" NUMBER(*,0), 
	"DT_PROCESSAMENTO" DATE, 
	"NB_VALOR_BASE" NUMBER(12,2), 
	"NB_VALOR_CALCULADO" NUMBER(12,2), 
	"NB_VALOR_UNITARIO" NUMBER(12,2), 
	"NB_QUANTIDADE" NUMBER(12,2), 
	"ID_USUARIO" NUMBER, 
	"ID_CONTRATO" NUMBER(*,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."ITEM_PAG_ESTAGIO"."ID_USUARIO" IS 'CÃ³digo do usuÃ¡rio do BD.';
--------------------------------------------------------
--  DDL for Table ORGAO_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."ORGAO_ESTAGIO" 
   (	"ID_ORGAO_ESTAGIO" NUMBER(*,0), 
	"TX_ORGAO_ESTAGIO" VARCHAR2(255 BYTE), 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"ID_UNIDADE_ORG" NUMBER(*,0), 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"CS_STATUS" NUMBER, 
	"TX_CNPJ" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."ORGAO_ESTAGIO"."ID_UNIDADE_ORG" IS 'Identificador Ãºnico de uma unidade organizacional.';
 
   COMMENT ON COLUMN "SEMAD"."ORGAO_ESTAGIO"."ID_USUARIO_CADASTRO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."ORGAO_ESTAGIO"."ID_USUARIO_ATUALIZACAO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."ORGAO_ESTAGIO"."CS_STATUS" IS '1 - Ativado
2 - Desativado';
--------------------------------------------------------
--  DDL for Table PAGAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."PAGAMENTO_ESTAGIO" 
   (	"ID_PAGAMENTO_ESTAGIO" NUMBER(*,0), 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"NB_ANO" NUMBER(*,0), 
	"NB_MES" NUMBER(*,0), 
	"CS_SITUACAO" NUMBER(*,0), 
	"NB_DIAS_UTEIS" NUMBER(*,0), 
	"ID_ORGAO_ESTAGIO" NUMBER(*,0), 
	"ID_ORGAO_GESTOR_ESTAGIO" NUMBER(*,0), 
	"ID_AGENCIA_ESTAGIO" NUMBER(*,0), 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"CS_TIPO_PAG_ESTAGIO" NUMBER(*,0), 
	"DT_INICIO_COMPETENCIA" DATE, 
	"DT_FIM_COMPETENCIA" DATE, 
	"DT_INICIO_FREQUENCIA" DATE, 
	"DT_FIM_FREQUENCIA" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."PAGAMENTO_ESTAGIO"."CS_SITUACAO" IS '1 - Aberto
2 - Fechado
3 - Cancelado';
 
   COMMENT ON COLUMN "SEMAD"."PAGAMENTO_ESTAGIO"."ID_USUARIO_CADASTRO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."PAGAMENTO_ESTAGIO"."ID_USUARIO_ATUALIZACAO" IS 'CÃ³digo do usuÃ¡rio do BD.';
--------------------------------------------------------
--  DDL for Table QUADRO_VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" 
   (	"ID_QUADRO_VAGAS_ESTAGIO" NUMBER(*,0), 
	"ID_ORGAO_GESTOR_ESTAGIO" NUMBER(*,0), 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"CS_SITUACAO" NUMBER(*,0), 
	"TX_CODIGO" VARCHAR2(20 BYTE), 
	"ID_CONTRATO_CP" NUMBER(*,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."QUADRO_VAGAS_ESTAGIO"."ID_USUARIO_ATUALIZACAO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."QUADRO_VAGAS_ESTAGIO"."ID_USUARIO_CADASTRO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."QUADRO_VAGAS_ESTAGIO"."CS_SITUACAO" IS '1 - Ativo
2 - Desativado';
--------------------------------------------------------
--  DDL for Table RECESSO_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."RECESSO_ESTAGIO" 
   (	"ID_RECESSO_ESTAGIO" NUMBER(*,0), 
	"TX_CODIGO" VARCHAR2(20 BYTE), 
	"TX_CARGO_AGENTE" VARCHAR2(255 BYTE), 
	"TX_EMAIL_AGENTE" VARCHAR2(255 BYTE), 
	"TX_TELEFONE_AGENTE" VARCHAR2(255 BYTE), 
	"DT_INICIO_VIG_ESTAGIO" DATE, 
	"TX_JUSTIFICATIVA_ADIAMENTO" VARCHAR2(255 BYTE), 
	"DT_ADIAMENTO" DATE, 
	"ID_CONTRATO" NUMBER(*,0), 
	"ID_SETORIAL_ESTAGIO" NUMBER(*,0), 
	"ID_AGENCIA_ESTAGIO" NUMBER(*,0), 
	"ID_ORGAO_ESTAGIO" NUMBER(*,0), 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"CS_SITUACAO" NUMBER(*,0), 
	"DT_FIM_VIGENCIA_ESTAGIO" DATE, 
	"DT_INICIO_RECESSO" DATE, 
	"DT_FIM_RECESSO" DATE, 
	"NB_MES_REFERENCIA" NUMBER(*,0), 
	"NB_ANO_REFERENCIA" NUMBER(*,0), 
	"DT_ASSINATURA" DATE, 
	"TX_MATRICULA" VARCHAR2(20 BYTE), 
	"NB_DIAS_RESTANTES" NUMBER(*,0), 
	"TX_CHEFIA_IMEDIATA" VARCHAR2(255 BYTE), 
	"CS_REALIZACAO" NUMBER(*,0), 
	"ID_ORGAO_GESTOR_ESTAGIO" NUMBER(*,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."RECESSO_ESTAGIO"."DT_CADASTRO" IS '';
 
   COMMENT ON COLUMN "SEMAD"."RECESSO_ESTAGIO"."ID_USUARIO_CADASTRO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."RECESSO_ESTAGIO"."ID_USUARIO_ATUALIZACAO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."RECESSO_ESTAGIO"."CS_SITUACAO" IS '1 - Aberta
2 - Fechada';
 
   COMMENT ON COLUMN "SEMAD"."RECESSO_ESTAGIO"."CS_REALIZACAO" IS '1 - Realizado
2 - Postergado Totalmente
3 - Postergado Parcialmente';
--------------------------------------------------------
--  DDL for Table RECRUTAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" 
   (	"ID_RECRUTAMENTO_ESTAGIO" NUMBER(*,0), 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"ID_QUADRO_VAGAS_ESTAGIO" NUMBER(*,0), 
	"ID_ORGAO_ESTAGIO" NUMBER(*,0), 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"TX_DOC_AUTORIZACAO" VARCHAR2(20 BYTE), 
	"TX_MOTIVO" VARCHAR2(255 BYTE), 
	"TX_COD_RECRUTAMENTO" VARCHAR2(20 BYTE), 
	"CS_SITUACAO" NUMBER(*,0), 
	"ID_SOLICITACAO_ESTAGIO" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."RECRUTAMENTO_ESTAGIO"."ID_USUARIO_CADASTRO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."RECRUTAMENTO_ESTAGIO"."ID_USUARIO_ATUALIZACAO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."RECRUTAMENTO_ESTAGIO"."CS_SITUACAO" IS '1 - Aberto  2 - Fechado';
--------------------------------------------------------
--  DDL for Table SELECAO_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."SELECAO_ESTAGIO" 
   (	"ID_SELECAO_ESTAGIO" NUMBER(*,0), 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"ID_ORGAO_ESTAGIO" NUMBER(*,0), 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"TX_COD_SELECAO" VARCHAR2(20 BYTE), 
	"ID_ORGAO_GESTOR_ESTAGIO" NUMBER(*,0), 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"CS_SITUACAO" NUMBER(*,0), 
	"CS_SELECAO" NUMBER, 
	"ID_OFERTA_VAGA" NUMBER, 
	"ID_AGENCIA_ESTAGIO" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."SELECAO_ESTAGIO"."ID_USUARIO_CADASTRO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."SELECAO_ESTAGIO"."ID_USUARIO_ATUALIZACAO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."SELECAO_ESTAGIO"."CS_SITUACAO" IS '1-Aberta; 
2-Efetivada; 
3-SeleÃ§Ã£o Encaminhada; 
4-Cancelada.';
 
   COMMENT ON COLUMN "SEMAD"."SELECAO_ESTAGIO"."CS_SELECAO" IS '1 - com oferta, 2 - sem oferta';
--------------------------------------------------------
--  DDL for Table SOLICITACAO_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."SOLICITACAO_ESTAGIO" 
   (	"ID_SOLICITACAO_ESTAGIO" NUMBER(*,0), 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"TX_COD_SOLICITACAO" VARCHAR2(20 BYTE), 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"ID_ORGAO_ESTAGIO" NUMBER(*,0), 
	"ID_ORGAO_GESTOR_ESTAGIO" NUMBER(*,0), 
	"TX_JUSTIFICATIVA" VARCHAR2(255 BYTE), 
	"CS_SITUACAO" NUMBER(*,0), 
	"ID_QUADRO_VAGAS_ESTAGIO" NUMBER(*,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."SOLICITACAO_ESTAGIO"."ID_USUARIO_ATUALIZACAO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."SOLICITACAO_ESTAGIO"."ID_USUARIO_CADASTRO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."SOLICITACAO_ESTAGIO"."CS_SITUACAO" IS '1 - Aberta
2 - Efetivada
3 - Cancelada';
--------------------------------------------------------
--  DDL for Table SUPERVISOR_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."SUPERVISOR_ESTAGIO" 
   (	"ID_PESSOA_SUPERVISOR" NUMBER(*,0), 
	"ID_PESSOA_FUNCIONARIO" NUMBER(*,0), 
	"NB_FUNCIONARIO" NUMBER(*,0), 
	"TX_CURRICULO" VARCHAR2(2000 BYTE), 
	"ID_CONSELHO" NUMBER, 
	"NB_INSCRICAO_CONSELHO" VARCHAR2(80 BYTE), 
	"TX_FORMACAO" VARCHAR2(255 BYTE), 
	"TX_CARGO" VARCHAR2(255 BYTE), 
	"TX_TEMPO_EXPERIENCIA" VARCHAR2(20 BYTE), 
	"TX_EMAIL" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."SUPERVISOR_ESTAGIO"."ID_PESSOA_SUPERVISOR" IS 'Ã o identificador Ãºnico das pessoa fÃ­sicas.';
 
   COMMENT ON COLUMN "SEMAD"."SUPERVISOR_ESTAGIO"."ID_PESSOA_FUNCIONARIO" IS 'Ã o identificador Ãºnico das pessoa fÃ­sicas.';
--------------------------------------------------------
--  DDL for Table TIPO_PAG_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."TIPO_PAG_ESTAGIO" 
   (	"CS_TIPO_PAG_ESTAGIO" NUMBER(*,0), 
	"TX_TIPO_PAG_ESTAGIO" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Table TIPO_VAGA_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."TIPO_VAGA_ESTAGIO" 
   (	"CS_TIPO_VAGA_ESTAGIO" NUMBER(*,0), 
	"TX_TIPO_VAGA_ESTAGIO" VARCHAR2(255 BYTE), 
	"ID_BOLSA_ESTAGIO" NUMBER(*,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Table VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."VAGAS_ESTAGIO" 
   (	"ID_QUADRO_VAGAS_ESTAGIO" NUMBER(*,0), 
	"ID_ORGAO_ESTAGIO" NUMBER(*,0), 
	"NB_QUANTIDADE" NUMBER(*,0), 
	"CS_TIPO_VAGA_ESTAGIO" NUMBER(*,0), 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"ID_CURSO_ESTAGIO" NUMBER(*,0), 
	"ID_AGENCIA_ESTAGIO" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."VAGAS_ESTAGIO"."ID_USUARIO_CADASTRO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."VAGAS_ESTAGIO"."ID_USUARIO_ATUALIZACAO" IS 'CÃ³digo do usuÃ¡rio do BD.';
--------------------------------------------------------
--  DDL for Table ESTAGIARIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."ESTAGIARIO" 
   (	"ID_PESSOA_ESTAGIARIO" NUMBER(*,0), 
	"ID_PESSOA_FUNCIONARIO" NUMBER(*,0), 
	"NB_FUNCIONARIO" NUMBER(*,0), 
	"TX_CEP" VARCHAR2(20 BYTE), 
	"TX_ENDERECO" VARCHAR2(255 BYTE), 
	"NB_NUMERO" NUMBER, 
	"TX_COMPLEMENTO" VARCHAR2(255 BYTE), 
	"TX_BAIRRO" VARCHAR2(100 BYTE), 
	"TX_AGENCIA" VARCHAR2(20 BYTE), 
	"TX_CONTA_CORRENTE" VARCHAR2(20 BYTE), 
	"TX_CONTATO" VARCHAR2(180 BYTE), 
	"TX_EMAIL" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."ESTAGIARIO"."ID_PESSOA_ESTAGIARIO" IS 'Ã o identificador Ãºnico das pessoa fÃ­sicas.';
 
   COMMENT ON COLUMN "SEMAD"."ESTAGIARIO"."ID_PESSOA_FUNCIONARIO" IS 'Ã o identificador Ãºnico das pessoa fÃ­sicas.';
--------------------------------------------------------
--  DDL for Table ESTAGIARIO_CONTRATO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."ESTAGIARIO_CONTRATO" 
   (	"ID_CONTRATO" NUMBER, 
	"NB_ESTAGIARIO_CONTRATO" NUMBER, 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"NB_VIGENCIA" NUMBER, 
	"DT_INICIO_PRORROGACAO" DATE, 
	"DT_FIM_PRORROGACAO" DATE, 
	"DT_INICIO_RECESSO" DATE, 
	"DT_FIM_RECESSO" DATE, 
	"NB_JORNADA" NUMBER, 
	"DT_INICIO_JORNADA" DATE, 
	"TX_INICIO_HORARIO" VARCHAR2(20 BYTE), 
	"TX_FIM_HORARIO" VARCHAR2(20 BYTE), 
	"NB_BOLSA" NUMBER, 
	"DT_INICIO_PAG_BOLSA" DATE, 
	"NB_VALOR_BOLSA" NUMBER, 
	"NB_SUPERVISOR" NUMBER, 
	"ID_PESSOA_SUPERVISOR" VARCHAR2(20 BYTE), 
	"NB_ALTERACOES" NUMBER, 
	"TX_OUTRAS_ALTERACOES" VARCHAR2(4000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Table ESTAGIARIO_SELECAO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."ESTAGIARIO_SELECAO" 
   (	"ID_SELECAO_ESTAGIO" NUMBER(*,0), 
	"CS_SITUACAO" NUMBER(*,0), 
	"TX_MOTIVO_SITUACAO" VARCHAR2(255 BYTE), 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"ID_PESSOA_ESTAGIARIO" NUMBER(*,0), 
	"CS_ESCOLARIDADE" NUMBER, 
	"ID_CURSO_ESTAGIO" NUMBER, 
	"NB_PERIODO_ANO" NUMBER, 
	"CS_TURNO" NUMBER, 
	"ID_INSTITUICAO_ENSINO" NUMBER, 
	"ID_ORGAO_ESTAGIO" NUMBER, 
	"CS_TIPO_VAGA_ESTAGIO" NUMBER, 
	"TX_HORA_INICIO" VARCHAR2(20 BYTE), 
	"TX_HORA_FINAL" VARCHAR2(20 BYTE), 
	"ID_BOLSA_ESTAGIO" NUMBER, 
	"ID_PESSOA_SUPERVISOR" NUMBER, 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"CS_CARGA_HORARIA" NUMBER, 
	"TX_ATIVIDADES" VARCHAR2(400 BYTE), 
	"NB_VALOR_TRANSPORTE" NUMBER, 
	"TX_LOCAL_ESTAGIO" VARCHAR2(255 BYTE), 
	"DT_INICIO" DATE, 
	"DT_FINAL" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."ESTAGIARIO_SELECAO"."CS_SITUACAO" IS '1 - Em AnÃ¡lise; 
2 - Aprovado; 
3 - Reprovado; 
4 - Cancelado; 
5 - Autorizado.';
 
   COMMENT ON COLUMN "SEMAD"."ESTAGIARIO_SELECAO"."ID_USUARIO_CADASTRO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."ESTAGIARIO_SELECAO"."ID_PESSOA_ESTAGIARIO" IS '';
--------------------------------------------------------
--  DDL for Table ESTAGIARIO_VAGA
--------------------------------------------------------

  CREATE TABLE "SEMAD"."ESTAGIARIO_VAGA" 
   (	"ID_RECRUTAMENTO_ESTAGIO" NUMBER(*,0), 
	"NB_VAGAS_RECRUTAMENTO" NUMBER(*,0), 
	"NB_CANDIDATO" NUMBER(*,0), 
	"CS_SITUACAO" NUMBER(*,0), 
	"TX_MOTIVO_SITUACAO" VARCHAR2(255 BYTE), 
	"ID_PESSOA_ESTAGIARIO" NUMBER(*,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."ESTAGIARIO_VAGA"."CS_SITUACAO" IS '1 - Em AnÃ¡lise
2 - Aprovado
3 - Reprovado
4 - Cancelado';
 
   COMMENT ON COLUMN "SEMAD"."ESTAGIARIO_VAGA"."ID_PESSOA_ESTAGIARIO" IS 'Ã o identificador Ãºnico das pessoa fÃ­sicas.';
--------------------------------------------------------
--  DDL for Table UNIDADE_ORG
--------------------------------------------------------

  CREATE TABLE "SEMAD"."UNIDADE_ORG" 
   (	"ID_UNIDADE_ORG" NUMBER, 
	"TX_UNIDADE_ORG" VARCHAR2(120 BYTE), 
	"TX_SIGLA_UNIDADE" VARCHAR2(30 BYTE), 
	"CS_TIPO_UNID_ORG" NUMBER(*,0), 
	"CS_POSSUI_ORCAMENTO" NUMBER(*,0) DEFAULT 1, 
	"CS_ATIVA" NUMBER(*,0) DEFAULT 0, 
	"DT_CADASTRO" DATE, 
	"DT_COMPOSICAO" DATE, 
	"NB_CODIGO_UNIDADE" VARCHAR2(50 BYTE), 
	"CS_TIPO_AUTORIDADE" NUMBER(*,0), 
	"ID_SISTEMA_GESTAO" NUMBER(*,0), 
	"CS_NIVEL_ADMINISTRATIVO_ORG" NUMBER(*,0), 
	"FK_UNIDADE_ORG" NUMBER, 
	"BL_LOGO" LONG RAW, 
	"TX_MISSAO" VARCHAR2(4000 BYTE), 
	"CS_LOTACAO" NUMBER, 
	"CS_UNID_GEST_AQUISICAO" NUMBER, 
	"CS_UNID_GEST_PATRIMONIO" NUMBER, 
	"CS_UNID_GEST_CELULAR" NUMBER, 
	"CS_ESCOLA" NUMBER, 
	"CS_TIPO_ADM" NUMBER, 
	"NB_COD_UNID_PAT" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."UNIDADE_ORG"."ID_UNIDADE_ORG" IS 'Identificador Ãºnico de uma unidade organizacional.';
 
   COMMENT ON COLUMN "SEMAD"."UNIDADE_ORG"."TX_UNIDADE_ORG" IS 'DenominaÃ§Ã£o da unidade organizacional.';
 
   COMMENT ON COLUMN "SEMAD"."UNIDADE_ORG"."TX_SIGLA_UNIDADE" IS 'Sigla da unidade organizacional.';
 
   COMMENT ON COLUMN "SEMAD"."UNIDADE_ORG"."CS_TIPO_UNID_ORG" IS 'Identificador do tipo de unidade organizacional.';
 
   COMMENT ON COLUMN "SEMAD"."UNIDADE_ORG"."CS_POSSUI_ORCAMENTO" IS 'Indica se a unidade possui orÃ§amento prÃ³prio.';
 
   COMMENT ON COLUMN "SEMAD"."UNIDADE_ORG"."DT_CADASTRO" IS 'Data de cadastro da unidade organizacional.';
 
   COMMENT ON COLUMN "SEMAD"."UNIDADE_ORG"."DT_COMPOSICAO" IS 'Data da composiÃ§Ã£o da unidade organizacional. A composiÃ§Ã£o identifica as unidades organizacionais que pertencem a hierarquia de uma determinada unidade organizacional.';
 
   COMMENT ON COLUMN "SEMAD"."UNIDADE_ORG"."NB_CODIGO_UNIDADE" IS 'CÃ³digo para identificaÃ§Ã£o da unidade organizacional.';
 
   COMMENT ON COLUMN "SEMAD"."UNIDADE_ORG"."CS_TIPO_AUTORIDADE" IS 'Indica o tipo de autoridade que a unidade organizacional possui.';
 
   COMMENT ON COLUMN "SEMAD"."UNIDADE_ORG"."ID_SISTEMA_GESTAO" IS 'Identificador Ãºnico do sistema de gestÃ£o de uma organizaÃ§Ã£o.';
 
   COMMENT ON COLUMN "SEMAD"."UNIDADE_ORG"."CS_NIVEL_ADMINISTRATIVO_ORG" IS 'Indica o nÃ­vel administrativo da unidade organizacional.';
 
   COMMENT ON COLUMN "SEMAD"."UNIDADE_ORG"."FK_UNIDADE_ORG" IS 'Identificador Ãºnico de uma unidade organizacional.';
 
   COMMENT ON TABLE "SEMAD"."UNIDADE_ORG"  IS 'Representa as unidades operacionais da PMM. (orgÃ£os, departamentos, coordenadorias, assessorias, divisÃµes, seÃ§Ãµes, etc..)';
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "BANCOPRECO";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "BP_FINALIZADORES";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PONTOELETRONICO_ADMIN";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "XPTO_CONNECT";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "LICITAC?O";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "ESTOQUE";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "Q_BANCO_PRECOS";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "ZOPE_ROLE";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "ORGANIZACIONAL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "BP_CADASTRO";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PROT_SEMSA";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PROT_LICITACAO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "BP_CONSULTA";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "APLICAR_PESSOAS";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PROT_CONSULTORES";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PROT_TRAMITE";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "CONTAS_PUBLICAS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "BP_MATERIAL";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PROT_CONS_EXT";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PATRIMONIO";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "COLETORDEPONTO";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PROT_TRAM_SEMSA";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "GERENTE_SISTEMAS";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PROT_IMPLURB";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PROT_CONS_IMPL";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PROT_TRAM_IMPL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "WOKF_EXTERNO";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "ESTOQUE_CONSULTA";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PROT_CML";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PONTO_SEMEF";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PONTO_CONS_SEMEF";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "ESTOQUE_KITS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "REGISTROPRECOS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PONTO_SEMAD";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "USUARIO_ADMIN";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PONTO_CONSULTA";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PONTOELETRONICOV2";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PONTO_SEMASC";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "ESTOQUE_ADMIN";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "GESTAOCONTASPUBLICAS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PONTO_SEMASDH";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "GESTAOESCOLAR";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "EST_OPERADOR";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "EST_ATENDENTE";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "EST_AUTORIZACAO";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "EST_GESTOR";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "GE_OPERADOR";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PONTO_SEMINF";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PONTO_MANAUSTRANS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "R_BANCOPRECOS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PONTO_SEMMAS";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "SEMAD_LNK";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "THIAGO";
 
  GRANT UPDATE ON "SEMAD"."UNIDADE_ORG" TO "ZOPEPROD";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "VALERIA";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "ROSANA";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "TACIANA";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PEDRO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "JUSSARA";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "VALDERI";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "SARYTA_GARCEZ";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "IWAMOTO";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "BERNARDO";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "ANDRE_PINHEIRO";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "IVY_SA";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PONTO_FDT";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PONTO2";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "VOYAGE_SOLICITANTE";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "VOYAGE_GESTOR";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "WILMA_SILVA";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "EST_RM";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "PONTOELETRONICOV2_CONS";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "VOYAGE_GESTOR_PASSAGEM";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "ROBSON";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "NEILA_SEMAD";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "JURIDICO";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "KEYCE_MARQUES";
 
  GRANT ALTER, SELECT, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "JURIDICO_CONSULTA";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "JURIDICO_OPERACIONAL";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "JURIDICO_GESTORAUXILIAR";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "JURIDICO_GESTOR";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "JURIDICO_OPERACIONALTCE";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "EST_ALMOXPEQUENOS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "ORGANIZACIONAL_ADM";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "PATRIMONIO_IMOVEL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PATRIMONIO_IMOVEL_REL";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "PATRIMONIO_MOVEL_CAD";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PATRIMONIO_MOVEL_REL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "GESTAOCONTASPUBLICAS_CEL";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "GESTAOCONTASPUBLICAS_AGUA";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "GESTAOCONTASPUBLICAS_AGUA_RE";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "GESTAOCONTASPUBLICAS_ENERGIA";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "GESTAOCONTASPUBLICAS_CONTRAT";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "GENILSON_ALVES";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "GESTAOESCOLAR_CONSULTA";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "JUR_DISTRIBUICAO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PATRIMONIO_MOVEL_MOV_IND";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "PATRIMONIO_CONS";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "VOYAGE_CONS";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "GESTAOCONTASPUBLICAS_CONS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "IRP";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "TESTES";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."UNIDADE_ORG" TO "PONTOELETRONICOV2_FISCALIZAC";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "PONTOELETRONICOV2_RH";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "EST_CONTABIL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "IRP_GESTOR_RP";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "IRP_GESTOR_BP";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "IRP_GESTOR_CATALOGACAO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."UNIDADE_ORG" TO "IRP_SOLICITANTE";
 
  GRANT SELECT ON "SEMAD"."UNIDADE_ORG" TO "HABITACAO";
--------------------------------------------------------
--  DDL for Table USUARIO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."USUARIO" 
   (	"ID_USUARIO" NUMBER(5,0), 
	"TX_LOGIN" VARCHAR2(20 BYTE), 
	"CS_SITUACAO" NUMBER DEFAULT 0, 
	"TX_CONFIGURACAO" LONG, 
	"ID_PESSOA_FUNCIONARIO" NUMBER, 
	"TX_MOTIVO_SITUACAO" VARCHAR2(200 BYTE), 
	"ID_UNIDADE_GESTORA" NUMBER, 
	"DT_ULTIMO_ACESSO" DATE, 
	"TX_IP_ULTIMO_ACESSO" VARCHAR2(15 BYTE), 
	"TX_EMAIL_PMM" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SCA_DATA" ;
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "BANCOPRECO";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "BP_FINALIZADORES";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "AUDITORIA";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "XPTO_CONNECT";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "ADMINISTRADORES";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "LICITAC?O";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "ESTOQUE";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "Q_BANCO_PRECOS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "BP_CADASTRO";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PROT_SEMSA";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PROT_LICITACAO";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "BP_CONSULTA";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "APLICAR_PESSOAS";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PROT_CONSULTORES";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PROT_TRAMITE";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "CONTAS_PUBLICAS";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "BP_MATERIAL";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "WORKFLOW";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PROT_CONS_EXT";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "PATRIMONIO";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "COLETORDEPONTO";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PROT_TRAM_SEMSA";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PONTO_ELETRONICO";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PROT_IMPLURB";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PROT_CONS_IMPL";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PROT_TRAM_IMPL";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "WOKF_EXTERNO";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "ESTOQUE_CONSULTA";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PROT_CML";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PRE_CADASTRO";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PONTO_SEMEF";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "ESTOQUE_KITS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "REGISTROPRECOS";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "USUARIO_ADMIN";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "ESTOQUE_ADMIN";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "GESTAOCONTASPUBLICAS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "GESTAOESCOLAR";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "EST_OPERADOR";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "EST_ATENDENTE";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "EST_AUTORIZACAO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "EST_GESTOR";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "GE_OPERADOR";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "R_BANCOPRECOS";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "EST_RECEBIMENTO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "GE_GESTOR";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "SEMAD_LNK";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "THIAGO";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "VALERIA";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "ROSANA";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "TACIANA";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "MAYCON";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "JUSSARA";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "VALDERI";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "SARYTA_GARCEZ";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "IWAMOTO";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "BERNARDO";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "ANDRE_PINHEIRO";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "IVY_SA";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "VOYAGE_SOLICITANTE";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "VOYAGE_GESTOR";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "EST_RM";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "VOYAGE_GESTOR_PASSAGEM";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "ROBSON";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "NEILA_SEMAD";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "JURIDICO";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PGM";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "KEYCE_MARQUES";
 
  GRANT ALTER, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "JURIDICO_CONSULTA";
 
  GRANT ALTER, SELECT, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "JURIDICO_OPERACIONAL";
 
  GRANT ALTER, SELECT, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "JURIDICO_GESTORAUXILIAR";
 
  GRANT ALTER, SELECT, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "JURIDICO_GESTOR";
 
  GRANT ALTER, SELECT, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "JURIDICO_OPERACIONALTCE";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "EST_ALMOXPEQUENOS";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "HABITACAO_CADASTRO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "PATRIMONIO_IMOVEL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "PATRIMONIO_IMOVEL_REL";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "PATRIMONIO_MOVEL_CAD";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "PATRIMONIO_MOVEL_REL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "GESTAOCONTASPUBLICAS_CEL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "GESTAOCONTASPUBLICAS_TEL";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "GESTAOCONTASPUBLICAS_AGUA";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "GESTAOCONTASPUBLICAS_ENERGIA";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "GESTAOESCOLAR_CONSULTA";
 
  GRANT ALTER, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "JUR_DISTRIBUICAO";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "EMANUELLE_ALVES";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "JAMILE_BREVAL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "PATRIMONIO_MOVEL_MOV_IND";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "PATRIMONIO_CONS";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "VOYAGE_CONS";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "GESTAOCONTASPUBLICAS_CONS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "IRP";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "TESTES";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "PONTOELETRONICOV2_RH";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "EST_CONTABIL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "IRP_GESTOR_RP";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "IRP_GESTOR_BP";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "IRP_GESTOR_CATALOGACAO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."USUARIO" TO "IRP_SOLICITANTE";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "EST_INVENTARIO";
 
  GRANT SELECT ON "SEMAD"."USUARIO" TO "HABITACAO";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."USUARIO" TO "PATRIMONIO_MOVEL_MOVI";
--------------------------------------------------------
--  DDL for Table INSTITUICAO_ENSINO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."INSTITUICAO_ENSINO" 
   (	"ID_INSTITUICAO_ENSINO" NUMBER(*,0), 
	"TX_INSTITUICAO_ENSINO" VARCHAR2(255 BYTE), 
	"TX_SIGLA" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Table AREA_CONHECIMENTO_GE
--------------------------------------------------------

  CREATE TABLE "SEMAD"."AREA_CONHECIMENTO_GE" 
   (	"CS_AREA_CONHECIMENTO" NUMBER(*,0), 
	"TX_AREA_CONHECIMENTO" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."AREA_CONHECIMENTO_GE" TO "GESTAOESCOLAR";
 
  GRANT SELECT ON "SEMAD"."AREA_CONHECIMENTO_GE" TO "GESTAOESCOLAR_CONSULTA";
--------------------------------------------------------
--  DDL for Table CONTRATO_CP
--------------------------------------------------------

  CREATE TABLE "SEMAD"."CONTRATO_CP" 
   (	"ID_CONTRATO_CP" NUMBER(*,0), 
	"NB_CODIGO" VARCHAR2(20 BYTE), 
	"DT_INICIO_VALIDADE" DATE, 
	"DT_FIM_VALIDADE" DATE, 
	"CS_TIPO_PRAZO" NUMBER(*,0), 
	"NB_PROC_ADMIN" VARCHAR2(50 BYTE), 
	"NB_VALOR_GLOBAL" NUMBER(12,2), 
	"TX_OBJETO" VARCHAR2(2000 BYTE), 
	"DT_CADASTRO" DATE, 
	"DT_ALTERACAO" DATE, 
	"NB_PRAZO" NUMBER(*,0), 
	"ID_UNID_GEST_RESP" NUMBER(*,0), 
	"ID_UNID_GEST_CADASTRO" NUMBER(*,0), 
	"ID_PESSOA_RESP" NUMBER(*,0), 
	"ID_PESSOA_CADASTRO" NUMBER(*,0), 
	"ID_UNID_GEST_ALTERACAO" NUMBER(*,0), 
	"ID_PESSOA_ALTERACAO" NUMBER(*,0), 
	"TX_OBSERVACAO" VARCHAR2(2000 BYTE), 
	"ID_UNIDADE_ORC" NUMBER, 
	"CS_TIPO_CONTRATO_CP" NUMBER, 
	"ID_MODALIDADE_CP" NUMBER, 
	"ID_PESSOA" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."CONTRATO_CP"."ID_PESSOA_RESP" IS 'Ã o identificador Ãºnico das pessoa fÃ­sicas que sÃ£o funcionÃ¡rios da PMM.';
 
   COMMENT ON COLUMN "SEMAD"."CONTRATO_CP"."ID_PESSOA_CADASTRO" IS 'Ã o identificador Ãºnico das pessoa fÃ­sicas que sÃ£o funcionÃ¡rios da PMM.';
 
   COMMENT ON COLUMN "SEMAD"."CONTRATO_CP"."ID_PESSOA_ALTERACAO" IS 'Ã o identificador Ãºnico das pessoa fÃ­sicas que sÃ£o funcionÃ¡rios da PMM.';
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."CONTRATO_CP" TO "GESTAOCONTASPUBLICAS";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."CONTRATO_CP" TO "THIAGOQUEIROZ";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."CONTRATO_CP" TO "GESTAOCONTASPUBLICAS_AGUA";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."CONTRATO_CP" TO "GESTAOCONTASPUBLICAS_ENERGIA";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."CONTRATO_CP" TO "GESTAOCONTASPUBLICAS_CONTRAT";
 
  GRANT SELECT ON "SEMAD"."CONTRATO_CP" TO "GESTAOCONTASPUBLICAS_CONS";
--------------------------------------------------------
--  DDL for Table OFERTA_VAGA
--------------------------------------------------------

  CREATE TABLE "SEMAD"."OFERTA_VAGA" 
   (	"ID_OFERTA_VAGA" NUMBER, 
	"TX_CODIGO_OFERTA_VAGA" VARCHAR2(20 BYTE), 
	"ID_ORGAO_GESTOR_ESTAGIO" NUMBER, 
	"ID_ORGAO_ESTAGIO" NUMBER, 
	"ID_QUADRO_VAGAS_ESTAGIO" NUMBER, 
	"ID_AGENCIA_ESTAGIO" NUMBER, 
	"CS_TIPO_VAGA_ESTAGIO" NUMBER, 
	"TX_PESSOA_CONTATO" VARCHAR2(100 BYTE), 
	"TX_TELEFONE" VARCHAR2(20 BYTE), 
	"TX_CARGO_FUNCAO" VARCHAR2(100 BYTE), 
	"TX_EMAIL" VARCHAR2(100 BYTE), 
	"TX_ENDERECO" VARCHAR2(200 BYTE), 
	"TX_PONTO_REFERENCIA" VARCHAR2(100 BYTE), 
	"TX_NUM_ONIBUS" VARCHAR2(20 BYTE), 
	"NB_QUANTIDADE" NUMBER, 
	"NB_QTDE_EMCAMINHADO" NUMBER, 
	"DT_ENTREVISTA" DATE, 
	"TX_HORARIO" VARCHAR2(20 BYTE), 
	"NB_DURACAO_ESTAGIO" NUMBER, 
	"ID_BOLSA_ESTAGIO" NUMBER, 
	"NB_VALOR_TRANSPORTE" NUMBER, 
	"CS_ESCOLARIDADE" NUMBER, 
	"ID_CURSO_ESTAGIO" NUMBER, 
	"NB_SEMESTRE" NUMBER, 
	"TX_HORA_INICIO" VARCHAR2(20 BYTE), 
	"TX_HORA_FINAL" VARCHAR2(20 BYTE), 
	"TX_OUTROS_HORARIOS" VARCHAR2(100 BYTE), 
	"CS_WINDOWS" NUMBER, 
	"CS_WORD" NUMBER, 
	"CS_EXCEL" NUMBER, 
	"CS_POWERPOINT" NUMBER, 
	"CS_INTERNET" NUMBER, 
	"CS_CORELDRAW" NUMBER, 
	"CS_PHOTOSHOP" NUMBER, 
	"CS_WEBDESIGN" NUMBER, 
	"CS_AUTOCAD" NUMBER, 
	"CS_INGLES" NUMBER, 
	"CS_ESPANHOL" NUMBER, 
	"CS_FRANCES" NUMBER, 
	"CS_ALEMAO" NUMBER, 
	"TX_OUTRAS_LINGUAS" VARCHAR2(100 BYTE), 
	"TX_OUTROS_REQUISITOS" VARCHAR2(100 BYTE), 
	"CS_SEXO" NUMBER, 
	"TX_ATIVIDADES" VARCHAR2(400 BYTE), 
	"TX_OBSERVACAO" VARCHAR2(200 BYTE), 
	"CS_SITUACAO" NUMBER, 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."OFERTA_VAGA"."CS_SITUACAO" IS '1-Aberta
2-Efetivada
3-Oferta Encaminhada
4-Cancelada';
--------------------------------------------------------
--  DDL for Table CONSELHO_PROFISSIONAL
--------------------------------------------------------

  CREATE TABLE "SEMAD"."CONSELHO_PROFISSIONAL" 
   (	"ID_CONSELHO" NUMBER, 
	"TX_CONSELHO" VARCHAR2(80 BYTE), 
	"TX_SIGLA_CONSELHO" VARCHAR2(20 BYTE), 
	"TX_REGIAO" VARCHAR2(20 BYTE), 
	"ID_UF" VARCHAR2(2 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" 
  PARALLEL ;
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "BANCOPRECO";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "BP_FINALIZADORES";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "LICITAC?O";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "FORNECEDORES";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "ESTOQUE";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "PARAMETRIZAC?O";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "PROT_SEMSA";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "PROT_LICITACAO";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "BP_CONSULTA";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "APLICAR_PESSOAS";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "EXECUCAO_ORCAMENTARIA";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "FORNEC_CONSULTA";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "PROT_IMPLURB";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "PROT_CML";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "LICITACAO_CONS";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "PRE_CADASTRO";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "PONTO_SEMEF";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "PONTO_CONS_SEMEF";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "PONTO_SEMASC";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "GESTAOESCOLAR";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "EST_OPERADOR";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "EST_ATENDENTE";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "GE_OPERADOR";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "R_BANCOPRECOS";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "SEMAD_LNK";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "PARAMETRIZACAO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "VOYAGE_SOLICITANTE";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "VOYAGE_GESTOR";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "VOYAGE_GESTOR_PASSAGEM";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "HIGOR_ROCHA";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "GESTAOESCOLAR_CONSULTA";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "VOYAGE_CONS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "PONTOELETRONICOV2_RH";
 
  GRANT SELECT ON "SEMAD"."CONSELHO_PROFISSIONAL" TO "GESTAOESPM";
-- NÃ£o Ã© possÃ­vel renderizar a DLL TABLE para o objeto SEMAD.FUNCIONARIO_PE com o DBMS_METADATA tentando um gerador interno.
CREATE INDEX SEMAD.XIF1FUNCIONARIO_PE ON SEMAD.FUNCIONARIO_PE (ID_UNIDADE_GESTORA ASC) 
LOGGING 
TABLESPACE "PMM_DATA" 
PCTFREE 10 
INITRANS 2 
STORAGE 
( 
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1 
  MAXEXTENTS 2147483645 
  BUFFER_POOL DEFAULT 
)
CREATE INDEX SEMAD.XIF2FUNCIONARIO_PE ON SEMAD.FUNCIONARIO_PE (ID_PESSOA_FUNCIONARIO ASC) 
LOGGING 
TABLESPACE "PMM_DATA" 
PCTFREE 10 
INITRANS 2 
STORAGE 
( 
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1 
  MAXEXTENTS 2147483645 
  BUFFER_POOL DEFAULT 
)
CREATE INDEX SEMAD.XIF3FUNCIONARIO_PE ON SEMAD.FUNCIONARIO_PE (CS_SITUACAO_FUNCIONARIO ASC) 
LOGGING 
TABLESPACE "PMM_DATA" 
PCTFREE 10 
INITRANS 2 
STORAGE 
( 
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1 
  MAXEXTENTS 2147483645 
  BUFFER_POOL DEFAULT 
)
CREATE INDEX SEMAD.XIF4FUNCIONARIO_PE ON SEMAD.FUNCIONARIO_PE (CS_TIPO_FUNCIONARIO_PE ASC) 
LOGGING 
TABLESPACE "PMM_DATA" 
PCTFREE 10 
INITRANS 2 
STORAGE 
( 
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1 
  MAXEXTENTS 2147483645 
  BUFFER_POOL DEFAULT 
)
CREATE UNIQUE INDEX SEMAD.XPKFUNCIONARIO_PE ON SEMAD.FUNCIONARIO_PE (ID_PESSOA_FUNCIONARIO ASC, NB_FUNCIONARIO ASC) 
LOGGING 
TABLESPACE "PMM_DATA" 
PCTFREE 10 
INITRANS 2 
STORAGE 
( 
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1 
  MAXEXTENTS 2147483645 
  BUFFER_POOL DEFAULT 
)ALTER TABLE SEMAD.FUNCIONARIO_PE
ADD CONSTRAINT SYS_C0030522 FOREIGN KEY
(
  CS_TIPO_FUNCIONARIO_PE 
)
REFERENCES SEMAD.TIPO_FUNCIONARIO_PE
(
  CS_TIPO_FUNCIONARIO_PE 
)
ENABLE
ALTER TABLE SEMAD.FUNCIONARIO_PE
ADD CONSTRAINT SYS_C0030523 FOREIGN KEY
(
  CS_SITUACAO_FUNCIONARIO 
)
REFERENCES SEMAD.SITUACAO_FUNCIONARIO
(
  CS_SITUACAO_FUNCIONARIO 
)
ENABLE
ALTER TABLE SEMAD.FUNCIONARIO_PE
ADD CONSTRAINT SYS_C0030524 FOREIGN KEY
(
  ID_PESSOA_FUNCIONARIO 
)
REFERENCES SEMAD.PESSOA_FISICA
(
  ID_PESSOA 
)
ENABLE
ALTER TABLE SEMAD.FUNCIONARIO_PE
ADD CONSTRAINT SYS_C0030525 FOREIGN KEY
(
  ID_UNIDADE_GESTORA 
)
REFERENCES SEMAD.UNID_GESTORA_PESSOA_PE
(
  ID_UNIDADE_GESTORA 
)
ENABLECREATE TABLE SEMAD.FUNCIONARIO_PE 
(
  ID_UNIDADE_GESTORA NUMBER(*, 0) NOT NULL 
, ID_PESSOA_FUNCIONARIO NUMBER(*, 0) NOT NULL 
, DT_CADASTRO DATE NOT NULL 
, TX_NOME_GUERRA VARCHAR2(80 BYTE) NOT NULL 
, NB_FUNCIONARIO NUMBER(*, 0) NOT NULL 
, BL_FOTO BLOB 
, BL_DIGITAL BLOB 
, CS_SITUACAO_FUNCIONARIO NUMBER(*, 0) NOT NULL 
, CS_TIPO_FUNCIONARIO_PE NUMBER(*, 0) NOT NULL 
, DT_ATUALIZACAO DATE NOT NULL 
, TX_FIR VARCHAR2(2000 BYTE) 
, CS_TIPO_REG_PONTO NUMBER(*, 0) 
, CONSTRAINT SYS_C0030521 PRIMARY KEY 
  (
    ID_PESSOA_FUNCIONARIO 
  , NB_FUNCIONARIO 
  )
  ENABLE 
) 
LOGGING 
TABLESPACE "PMM_DATA" 
PCTFREE 10 
INITRANS 1 
STORAGE 
( 
  INITIAL 65536 
  NEXT 1048576 
  MINEXTENTS 1 
  MAXEXTENTS 2147483645 
  BUFFER_POOL DEFAULT 
) 
LOB (BL_FOTO) STORE AS SYS_LOB0000105545C00006$$ 
( 
  ENABLE STORAGE IN ROW 
  CHUNK 8192 
  RETENTION 
  NOCACHE 
  LOGGING  
) 	
LOB (BL_DIGITAL) STORE AS SYS_LOB0000105545C00007$$ 
( 
  ENABLE STORAGE IN ROW 
  CHUNK 8192 
  RETENTION 
  NOCACHE 
  LOGGING  
)COMMENT ON COLUMN SEMAD.FUNCIONARIO_PE.ID_PESSOA_FUNCIONARIO IS 'Ã o identificador Ãºnico das pessoa fÃ­sicas.';
COMMENT ON COLUMN SEMAD.FUNCIONARIO_PE.DT_CADASTRO IS 'Data de cadastro do funcionÃ¡rio.';
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."FUNCIONARIO_PE" TO "PONTOELETRONICOV2";
 
  GRANT SELECT ON "SEMAD"."FUNCIONARIO_PE" TO "PONTO2";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."FUNCIONARIO_PE" TO "WILMA_SILVA";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."FUNCIONARIO_PE" TO "PONTOELETRONICOV2_CONS";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."FUNCIONARIO_PE" TO "LILIANE_FIGUEIREDO";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."FUNCIONARIO_PE" TO "JURIDICO_CONSULTA";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."FUNCIONARIO_PE" TO "JURIDICO_OPERACIONAL";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."FUNCIONARIO_PE" TO "JURIDICO_GESTORAUXILIAR";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."FUNCIONARIO_PE" TO "JURIDICO_GESTOR";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."FUNCIONARIO_PE" TO "JURIDICO_OPERACIONALTCE";
 
  GRANT SELECT ON "SEMAD"."FUNCIONARIO_PE" TO "GUEST_RHUNIVERSAL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."FUNCIONARIO_PE" TO "IRP";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."FUNCIONARIO_PE" TO "PONTOELETRONICOV2_FISCALIZAC";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."FUNCIONARIO_PE" TO "PONTOELETRONICOV2_RH";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."FUNCIONARIO_PE" TO "IRP_GESTOR_BP";
-- NÃ£o Ã© possÃ­vel renderizar a DLL TABLE para o objeto SEMAD.PESSOA_FISICA com o DBMS_METADATA tentando um gerador interno.
CREATE INDEX SEMAD.IDX_FK2_PESSOA_FISICA ON SEMAD.PESSOA_FISICA (ID_UF_REG_NASCIMENTO) 
LOGGING 
TABLESPACE "PMM_INDEX" 
PCTFREE 30 
INITRANS 10 
STORAGE 
( 
  INITIAL 131072 
  NEXT 1048576 
  MINEXTENTS 1 
  MAXEXTENTS 2147483645 
  BUFFER_POOL DEFAULT 
)ALTER TABLE SEMAD.PESSOA_FISICA
ADD CONSTRAINT IDX_FK1_PESSOA_FISICA FOREIGN KEY
(
  ID_LOCALIDADE_NATAL 
)
REFERENCES SEMAD.LOCALIDADE
(
  ID_LOCALIDADE 
)
ENABLE
ALTER TABLE SEMAD.PESSOA_FISICA
ADD CONSTRAINT IDX_FK2_PESSOA_FISICA FOREIGN KEY
(
  ID_UF_REG_NASCIMENTO 
)
REFERENCES SEMAD.UF
(
  ID_UF 
)
DISABLE
ALTER TABLE SEMAD.PESSOA_FISICA
ADD CONSTRAINT IDX_FK3_PESSOA_FISICA FOREIGN KEY
(
  ID_UF_RG 
)
REFERENCES SEMAD.UF
(
  ID_UF 
)
ENABLECREATE TABLE SEMAD.PESSOA_FISICA 
(
  ID_PESSOA NUMBER NOT NULL 
, NB_CPF VARCHAR2(80 BYTE) DEFAULT 00000000000000 
, NB_RG VARCHAR2(80 BYTE) 
, CS_SEXO NUMBER 
, DT_ATUALIZACAO DATE 
, CS_TIPO NUMBER 
, TX_ORGAO_EMISSOR VARCHAR2(80 BYTE) 
, ID_UF_RG VARCHAR2(80 BYTE) 
, DT_NASCIMENTO DATE 
, NB_REG_NASCIMENTO VARCHAR2(80 BYTE) 
, TX_CARTORIO_REG_NASC VARCHAR2(80 BYTE) 
, TX_LIVRO_CARTORIO VARCHAR2(20 BYTE) 
, TX_FOLHA_LIV_CART VARCHAR2(20 BYTE) 
, ID_UF_REG_NASCIMENTO VARCHAR2(80 BYTE) 
, ID_LOCALIDADE_NATAL NUMBER 
, NB_COD_CERT_MILITAR VARCHAR2(80 BYTE) 
, NB_CERT_MILITAR VARCHAR2(80 BYTE) 
, NB_PISPASEP VARCHAR2(80 BYTE) 
, NB_TITULO_ELEITOR VARCHAR2(80 BYTE) 
, NB_ZONA_TITULO VARCHAR2(80 BYTE) 
, NB_SECAO_TITULO VARCHAR2(80 BYTE) 
, LR_FOTO LONG RAW 
, ID_LOCALIDADE_CARTORIO NUMBER 
, DT_EMISSAO_CERTIDAO DATE 
, CS_TIPO_CERTIDAO NUMBER 
, DT_EMISSAO DATE 
, CS_ETNIA NUMBER 
, ID_MAE NUMBER 
, ID_PAI NUMBER 
, NB_CODIGO_INEP NUMBER 
, NB_CODIGO_CENTRAL NUMBER 
, LR_FOTO_PNG BLOB 
, CONSTRAINT IDX_PK_PESSOA_FISICA PRIMARY KEY 
  (
    ID_PESSOA 
  )
  ENABLE 
) 
LOGGING 
TABLESPACE "PMM_DATA" 
PCTFREE 10 
INITRANS 1 
STORAGE 
( 
  INITIAL 4194304 
  NEXT 1048576 
  MINEXTENTS 1 
  MAXEXTENTS 2147483645 
  BUFFER_POOL DEFAULT 
) 
PARALLEL 
LOB (LR_FOTO_PNG) STORE AS SYS_LOB0000097424C00032$$ 
( 
  ENABLE STORAGE IN ROW 
  CHUNK 8192 
  RETENTION 
  NOCACHE 
  NOLOGGING  
)
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "BANCOPRECO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "BP_FINALIZADORES";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "ADMINISTRADORES";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "LICITAC?O";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "FORNECEDORES";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "ZOPE_ROLE";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PROT_SEMSA";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PROT_LICITACAO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "BP_CONSULTA";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "APLICAR_PESSOAS";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PROT_CONSULTORES";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PROT_TRAMITE";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PROT_CONS_EXT";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "COLETORDEPONTO";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PROT_TRAM_SEMSA";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "FORNEC_CONSULTA";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PONTO_ELETRONICO";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PROT_IMPLURB";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PROT_CONS_IMPL";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PROT_TRAM_IMPL";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PROT_CML";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "LICITACAO_CONS";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PONTO_SEMEF";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "USUARIO_ADMIN";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "PONTOELETRONICOV2";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PONTO_SEMASC";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "GESTAOCONTASPUBLICAS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "GESTAOESCOLAR";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "GE_OPERADOR";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "R_BANCOPRECOS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "GE_GESTOR";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "SEMAD_LNK";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "ZOPEPROD";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PEDRO";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA_FISICA" TO "ANTONIO_SOUSA";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "PONTO2";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "VOYAGE_SOLICITANTE";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "VOYAGE_GESTOR";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA_FISICA" TO "VANESSA_MACIEL";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA_FISICA" TO "IONNE_PEREIRA";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA_FISICA" TO "PONTOELETRONICOV2_CONS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "PONTO_SMTU";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "GESTAOESCOLAR_CONSULTA";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "VOYAGE_CONS";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "GESTAOCONTASPUBLICAS_CONS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "IRP";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "TESTES";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA_FISICA" TO "PONTOELETRONICOV2_FISCALIZAC";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "PONTOELETRONICOV2_RH";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "GESTAOESPM";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "IRP_GESTOR_RP";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "IRP_GESTOR_CATALOGACAO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA_FISICA" TO "IRP_SOLICITANTE";
 
  GRANT SELECT ON "SEMAD"."PESSOA_FISICA" TO "HABITACAO";
--------------------------------------------------------
--  DDL for Table VAGAS_RECRUTAMENTO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."VAGAS_RECRUTAMENTO" 
   (	"ID_QUADRO_VAGAS_ESTAGIO" NUMBER(*,0), 
	"NB_QUANTIDADE" NUMBER(*,0), 
	"ID_RECRUTAMENTO_ESTAGIO" NUMBER(*,0), 
	"NB_VAGAS_RECRUTAMENTO" NUMBER(*,0), 
	"ID_ORGAO_ESTAGIO" NUMBER(*,0), 
	"CS_TIPO_VAGA_ESTAGIO" NUMBER(*,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Table PESSOA
--------------------------------------------------------

  CREATE TABLE "SEMAD"."PESSOA" 
   (	"ID_PESSOA" NUMBER, 
	"TX_NOME" VARCHAR2(80 BYTE), 
	"CS_TIPO_PESSOA" NUMBER, 
	"CS_BLOQUEIO_VOYAGE" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 8388608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" 
  PARALLEL ;
  GRANT SELECT ON "SEMAD"."PESSOA" TO "BANCOPRECO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "BP_FINALIZADORES";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PONTOELETRONICO_ADMIN";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "XPTO_CONNECT";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "ADMINISTRADORES";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "LICITAC?O";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "FORNECEDORES";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "ESTOQUE";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PARAMETRIZAC?O";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "Q_BANCO_PRECOS";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "ORGANIZACIONAL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "BP_CADASTRO";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PROT_SEMSA";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PROT_LICITACAO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "BP_CONSULTA";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "APLICAR_PESSOAS";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PROT_CONSULTORES";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PROT_TRAMITE";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "CONTAS_PUBLICAS";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "BP_MATERIAL";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "WORKFLOW";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PROT_CONS_EXT";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "EXECUCAO_ORCAMENTARIA";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PATRIMONIO";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "COLETORDEPONTO";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PROT_TRAM_SEMSA";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "FORNEC_CONSULTA";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PROT_IMPLURB";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PROT_CONS_IMPL";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PROT_TRAM_IMPL";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "WOKF_EXTERNO";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "ESTOQUE_CONSULTA";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PROT_CML";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "LICITACAO_CONS";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PRE_CADASTRO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PONTO_SEMEF";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PONTO_CONS_SEMEF";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "ESTOQUE_KITS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "REGISTROPRECOS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PONTO_SEMAD";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "USUARIO_ADMIN";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PONTO_CONSULTA";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PONTOELETRONICOV2";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PONTO_SEMASC";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "ESTOQUE_ADMIN";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "GESTAOCONTASPUBLICAS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PONTO_SEMASDH";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "GESTAOESCOLAR";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "EST_OPERADOR";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "EST_ATENDENTE";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "EST_AUTORIZACAO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "EST_GESTOR";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "GE_OPERADOR";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PONTO_SEMINF";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PONTO_MANAUSTRANS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "R_BANCOPRECOS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PONTO_SEMMAS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "GE_GESTOR";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "SEMAD_LNK";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "ZOPEPROD";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "ROSANA";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "TACIANA";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "IWAMOTO";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "FABIOLA_FACANHA";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PONTO_FDT";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PARAMETRIZACAO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "VOYAGE_SOLICITANTE";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "VOYAGE_GESTOR";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "WILMA_SILVA";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "EST_RM";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "PONTOELETRONICOV2_CONS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "VOYAGE_GESTOR_PASSAGEM";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "NEILA_SEMAD";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "JURIDICO";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "LILIANE_FIGUEIREDO";
 
  GRANT ALTER, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "JURIDICO_CONSULTA";
 
  GRANT ALTER, SELECT, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "JURIDICO_OPERACIONAL";
 
  GRANT ALTER, SELECT, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "JURIDICO_GESTORAUXILIAR";
 
  GRANT ALTER, SELECT, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "JURIDICO_GESTOR";
 
  GRANT ALTER, SELECT, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "JURIDICO_OPERACIONALTCE";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "EST_ALMOXPEQUENOS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PONTO_SMTU";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "ORGANIZACIONAL_ADM";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PATRIMONIO_IMOVEL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PATRIMONIO_IMOVEL_REL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PATRIMONIO_MOVEL_CAD";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PATRIMONIO_MOVEL_REL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "GESTAOCONTASPUBLICAS_TEL";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "GESTAOCONTASPUBLICAS_AGUA";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "GESTAOCONTASPUBLICAS_ENERGIA";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "GESTAOCONTASPUBLICAS_CONTRAT";
 
  GRANT ALTER, DELETE, INDEX, INSERT, SELECT, UPDATE, REFERENCES, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "GENILSON_ALVES";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "GESTAOESCOLAR_CONSULTA";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "PATRIMONIO_CONS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "VOYAGE_CONS";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "GESTAOCONTASPUBLICAS_CONS";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "IRP";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "TESTES";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE, ON COMMIT REFRESH, QUERY REWRITE, DEBUG, FLASHBACK ON "SEMAD"."PESSOA" TO "PONTOELETRONICOV2_FISCALIZAC";
 
  GRANT ALTER, DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "PONTOELETRONICOV2_RH";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "GESTAOESPM";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "EST_CONTABIL";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "IRP_GESTOR_RP";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "IRP_GESTOR_BP";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "IRP_GESTOR_CATALOGACAO";
 
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."PESSOA" TO "IRP_SOLICITANTE";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "EST_INVENTARIO";
 
  GRANT SELECT ON "SEMAD"."PESSOA" TO "HABITACAO";
--------------------------------------------------------
--  DDL for Table CAMPO
--------------------------------------------------------

  CREATE TABLE "SEMAD"."CAMPO" 
   (	"NB_CAMPO" NUMBER, 
	"ID_TABELA" NUMBER, 
	"TX_CAMPO" VARCHAR2(80 BYTE), 
	"CS_TIPO_CAMPO" NUMBER, 
	"TX_TITULO" VARCHAR2(80 BYTE), 
	"TX_DESCRICAO" VARCHAR2(80 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 10 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
  GRANT SELECT ON "SEMAD"."CAMPO" TO "AUDITORIA";
 
  GRANT SELECT ON "SEMAD"."CAMPO" TO "USUARIO_ADMIN";
 
  GRANT SELECT ON "SEMAD"."CAMPO" TO "SEMAD_LNK";
--------------------------------------------------------
--  DDL for Table TABELA
--------------------------------------------------------

  CREATE TABLE "SEMAD"."TABELA" 
   (	"TX_NOME" VARCHAR2(80 BYTE), 
	"ID_TABELA" NUMBER, 
	"ID_SERVIDOR" NUMBER, 
	"CS_ATUALIZACAO" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 10 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
  GRANT SELECT ON "SEMAD"."TABELA" TO "AUDITORIA";
 
  GRANT SELECT ON "SEMAD"."TABELA" TO "USUARIO_ADMIN";
 
  GRANT SELECT ON "SEMAD"."TABELA" TO "SEMAD_LNK";
-- NÃ£o Ã© possÃ­vel renderizar a DLL TABLE para o objeto SEMAD.VALOR_HISTORICO com o DBMS_METADATA tentando um gerador interno.
CREATE INDEX SEMAD.IDX_FK3_VALOR_HISTORICO ON SEMAD.VALOR_HISTORICO (ID_TABELA ASC) 
LOGGING 
TABLESPACE "PMM_INDEX" 
PCTFREE 10 
INITRANS 2 
STORAGE 
( 
  INITIAL 570425344 
  NEXT 1048576 
  MINEXTENTS 1 
  MAXEXTENTS 2147483645 
  BUFFER_POOL DEFAULT 
)
CREATE INDEX SEMAD.IDX_FK5_VALOR_HISTORICO ON SEMAD.VALOR_HISTORICO (ID_TABELA ASC, NB_TRANSACAO_HISTORICO ASC, NB_CAMPO ASC, ID_USUARIO ASC) 
LOGGING 
TABLESPACE "PMM_INDEX" 
PCTFREE 10 
INITRANS 2 
STORAGE 
( 
  INITIAL 995098624 
  NEXT 1048576 
  MINEXTENTS 1 
  MAXEXTENTS 2147483645 
  BUFFER_POOL DEFAULT 
)ALTER TABLE SEMAD.VALOR_HISTORICO
ADD CONSTRAINT IDX_FK1_VALOR_HISTORICO FOREIGN KEY
(
  ID_USUARIO 
, NB_TRANSACAO_HISTORICO 
, ID_TABELA 
)
REFERENCES SEMAD.TRANSACAO_HISTORICO
(
  ID_USUARIO 
, NB_TRANSACAO_HISTORICO 
, ID_TABELA 
)
ENABLE
ALTER TABLE SEMAD.VALOR_HISTORICO
ADD CONSTRAINT IDX_FK2_VALOR_HISTORICO FOREIGN KEY
(
  ID_TABELA 
, NB_CAMPO 
)
REFERENCES SEMAD.CAMPO
(
  ID_TABELA 
, NB_CAMPO 
)
ENABLECREATE TABLE SEMAD.VALOR_HISTORICO 
(
  ID_TABELA NUMBER NOT NULL 
, NB_TRANSACAO_HISTORICO NUMBER NOT NULL 
, NB_CAMPO NUMBER NOT NULL 
, ID_USUARIO NUMBER NOT NULL 
, NB_VALOR_HISTORICO NUMBER NOT NULL 
, NB_VALOR_VARCHAR2000 VARCHAR2(4000 BYTE) 
, NB_OLD_VARCHAR2000 VARCHAR2(4000 BYTE) 
, NB_OLD_LONG_RAW BLOB 
, CONSTRAINT IDX_PK_VALOR_HISTORICO PRIMARY KEY 
  (
    NB_CAMPO 
  , ID_TABELA 
  , ID_USUARIO 
  , NB_TRANSACAO_HISTORICO 
  , NB_VALOR_HISTORICO 
  )
  ENABLE 
) 
LOGGING 
TABLESPACE "PMM_DATA" 
PCTFREE 10 
INITRANS 10 
STORAGE 
( 
  INITIAL 1109393408 
  NEXT 1048576 
  MINEXTENTS 1 
  MAXEXTENTS 2147483645 
  BUFFER_POOL DEFAULT 
) 
LOB (NB_OLD_LONG_RAW) STORE AS SYS_LOB0000098230C00008$$ 
( 
  ENABLE STORAGE IN ROW 
  CHUNK 8192 
  PCTVERSION 10 
  NOCACHE 
  LOGGING  
)
  GRANT DELETE, INSERT, SELECT, UPDATE ON "SEMAD"."VALOR_HISTORICO" TO "AUDITORIA";
 
  GRANT SELECT ON "SEMAD"."VALOR_HISTORICO" TO "USUARIO_ADMIN";
 
  GRANT SELECT ON "SEMAD"."VALOR_HISTORICO" TO "SEMAD_LNK";
--------------------------------------------------------
--  DDL for Table TRANSFERENCIA_VAGAS
--------------------------------------------------------

  CREATE TABLE "SEMAD"."TRANSFERENCIA_VAGAS" 
   (	"ID_TRANSFERENCIA_ESTAGIO" NUMBER(*,0), 
	"DT_CADASTRO" DATE, 
	"DT_ATUALIZACAO" DATE, 
	"CS_SITUACAO" NUMBER(*,0), 
	"ID_USUARIO_ATUALIZACAO" NUMBER, 
	"ID_USUARIO_CADASTRO" NUMBER, 
	"TX_COD_TRANSFERENCIA" VARCHAR2(20 BYTE), 
	"ID_ORGAO_ESTAGIO" NUMBER(*,0), 
	"ID_ORGAO_GESTOR_ESTAGIO" NUMBER(*,0), 
	"TX_MOTIVO" VARCHAR2(255 BYTE), 
	"ID_ORGAO_SOLICITANTE" NUMBER(*,0), 
	"ID_QUADRO_VAGAS_ESTAGIO" NUMBER(*,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."TRANSFERENCIA_VAGAS"."CS_SITUACAO" IS '1 - Aberta
2 - Fechada
3 - Cancelada';
 
   COMMENT ON COLUMN "SEMAD"."TRANSFERENCIA_VAGAS"."ID_USUARIO_ATUALIZACAO" IS 'CÃ³digo do usuÃ¡rio do BD.';
 
   COMMENT ON COLUMN "SEMAD"."TRANSFERENCIA_VAGAS"."ID_USUARIO_CADASTRO" IS 'CÃ³digo do usuÃ¡rio do BD.';
--------------------------------------------------------
--  DDL for Table AVALIACAO_COORDENADOR
--------------------------------------------------------

  CREATE TABLE "SEMAD"."AVALIACAO_COORDENADOR" 
   (	"ID_AVALIACAO_COORDENADOR" NUMBER(*,0), 
	"ID_PROGRAMACAO_CURSO" NUMBER, 
	"ID_CURSO" NUMBER, 
	"NB_CURSO_PROGRAMADO" NUMBER, 
	"TX_MENSAGEM" VARCHAR2(255 BYTE), 
	"TX_CONCEITOS" VARCHAR2(255 BYTE), 
	"TX_SUGESTAO" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
 

   COMMENT ON COLUMN "SEMAD"."AVALIACAO_COORDENADOR"."ID_PROGRAMACAO_CURSO" IS 'CÃ³digo do documento.';
-- NÃ£o Ã© possÃ­vel renderizar a DLL VIEW para o objeto SEMAD.V_ESTAGIARIO com o DBMS_METADATA tentando um gerador interno.
CREATE VIEW SEMAD.V_ESTAGIARIO AS SELECT
  a.TX_NOME,
  a.CS_TIPO_PESSOA,
  b.CS_SEXO,
  B.DT_ATUALIZACAO,
  --b.CS_TIPO,
  b.NB_RG,
  b.NB_CPF,
  B.DT_NASCIMENTO,
  --b.LR_FOTO,
  b.TX_ORGAO_EMISSOR,
  c.ID_PESSOA_ESTAGIARIO,
  c.ID_PESSOA_FUNCIONARIO,
  c.NB_FUNCIONARIO,
  c.TX_CEP,
  c.TX_ENDERECO,
  c.NB_NUMERO,
  c.TX_COMPLEMENTO,
  c.TX_BAIRRO,
  c.TX_AGENCIA,
  c.TX_CONTA_CORRENTE,
  c.TX_CONTATO,
  c.TX_EMAIL
FROM
  PESSOA a,
  PESSOA_FISICA b,
  semad.ESTAGIARIO c
WHERE
  a.ID_PESSOA   = b.ID_PESSOA
AND B.ID_PESSOA = C.ID_PESSOA_ESTAGIARIO
-- NÃ£o Ã© possÃ­vel renderizar a DLL VIEW para o objeto SEMAD.V_ESTAGIARIO_2 com o DBMS_METADATA tentando um gerador interno.
CREATE VIEW SEMAD.V_ESTAGIARIO_2 AS select a.TX_NOME, a.CS_TIPO_PESSOA, b.CS_SEXO, b.DT_ATUALIZACAO, b.CS_TIPO, b.NB_RG, b.NB_CPF, b.DT_NASCIMENTO, b.LR_FOTO, b.TX_ORGAO_EMISSOR,
       c.ID_PESSOA_ESTAGIARIO, c.ID_PESSOA_FUNCIONARIO, c.NB_FUNCIONARIO, c.ID_OFERTA_VAGA, c.TX_CEP, c.TX_ENDERECO, c.NB_NUMERO, c.TX_COMPLEMENTO,
       c.TX_BAIRRO, c.TX_AGENCIA, c.TX_CONTA_CORRENTE, c.CS_ESCOLARIDADE, c.ID_CURSO_ESTAGIO, c.NB_PERIODO_ANO, c.CS_TURNO, c.ID_INSTITUICAO_ENSINO,
       c.ID_ORGAO_ESTAGIO, c.CS_TIPO_VAGA_ESTAGIO, c.TX_HORA_INICIO, c.TX_HORA_FINAL, c.ID_BOLSA_ESTAGIO, c.ID_PESSOA_SUPERVISOR
  from PESSOA a, PESSOA_FISICA b, semad.ESTAGIARIO c
 where a.ID_PESSOA = b.ID_PESSOA
   and b.ID_PESSOA = c.ID_PESSOA_ESTAGIARIO
-- NÃ£o Ã© possÃ­vel renderizar a DLL VIEW para o objeto OSMUNDO.MGV_ALL_CATALOGS com o DBMS_METADATA tentando um gerador interno.
CREATE VIEW MGV_ALL_CATALOGS AS SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_connections.dburl dburl ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name
  FROM md_projects ,
    md_connections,
    md_catalogs
  WHERE md_catalogs.connection_id_fk = md_connections.id
  AND md_connections.project_id_fk   = md_projects.id WITH READ ONLY
-- NÃ£o Ã© possÃ­vel renderizar a DLL VIEW para o objeto OSMUNDO.MGV_ALL_SCHEMA com o DBMS_METADATA tentando um gerador interno.
CREATE VIEW MGV_ALL_SCHEMA AS SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name,
    md_schemas.id schema_id ,
    md_schemas.name schema_name
  FROM md_connections,
    md_catalogs ,
    md_schemas ,
    md_projects
  WHERE md_schemas.catalog_id_fk   = md_catalogs.id
  AND md_catalogs.connection_id_fk = md_connections.id
  AND md_connections.project_id_fk = md_projects.id WITH READ ONLY
-- NÃ£o Ã© possÃ­vel renderizar a DLL VIEW para o objeto OSMUNDO.MGV_ALL_TABLES com o DBMS_METADATA tentando um gerador interno.
CREATE VIEW MGV_ALL_TABLES AS SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_connections.dburl dburl ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name,
    md_schemas.id schema_id ,
    md_schemas.name schema_name ,
    md_tables.id table_id ,
    md_tables.TABLE_NAME TABLE_NAME
  FROM md_connections,
    md_catalogs ,
    md_schemas ,
    md_tables ,
    md_projects
  WHERE md_tables.schema_id_fk     = md_schemas.id
  AND md_schemas.catalog_id_fk     = md_catalogs.id
  AND md_catalogs.connection_id_fk = md_connections.id
  AND md_connections.project_id_fk = md_projects.id WITH READ ONLY
-- NÃ£o Ã© possÃ­vel renderizar a DLL VIEW para o objeto OSMUNDO.MGV_ALL_VIEWS com o DBMS_METADATA tentando um gerador interno.
COMMENT ON TABLE MGV_ALL_VIEWS IS 'View to iterate over all views in the system'CREATE VIEW MGV_ALL_VIEWS AS SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    username username ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name,
    md_catalogs.dummy_flag dummy_flag ,
    md_schemas.id schema_id ,
    md_schemas.name schema_name ,
    md_views.id view_id ,
    md_views.view_name view_name
  FROM md_projects ,
    md_connections,
    md_catalogs ,
    md_schemas ,
    md_views
  WHERE md_views.schema_id_fk      = md_schemas.id
  AND md_schemas.catalog_id_fk     = md_catalogs.id
  AND md_catalogs.connection_id_fk = md_connections.id
  AND md_connections.project_id_fk = md_projects.id WITH READ ONLY
-- NÃ£o Ã© possÃ­vel renderizar a DLL VIEW para o objeto SEMAD.V_ENTRADA_ESTOQUE_3 com o DBMS_METADATA tentando um gerador interno.
CREATE VIEW SEMAD.V_ENTRADA_ESTOQUE_3 AS SELECT DISTINCT
          Entrada_Material.nb_Entrada,
          Entrada_Material.dt_Entrada_Material,
          Item_Ent_Material.nb_Quantidade,
          Entrada_Material.ID_Recebedor,
          Material_Estoque.ID_Unidade_Org,
          Material_Estoque.ID_Material_Servico,
          Entrada_Material.ID_Entrada_Material,
          Item_Ent_Material.nb_Valor_Unitario,
          Entrada_Material.tx_empenho
     FROM Material_Estoque, Entrada_Material, Item_Ent_Material
    WHERE Material_Estoque.ID_Unidade_Org = Item_Ent_Material.ID_Unidade_Org
          AND Material_Estoque.ID_Material_Servico =
                Item_Ent_Material.ID_Material_Servico
          AND Item_Ent_Material.ID_Material_Servico =
                Item_Ent_Material.ID_Material_Servico
          AND Item_Ent_Material.ID_Entrada_Material =
                Entrada_Material.ID_Entrada_Material
  GRANT SELECT ON "SEMAD"."V_ENTRADA_ESTOQUE_3" TO "ESTOQUE";
 
  GRANT SELECT ON "SEMAD"."V_ENTRADA_ESTOQUE_3" TO "EST_CONTABIL";
REM INSERTING into SEMAD.ORGAO_GESTOR_ESTAGIO
SET DEFINE OFF;
Insert into SEMAD.ORGAO_GESTOR_ESTAGIO (ID_ORGAO_GESTOR_ESTAGIO,TX_ORGAO_GESTOR_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,TX_CNPJ) values ('2','SEMAD',to_date('14/05/13','DD/MM/RR'),to_date('15/04/14','DD/MM/RR'),'1877','02.699.336/0001-10');
REM INSERTING into SEMAD.AGENCIA_ESTAGIO
SET DEFINE OFF;
Insert into SEMAD.AGENCIA_ESTAGIO (ID_AGENCIA_ESTAGIO,TX_AGENCIA_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,TX_SIGLA,TX_CNPJ,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,TX_EMAIL) values ('62','CIEE',to_date('27/05/13','DD/MM/RR'),to_date('05/02/14','DD/MM/RR'),'CIEE','91.518.996/0001-87','143','143','rodrigo.cabral@pmm.am.gov.br');
Insert into SEMAD.AGENCIA_ESTAGIO (ID_AGENCIA_ESTAGIO,TX_AGENCIA_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,TX_SIGLA,TX_CNPJ,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,TX_EMAIL) values ('2','IEL',to_date('17/05/13','DD/MM/RR'),to_date('03/10/13','DD/MM/RR'),'IEL','52.092.519/0001-40','2','143','andre.sousa@pmm.am.gov.br');
REM INSERTING into SEMAD.AGENCIA_ESTAGIO_EMAIL
SET DEFINE OFF;
REM INSERTING into SEMAD.AGENTE_SETORIAL_ESTAGIO
SET DEFINE OFF;
Insert into SEMAD.AGENTE_SETORIAL_ESTAGIO (ID_USUARIO,ID_SETORIAL_ESTAGIO,DT_CADASTRO,DT_ATULIZACAO,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,TX_EMAIL,TX_CARGO_FUNCAO,TX_CONTATO) values ('143','1',to_date('26/09/13','DD/MM/RR'),to_date('28/03/14','DD/MM/RR'),'143','143','andre.sousa@pmm.am.gov.br',null,null);
Insert into SEMAD.AGENTE_SETORIAL_ESTAGIO (ID_USUARIO,ID_SETORIAL_ESTAGIO,DT_CADASTRO,DT_ATULIZACAO,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,TX_EMAIL,TX_CARGO_FUNCAO,TX_CONTATO) values ('3087','36',to_date('02/10/13','DD/MM/RR'),to_date('02/10/13','DD/MM/RR'),'3087','3087','andrecgk@gmail.com',null,null);
Insert into SEMAD.AGENTE_SETORIAL_ESTAGIO (ID_USUARIO,ID_SETORIAL_ESTAGIO,DT_CADASTRO,DT_ATULIZACAO,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,TX_EMAIL,TX_CARGO_FUNCAO,TX_CONTATO) values ('3265','37',to_date('10/10/13','DD/MM/RR'),to_date('23/01/14','DD/MM/RR'),'143','143','rodrigo.cabral@pmm.am.gov.br',null,null);
REM INSERTING into SEMAD.BOLSA_ESTAGIO
SET DEFINE OFF;
Insert into SEMAD.BOLSA_ESTAGIO (ID_BOLSA_ESTAGIO,TX_BOLSA_ESTAGIO,NB_VALOR) values ('42','Superior 5 Horas','500');
Insert into SEMAD.BOLSA_ESTAGIO (ID_BOLSA_ESTAGIO,TX_BOLSA_ESTAGIO,NB_VALOR) values ('43','Superior 4 Horas','400');
Insert into SEMAD.BOLSA_ESTAGIO (ID_BOLSA_ESTAGIO,TX_BOLSA_ESTAGIO,NB_VALOR) values ('44','Medio','300');
Insert into SEMAD.BOLSA_ESTAGIO (ID_BOLSA_ESTAGIO,TX_BOLSA_ESTAGIO,NB_VALOR) values ('41','Superior 6 Horas','600');
REM INSERTING into SEMAD.CONTRATO_ESTAGIO
SET DEFINE OFF;
REM INSERTING into SEMAD.CURSO_ESTAGIO
SET DEFINE OFF;
Insert into SEMAD.CURSO_ESTAGIO (ID_CURSO_ESTAGIO,TX_CURSO_ESTAGIO,CS_AREA_CONHECIMENTO) values ('15','SEMAD TESTE','3');
Insert into SEMAD.CURSO_ESTAGIO (ID_CURSO_ESTAGIO,TX_CURSO_ESTAGIO,CS_AREA_CONHECIMENTO) values ('121','Sistema de InformaÃ§Ã£o','1');
Insert into SEMAD.CURSO_ESTAGIO (ID_CURSO_ESTAGIO,TX_CURSO_ESTAGIO,CS_AREA_CONHECIMENTO) values ('182','Tecnologia em AnÃ¡lise e Desenvolvimento de Sistemas','1');
Insert into SEMAD.CURSO_ESTAGIO (ID_CURSO_ESTAGIO,TX_CURSO_ESTAGIO,CS_AREA_CONHECIMENTO) values ('16','Medicina','2');
Insert into SEMAD.CURSO_ESTAGIO (ID_CURSO_ESTAGIO,TX_CURSO_ESTAGIO,CS_AREA_CONHECIMENTO) values ('14','Tecnico em Informatica','1');
Insert into SEMAD.CURSO_ESTAGIO (ID_CURSO_ESTAGIO,TX_CURSO_ESTAGIO,CS_AREA_CONHECIMENTO) values ('61','Ciencia da ComputaÃ§Ã£o','1');
Insert into SEMAD.CURSO_ESTAGIO (ID_CURSO_ESTAGIO,TX_CURSO_ESTAGIO,CS_AREA_CONHECIMENTO) values ('221','GestÃ£o em Tecnologia da InformaÃ§Ã£o','1');
Insert into SEMAD.CURSO_ESTAGIO (ID_CURSO_ESTAGIO,TX_CURSO_ESTAGIO,CS_AREA_CONHECIMENTO) values ('101','Engenharia da ComputaÃ§Ã£o','1');
Insert into SEMAD.CURSO_ESTAGIO (ID_CURSO_ESTAGIO,TX_CURSO_ESTAGIO,CS_AREA_CONHECIMENTO) values ('102','AnÃ¡lise de sistema','1');
Insert into SEMAD.CURSO_ESTAGIO (ID_CURSO_ESTAGIO,TX_CURSO_ESTAGIO,CS_AREA_CONHECIMENTO) values ('241','Licenciatura em Artes Plasticas','2');
REM INSERTING into SEMAD.ITEM_PAGAMENTO_ESTAGIO
SET DEFINE OFF;
Insert into SEMAD.ITEM_PAGAMENTO_ESTAGIO (ID_ITEM_PAGAMENTO_ESTAGIO,TX_CODIGO,TX_DESCRICAO,TX_SIGLA,DT_CADASTRO,DT_ATUALIZACAO,CS_TIPO,CS_SITUACAO) values ('81','1','teste','TESTE',to_date('07/06/13','DD/MM/RR'),to_date('29/10/13','DD/MM/RR'),'1','2');
Insert into SEMAD.ITEM_PAGAMENTO_ESTAGIO (ID_ITEM_PAGAMENTO_ESTAGIO,TX_CODIGO,TX_DESCRICAO,TX_SIGLA,DT_CADASTRO,DT_ATUALIZACAO,CS_TIPO,CS_SITUACAO) values ('62','12334','sdsad','adssad',to_date('27/05/13','DD/MM/RR'),to_date('27/05/13','DD/MM/RR'),'2','1');
REM INSERTING into SEMAD.ITEM_PAG_ESTAGIO
SET DEFINE OFF;
REM INSERTING into SEMAD.ORGAO_ESTAGIO
SET DEFINE OFF;
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('271','PGM',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1884','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('272','SEHAF',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'4824','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('1','SEMAD',to_date('26/09/13','DD/MM/RR'),to_date('26/09/13','DD/MM/RR'),'1877','143','143','1','60633299000143');
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('223','CC',to_date('27/09/13','DD/MM/RR'),to_date('01/10/13','DD/MM/RR'),'1880','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('269','MANAUSTRANS',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'3749','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('262','FDT',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1898','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('263','FESPM',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1899','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('264','FMDS',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'4838','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('265','CM',to_date('30/09/13','DD/MM/RR'),to_date('01/10/13','DD/MM/RR'),'1883','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('266','IMPLURB',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1902','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('268','MANAUSMED',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1904','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('273','SEMCOM',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1885','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('274','SEMDEJ',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1886','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('278','SEMJEL',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'3585','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('279','SEMMAS',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1892','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('280','SEMPAB',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1893','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('281','SEMSA',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1896','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('282','SEMTRAD',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1887','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('283','SMTU',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1901','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('261','CGM',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'3835','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('267','MANAUSCULT',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1900','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('270','MANAUSTUR',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'2856','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('275','SEMED',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1897','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('2','SEMASDH',to_date('27/09/13','DD/MM/RR'),to_date('27/09/13','DD/MM/RR'),'1891','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('276','SEMEF',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1890','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('277','SEMINF',to_date('30/09/13','DD/MM/RR'),to_date('30/09/13','DD/MM/RR'),'1895','143','143','1',null);
Insert into SEMAD.ORGAO_ESTAGIO (ID_ORGAO_ESTAGIO,TX_ORGAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_UNIDADE_ORG,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,CS_STATUS,TX_CNPJ) values ('341','UNID. CONCED. SEMAD',to_date('28/03/14','DD/MM/RR'),to_date('28/03/14','DD/MM/RR'),'1877','143','143','1',null);
REM INSERTING into SEMAD.PAGAMENTO_ESTAGIO
SET DEFINE OFF;
REM INSERTING into SEMAD.QUADRO_VAGAS_ESTAGIO
SET DEFINE OFF;
Insert into SEMAD.QUADRO_VAGAS_ESTAGIO (ID_QUADRO_VAGAS_ESTAGIO,ID_ORGAO_GESTOR_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_USUARIO_ATUALIZACAO,ID_USUARIO_CADASTRO,CS_SITUACAO,TX_CODIGO,ID_CONTRATO_CP) values ('441','2',to_date('01/10/13','DD/MM/RR'),to_date('01/10/13','DD/MM/RR'),'143','143','2','00002/2013','561');
Insert into SEMAD.QUADRO_VAGAS_ESTAGIO (ID_QUADRO_VAGAS_ESTAGIO,ID_ORGAO_GESTOR_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_USUARIO_ATUALIZACAO,ID_USUARIO_CADASTRO,CS_SITUACAO,TX_CODIGO,ID_CONTRATO_CP) values ('402','2',to_date('30/09/13','DD/MM/RR'),to_date('28/03/14','DD/MM/RR'),'143','143','1','00001/2013','561');
REM INSERTING into SEMAD.RECESSO_ESTAGIO
SET DEFINE OFF;
REM INSERTING into SEMAD.RECRUTAMENTO_ESTAGIO
SET DEFINE OFF;
REM INSERTING into SEMAD.SELECAO_ESTAGIO
SET DEFINE OFF;
Insert into SEMAD.SELECAO_ESTAGIO (ID_SELECAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_ORGAO_ESTAGIO,ID_USUARIO_CADASTRO,TX_COD_SELECAO,ID_ORGAO_GESTOR_ESTAGIO,ID_USUARIO_ATUALIZACAO,CS_SITUACAO,CS_SELECAO,ID_OFERTA_VAGA,ID_AGENCIA_ESTAGIO) values ('77',to_date('17/10/13','DD/MM/RR'),to_date('01/04/14','DD/MM/RR'),'1','143','00002/2013','2','143','3',null,'1','62');
Insert into SEMAD.SELECAO_ESTAGIO (ID_SELECAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_ORGAO_ESTAGIO,ID_USUARIO_CADASTRO,TX_COD_SELECAO,ID_ORGAO_GESTOR_ESTAGIO,ID_USUARIO_ATUALIZACAO,CS_SITUACAO,CS_SELECAO,ID_OFERTA_VAGA,ID_AGENCIA_ESTAGIO) values ('78',to_date('17/10/13','DD/MM/RR'),to_date('18/10/13','DD/MM/RR'),'2','143','00003/2013','2','143','1',null,null,'62');
Insert into SEMAD.SELECAO_ESTAGIO (ID_SELECAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_ORGAO_ESTAGIO,ID_USUARIO_CADASTRO,TX_COD_SELECAO,ID_ORGAO_GESTOR_ESTAGIO,ID_USUARIO_ATUALIZACAO,CS_SITUACAO,CS_SELECAO,ID_OFERTA_VAGA,ID_AGENCIA_ESTAGIO) values ('83',to_date('05/02/14','DD/MM/RR'),to_date('05/02/14','DD/MM/RR'),'1','3265','00001/2014','2','3265','1','2',null,'62');
Insert into SEMAD.SELECAO_ESTAGIO (ID_SELECAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_ORGAO_ESTAGIO,ID_USUARIO_CADASTRO,TX_COD_SELECAO,ID_ORGAO_GESTOR_ESTAGIO,ID_USUARIO_ATUALIZACAO,CS_SITUACAO,CS_SELECAO,ID_OFERTA_VAGA,ID_AGENCIA_ESTAGIO) values ('74',to_date('14/10/13','DD/MM/RR'),to_date('14/10/13','DD/MM/RR'),'2','143','00001/2013','2','143','1',null,null,'62');
Insert into SEMAD.SELECAO_ESTAGIO (ID_SELECAO_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_ORGAO_ESTAGIO,ID_USUARIO_CADASTRO,TX_COD_SELECAO,ID_ORGAO_GESTOR_ESTAGIO,ID_USUARIO_ATUALIZACAO,CS_SITUACAO,CS_SELECAO,ID_OFERTA_VAGA,ID_AGENCIA_ESTAGIO) values ('85',to_date('21/02/14','DD/MM/RR'),to_date('02/04/14','DD/MM/RR'),'1','143','00003/2014','2','143','1','2',null,'62');
REM INSERTING into SEMAD.SOLICITACAO_ESTAGIO
SET DEFINE OFF;
REM INSERTING into SEMAD.SUPERVISOR_ESTAGIO
SET DEFINE OFF;
Insert into SEMAD.SUPERVISOR_ESTAGIO (ID_PESSOA_SUPERVISOR,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CURRICULO,ID_CONSELHO,NB_INSCRICAO_CONSELHO,TX_FORMACAO,TX_CARGO,TX_TEMPO_EXPERIENCIA,TX_EMAIL) values ('167335','167335','1','Dsti usuario','33','123654123','Gestor de TI','Tecnico','2 anos','usario.dstiteste@pmm.am.gov.br');
Insert into SEMAD.SUPERVISOR_ESTAGIO (ID_PESSOA_SUPERVISOR,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CURRICULO,ID_CONSELHO,NB_INSCRICAO_CONSELHO,TX_FORMACAO,TX_CARGO,TX_TEMPO_EXPERIENCIA,TX_EMAIL) values ('27130','27130','1',null,'1','123456789','TECNOLOGO EM GESTÃO DE TI','ASSESSOR TÃCNICO III','6 anos','rodrigo.cabral@pmm.am.gov.br');
Insert into SEMAD.SUPERVISOR_ESTAGIO (ID_PESSOA_SUPERVISOR,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CURRICULO,ID_CONSELHO,NB_INSCRICAO_CONSELHO,TX_FORMACAO,TX_CARGO,TX_TEMPO_EXPERIENCIA,TX_EMAIL) values ('157067','157067','1','teste','33','25487','Bacharel em CiÃªncia da ComputaÃ§Ã£o','Assessor TÃ©cnico 2','8 meses',null);
Insert into SEMAD.SUPERVISOR_ESTAGIO (ID_PESSOA_SUPERVISOR,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CURRICULO,ID_CONSELHO,NB_INSCRICAO_CONSELHO,TX_FORMACAO,TX_CARGO,TX_TEMPO_EXPERIENCIA,TX_EMAIL) values ('161541','161541','1','TESTE3','33','34253546','TÃ©cnico em InformÃ¡tica','TECNICO','1 ano','adilson@email.com');
REM INSERTING into SEMAD.TIPO_PAG_ESTAGIO
SET DEFINE OFF;
Insert into SEMAD.TIPO_PAG_ESTAGIO (CS_TIPO_PAG_ESTAGIO,TX_TIPO_PAG_ESTAGIO) values ('3','Folha Eventual');
Insert into SEMAD.TIPO_PAG_ESTAGIO (CS_TIPO_PAG_ESTAGIO,TX_TIPO_PAG_ESTAGIO) values ('1','Folha Mensal');
Insert into SEMAD.TIPO_PAG_ESTAGIO (CS_TIPO_PAG_ESTAGIO,TX_TIPO_PAG_ESTAGIO) values ('2','Folha de DÃ©cimo Terceiro');
REM INSERTING into SEMAD.TIPO_VAGA_ESTAGIO
SET DEFINE OFF;
Insert into SEMAD.TIPO_VAGA_ESTAGIO (CS_TIPO_VAGA_ESTAGIO,TX_TIPO_VAGA_ESTAGIO,ID_BOLSA_ESTAGIO) values ('2','Superior 4 Horas','43');
Insert into SEMAD.TIPO_VAGA_ESTAGIO (CS_TIPO_VAGA_ESTAGIO,TX_TIPO_VAGA_ESTAGIO,ID_BOLSA_ESTAGIO) values ('3','Superior 5 Horas','42');
Insert into SEMAD.TIPO_VAGA_ESTAGIO (CS_TIPO_VAGA_ESTAGIO,TX_TIPO_VAGA_ESTAGIO,ID_BOLSA_ESTAGIO) values ('4','Superior 6 Horas','41');
Insert into SEMAD.TIPO_VAGA_ESTAGIO (CS_TIPO_VAGA_ESTAGIO,TX_TIPO_VAGA_ESTAGIO,ID_BOLSA_ESTAGIO) values ('1','MÃ©dio','44');
REM INSERTING into SEMAD.VAGAS_ESTAGIO
SET DEFINE OFF;
Insert into SEMAD.VAGAS_ESTAGIO (ID_QUADRO_VAGAS_ESTAGIO,ID_ORGAO_ESTAGIO,NB_QUANTIDADE,CS_TIPO_VAGA_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,ID_CURSO_ESTAGIO,ID_AGENCIA_ESTAGIO) values ('402','223','5','2',to_date('30/09/13','DD/MM/RR'),to_date('01/04/14','DD/MM/RR'),'143','143',null,'62');
Insert into SEMAD.VAGAS_ESTAGIO (ID_QUADRO_VAGAS_ESTAGIO,ID_ORGAO_ESTAGIO,NB_QUANTIDADE,CS_TIPO_VAGA_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,ID_CURSO_ESTAGIO,ID_AGENCIA_ESTAGIO) values ('402','2','69','3',to_date('28/03/14','DD/MM/RR'),to_date('28/03/14','DD/MM/RR'),'143','143',null,'62');
Insert into SEMAD.VAGAS_ESTAGIO (ID_QUADRO_VAGAS_ESTAGIO,ID_ORGAO_ESTAGIO,NB_QUANTIDADE,CS_TIPO_VAGA_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,ID_CURSO_ESTAGIO,ID_AGENCIA_ESTAGIO) values ('441','1','2','2',to_date('01/10/13','DD/MM/RR'),to_date('01/10/13','DD/MM/RR'),'143','143','101','62');
Insert into SEMAD.VAGAS_ESTAGIO (ID_QUADRO_VAGAS_ESTAGIO,ID_ORGAO_ESTAGIO,NB_QUANTIDADE,CS_TIPO_VAGA_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,ID_CURSO_ESTAGIO,ID_AGENCIA_ESTAGIO) values ('402','2','50','1',to_date('28/03/14','DD/MM/RR'),to_date('28/03/14','DD/MM/RR'),'143','143',null,'62');
Insert into SEMAD.VAGAS_ESTAGIO (ID_QUADRO_VAGAS_ESTAGIO,ID_ORGAO_ESTAGIO,NB_QUANTIDADE,CS_TIPO_VAGA_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,ID_CURSO_ESTAGIO,ID_AGENCIA_ESTAGIO) values ('402','1','1','4',to_date('30/09/13','DD/MM/RR'),to_date('01/04/14','DD/MM/RR'),'143','143',null,'62');
Insert into SEMAD.VAGAS_ESTAGIO (ID_QUADRO_VAGAS_ESTAGIO,ID_ORGAO_ESTAGIO,NB_QUANTIDADE,CS_TIPO_VAGA_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,ID_CURSO_ESTAGIO,ID_AGENCIA_ESTAGIO) values ('402','2','81','2',to_date('28/03/14','DD/MM/RR'),to_date('28/03/14','DD/MM/RR'),'143','143',null,'62');
Insert into SEMAD.VAGAS_ESTAGIO (ID_QUADRO_VAGAS_ESTAGIO,ID_ORGAO_ESTAGIO,NB_QUANTIDADE,CS_TIPO_VAGA_ESTAGIO,DT_CADASTRO,DT_ATUALIZACAO,ID_USUARIO_CADASTRO,ID_USUARIO_ATUALIZACAO,ID_CURSO_ESTAGIO,ID_AGENCIA_ESTAGIO) values ('402','2','106','4',to_date('28/03/14','DD/MM/RR'),to_date('28/03/14','DD/MM/RR'),'143','143',null,'62');
REM INSERTING into SEMAD.ESTAGIARIO
SET DEFINE OFF;
Insert into SEMAD.ESTAGIARIO (ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('168293',null,null,'69000000','uyfyl',null,null,null,null,null,null,null);
Insert into SEMAD.ESTAGIARIO (ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('144120',null,null,'69000000','LIYFLYF',null,null,null,'123456','123456',null,null);
Insert into SEMAD.ESTAGIARIO (ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('157067',null,null,'69095090','RUA BURITI','47',null,'CIDADE NOVA','14545','Q545',null,null);
Insert into SEMAD.ESTAGIARIO (ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('166454',null,null,'69000000','LIYVLIV',null,null,null,null,null,null,null);
Insert into SEMAD.ESTAGIARIO (ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('167788',null,null,'69078480','Travessa S 6',null,null,'Japiim',null,null,null,null);
Insert into SEMAD.ESTAGIARIO (ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('168314',null,null,'69000000','livlvlv',null,null,null,null,null,null,null);
Insert into SEMAD.ESTAGIARIO (ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('166329',null,null,'69000000','LVLVLVL',null,null,null,null,null,null,null);
Insert into SEMAD.ESTAGIARIO (ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('27130',null,null,'69050520','Avenida Rio Negro','21','BL 10-A, APT 02, CONJ. ELDORADO','Parque 10 de Novembro','3711','00206792','9983-8492, 9336-2319','RODRIGO.CABRAL@PMM.AM.GOV.BR');
Insert into SEMAD.ESTAGIARIO (ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('168290',null,null,'69000000','vlvlvlivl',null,null,null,null,null,null,null);
Insert into SEMAD.ESTAGIARIO (ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('169166',null,null,'69010170','AVENIDA LEONARDO MALCHER','834','CASA 01','CENTRO','0320','06584993','9467-9435','KAKAUSAREL@HOTMAIL.COM');
REM INSERTING into SEMAD.ESTAGIARIO_CONTRATO
SET DEFINE OFF;
REM INSERTING into SEMAD.ESTAGIARIO_SELECAO
SET DEFINE OFF;
Insert into SEMAD.ESTAGIARIO_SELECAO (ID_SELECAO_ESTAGIO,CS_SITUACAO,TX_MOTIVO_SITUACAO,ID_USUARIO_CADASTRO,ID_PESSOA_ESTAGIARIO,CS_ESCOLARIDADE,ID_CURSO_ESTAGIO,NB_PERIODO_ANO,CS_TURNO,ID_INSTITUICAO_ENSINO,ID_ORGAO_ESTAGIO,CS_TIPO_VAGA_ESTAGIO,TX_HORA_INICIO,TX_HORA_FINAL,ID_BOLSA_ESTAGIO,ID_PESSOA_SUPERVISOR,ID_USUARIO_ATUALIZACAO,DT_CADASTRO,DT_ATUALIZACAO,CS_CARGA_HORARIA,TX_ATIVIDADES,NB_VALOR_TRANSPORTE,TX_LOCAL_ESTAGIO,DT_INICIO,DT_FINAL) values ('77','4',null,'143','157067',null,null,null,null,null,null,null,null,null,null,null,'143',to_date('22/01/14','DD/MM/RR'),to_date('22/01/14','DD/MM/RR'),null,null,null,null,null,null);
Insert into SEMAD.ESTAGIARIO_SELECAO (ID_SELECAO_ESTAGIO,CS_SITUACAO,TX_MOTIVO_SITUACAO,ID_USUARIO_CADASTRO,ID_PESSOA_ESTAGIARIO,CS_ESCOLARIDADE,ID_CURSO_ESTAGIO,NB_PERIODO_ANO,CS_TURNO,ID_INSTITUICAO_ENSINO,ID_ORGAO_ESTAGIO,CS_TIPO_VAGA_ESTAGIO,TX_HORA_INICIO,TX_HORA_FINAL,ID_BOLSA_ESTAGIO,ID_PESSOA_SUPERVISOR,ID_USUARIO_ATUALIZACAO,DT_CADASTRO,DT_ATUALIZACAO,CS_CARGA_HORARIA,TX_ATIVIDADES,NB_VALOR_TRANSPORTE,TX_LOCAL_ESTAGIO,DT_INICIO,DT_FINAL) values ('77','5',null,'143','144120','3','121','4','3','29','1','4','10:00','17:00','41','161541','143',to_date('22/01/14','DD/MM/RR'),to_date('04/04/14','DD/MM/RR'),'3','A) ATENDIMENTO AO PÃBLICO 
B) AUXÃLIO / SUPORTE NO PROCESSO DE ATENDIMENTO 
C) AUXILIAR / COOPERAR / NO ATENDIMENTO TELEFÃNICO PRESTANDO INFORMAÃÃES SOBRE OS SERVIÃOS DA EMPRESA 
D) LEVANTAMENTO','99,22','teste',to_date('04/04/14','DD/MM/RR'),to_date('03/10/14','DD/MM/RR'));
Insert into SEMAD.ESTAGIARIO_SELECAO (ID_SELECAO_ESTAGIO,CS_SITUACAO,TX_MOTIVO_SITUACAO,ID_USUARIO_CADASTRO,ID_PESSOA_ESTAGIARIO,CS_ESCOLARIDADE,ID_CURSO_ESTAGIO,NB_PERIODO_ANO,CS_TURNO,ID_INSTITUICAO_ENSINO,ID_ORGAO_ESTAGIO,CS_TIPO_VAGA_ESTAGIO,TX_HORA_INICIO,TX_HORA_FINAL,ID_BOLSA_ESTAGIO,ID_PESSOA_SUPERVISOR,ID_USUARIO_ATUALIZACAO,DT_CADASTRO,DT_ATUALIZACAO,CS_CARGA_HORARIA,TX_ATIVIDADES,NB_VALOR_TRANSPORTE,TX_LOCAL_ESTAGIO,DT_INICIO,DT_FINAL) values ('77','5',null,'143','169166','1','241','4','3','29','1','4','10:00:00','17:00:00','41','27130','3265',to_date('21/01/14','DD/MM/RR'),to_date('02/04/14','DD/MM/RR'),'3','A) ATENDIMENTO AO PÃBLICO 
B) AUXÃLIO / SUPORTE NO PROCESSO DE ATENDIMENTO 
C) AUXILIAR / COOPERAR / NO ATENDIMENTO TELEFÃNICO PRESTANDO INFORMAÃÃES SOBRE OS SERVIÃOS DA EMPRESA 
D) LEVANTAMENTO','99,22','teste',to_date('02/04/14','DD/MM/RR'),to_date('01/10/14','DD/MM/RR'));
Insert into SEMAD.ESTAGIARIO_SELECAO (ID_SELECAO_ESTAGIO,CS_SITUACAO,TX_MOTIVO_SITUACAO,ID_USUARIO_CADASTRO,ID_PESSOA_ESTAGIARIO,CS_ESCOLARIDADE,ID_CURSO_ESTAGIO,NB_PERIODO_ANO,CS_TURNO,ID_INSTITUICAO_ENSINO,ID_ORGAO_ESTAGIO,CS_TIPO_VAGA_ESTAGIO,TX_HORA_INICIO,TX_HORA_FINAL,ID_BOLSA_ESTAGIO,ID_PESSOA_SUPERVISOR,ID_USUARIO_ATUALIZACAO,DT_CADASTRO,DT_ATUALIZACAO,CS_CARGA_HORARIA,TX_ATIVIDADES,NB_VALOR_TRANSPORTE,TX_LOCAL_ESTAGIO,DT_INICIO,DT_FINAL) values ('83','1',null,'3265','27130',null,null,null,null,null,null,null,null,null,null,null,'3265',to_date('05/02/14','DD/MM/RR'),to_date('05/02/14','DD/MM/RR'),null,null,null,null,null,null);
Insert into SEMAD.ESTAGIARIO_SELECAO (ID_SELECAO_ESTAGIO,CS_SITUACAO,TX_MOTIVO_SITUACAO,ID_USUARIO_CADASTRO,ID_PESSOA_ESTAGIARIO,CS_ESCOLARIDADE,ID_CURSO_ESTAGIO,NB_PERIODO_ANO,CS_TURNO,ID_INSTITUICAO_ENSINO,ID_ORGAO_ESTAGIO,CS_TIPO_VAGA_ESTAGIO,TX_HORA_INICIO,TX_HORA_FINAL,ID_BOLSA_ESTAGIO,ID_PESSOA_SUPERVISOR,ID_USUARIO_ATUALIZACAO,DT_CADASTRO,DT_ATUALIZACAO,CS_CARGA_HORARIA,TX_ATIVIDADES,NB_VALOR_TRANSPORTE,TX_LOCAL_ESTAGIO,DT_INICIO,DT_FINAL) values ('77','3','asdvpbapvibe apvfvbpaeirbg pavfbpib pib piygpibÃ§g','143','166454',null,null,null,null,null,null,null,null,null,null,null,'143',to_date('21/01/14','DD/MM/RR'),to_date('23/01/14','DD/MM/RR'),null,null,null,null,null,null);
Insert into SEMAD.ESTAGIARIO_SELECAO (ID_SELECAO_ESTAGIO,CS_SITUACAO,TX_MOTIVO_SITUACAO,ID_USUARIO_CADASTRO,ID_PESSOA_ESTAGIARIO,CS_ESCOLARIDADE,ID_CURSO_ESTAGIO,NB_PERIODO_ANO,CS_TURNO,ID_INSTITUICAO_ENSINO,ID_ORGAO_ESTAGIO,CS_TIPO_VAGA_ESTAGIO,TX_HORA_INICIO,TX_HORA_FINAL,ID_BOLSA_ESTAGIO,ID_PESSOA_SUPERVISOR,ID_USUARIO_ATUALIZACAO,DT_CADASTRO,DT_ATUALIZACAO,CS_CARGA_HORARIA,TX_ATIVIDADES,NB_VALOR_TRANSPORTE,TX_LOCAL_ESTAGIO,DT_INICIO,DT_FINAL) values ('85','2',null,'143','27130','2','14','2','3','141','1','2','07:00:00','13:00:00','43','157067','143',to_date('21/02/14','DD/MM/RR'),to_date('02/04/14','DD/MM/RR'),'1',null,null,null,null,null);
Insert into SEMAD.ESTAGIARIO_SELECAO (ID_SELECAO_ESTAGIO,CS_SITUACAO,TX_MOTIVO_SITUACAO,ID_USUARIO_CADASTRO,ID_PESSOA_ESTAGIARIO,CS_ESCOLARIDADE,ID_CURSO_ESTAGIO,NB_PERIODO_ANO,CS_TURNO,ID_INSTITUICAO_ENSINO,ID_ORGAO_ESTAGIO,CS_TIPO_VAGA_ESTAGIO,TX_HORA_INICIO,TX_HORA_FINAL,ID_BOLSA_ESTAGIO,ID_PESSOA_SUPERVISOR,ID_USUARIO_ATUALIZACAO,DT_CADASTRO,DT_ATUALIZACAO,CS_CARGA_HORARIA,TX_ATIVIDADES,NB_VALOR_TRANSPORTE,TX_LOCAL_ESTAGIO,DT_INICIO,DT_FINAL) values ('77','5',null,'143','27130','3','221','4','3','29','1','4','10:00','16:00','41','157067','143',to_date('21/01/14','DD/MM/RR'),to_date('01/04/14','DD/MM/RR'),'3','A) ATENDIMENTO AO PÃBLICO 
B) AUXÃLIO / SUPORTE NO PROCESSO DE ATENDIMENTO 
C) AUXILIAR / COOPERAR / NO ATENDIMENTO TELEFÃNICO PRESTANDO INFORMAÃÃES SOBRE OS SERVIÃOS DA EMPRESA 
D) LEVANTAMENTO','1234,56','LKNJHBHHÃH',to_date('28/01/14','DD/MM/RR'),to_date('29/06/15','DD/MM/RR'));
REM INSERTING into SEMAD.ESTAGIARIO_VAGA
SET DEFINE OFF;
REM INSERTING into SEMAD.V_ESTAGIARIO
SET DEFINE OFF;
Insert into SEMAD.V_ESTAGIARIO (TX_NOME,CS_TIPO_PESSOA,CS_SEXO,DT_ATUALIZACAO,NB_RG,NB_CPF,DT_NASCIMENTO,TX_ORGAO_EMISSOR,ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('Maria Izabel','0','2',to_date('11/09/13','DD/MM/RR'),'321478965','17534690234',null,'SSP','168293',null,null,'69000000','uyfyl',null,null,null,null,null,null,null);
Insert into SEMAD.V_ESTAGIARIO (TX_NOME,CS_TIPO_PESSOA,CS_SEXO,DT_ATUALIZACAO,NB_RG,NB_CPF,DT_NASCIMENTO,TX_ORGAO_EMISSOR,ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('CARLOS GRIMM MONIZ JUNIOR','0','1',to_date('01/04/14','DD/MM/RR'),'19809786','96138475291',to_date('12/10/88','DD/MM/RR'),'SSP','144120',null,null,'69000000','LIYFLYF',null,null,null,'123456','123456',null,null);
Insert into SEMAD.V_ESTAGIARIO (TX_NOME,CS_TIPO_PESSOA,CS_SEXO,DT_ATUALIZACAO,NB_RG,NB_CPF,DT_NASCIMENTO,TX_ORGAO_EMISSOR,ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('ANDRE TEIXEIRA DE SOUSA','0','1',to_date('19/02/14','DD/MM/RR'),'17364663','86442228215',to_date('12/08/86','DD/MM/RR'),'SSP','157067',null,null,'69095090','RUA BURITI','47',null,'CIDADE NOVA','14545','Q545',null,null);
Insert into SEMAD.V_ESTAGIARIO (TX_NOME,CS_TIPO_PESSOA,CS_SEXO,DT_ATUALIZACAO,NB_RG,NB_CPF,DT_NASCIMENTO,TX_ORGAO_EMISSOR,ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('FRANCIBEL DA SILVA NEVES','0','2',to_date('21/01/14','DD/MM/RR'),'24725790','90381920291',to_date('01/10/89','DD/MM/RR'),'SESEG','166454',null,null,'69000000','LIYVLIV',null,null,null,null,null,null,null);
Insert into SEMAD.V_ESTAGIARIO (TX_NOME,CS_TIPO_PESSOA,CS_SEXO,DT_ATUALIZACAO,NB_RG,NB_CPF,DT_NASCIMENTO,TX_ORGAO_EMISSOR,ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('FRANCIBELL','0','2',to_date('22/01/14','DD/MM/RR'),'28754578','08487449425',to_date('01/07/92','DD/MM/RR'),'SSP-AM','167788',null,null,'69078480','Travessa S 6',null,null,'Japiim',null,null,null,null);
Insert into SEMAD.V_ESTAGIARIO (TX_NOME,CS_TIPO_PESSOA,CS_SEXO,DT_ATUALIZACAO,NB_RG,NB_CPF,DT_NASCIMENTO,TX_ORGAO_EMISSOR,ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('Laura','0','2',to_date('13/09/13','DD/MM/RR'),'255586931','90381947220',null,'ssp','168314',null,null,'69000000','livlvlv',null,null,null,null,null,null,null);
Insert into SEMAD.V_ESTAGIARIO (TX_NOME,CS_TIPO_PESSOA,CS_SEXO,DT_ATUALIZACAO,NB_RG,NB_CPF,DT_NASCIMENTO,TX_ORGAO_EMISSOR,ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('SMITH EDUARDO FERREIRA JUNIOR','0','1',to_date('28/10/13','DD/MM/RR'),'1257715152','88237343808',to_date('10/03/10','DD/MM/RR'),'SSP2','166329',null,null,'69000000','LVLVLVL',null,null,null,null,null,null,null);
Insert into SEMAD.V_ESTAGIARIO (TX_NOME,CS_TIPO_PESSOA,CS_SEXO,DT_ATUALIZACAO,NB_RG,NB_CPF,DT_NASCIMENTO,TX_ORGAO_EMISSOR,ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('RODRIGO OCTÃVIO CABRAL MADURO','0','1',to_date('02/04/14','DD/MM/RR'),'12933040','63813122204',to_date('05/11/78','DD/MM/RR'),'SESEG','27130',null,null,'69050520','Avenida Rio Negro','21','BL 10-A, APT 02, CONJ. ELDORADO','Parque 10 de Novembro','3711','00206792','9983-8492, 9336-2319','RODRIGO.CABRAL@PMM.AM.GOV.BR');
Insert into SEMAD.V_ESTAGIARIO (TX_NOME,CS_TIPO_PESSOA,CS_SEXO,DT_ATUALIZACAO,NB_RG,NB_CPF,DT_NASCIMENTO,TX_ORGAO_EMISSOR,ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('Antonia Viana','0','2',to_date('11/09/13','DD/MM/RR'),'2545896','90381955249',null,'SSP','168290',null,null,'69000000','vlvlvlivl',null,null,null,null,null,null,null);
Insert into SEMAD.V_ESTAGIARIO (TX_NOME,CS_TIPO_PESSOA,CS_SEXO,DT_ATUALIZACAO,NB_RG,NB_CPF,DT_NASCIMENTO,TX_ORGAO_EMISSOR,ID_PESSOA_ESTAGIARIO,ID_PESSOA_FUNCIONARIO,NB_FUNCIONARIO,TX_CEP,TX_ENDERECO,NB_NUMERO,TX_COMPLEMENTO,TX_BAIRRO,TX_AGENCIA,TX_CONTA_CORRENTE,TX_CONTATO,TX_EMAIL) values ('CLÃUDIA SOUZA CABRAL DA SILVA MADURO','0','2',to_date('01/04/14','DD/MM/RR'),null,'75010755220',to_date('06/12/81','DD/MM/RR'),null,'169166',null,null,'69010170','AVENIDA LEONARDO MALCHER','834','CASA 01','CENTRO','0320','06584993','9467-9435','KAKAUSAREL@HOTMAIL.COM');
--------------------------------------------------------
--  DDL for Index XIF1ORGAO_GESTOR_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1ORGAO_GESTOR_ESTAGIO" ON "SEMAD"."ORGAO_GESTOR_ESTAGIO" ("ID_UNIDADE_ORG") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKORGAO_GESTOR_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKORGAO_GESTOR_ESTAGIO" ON "SEMAD"."ORGAO_GESTOR_ESTAGIO" ("ID_ORGAO_GESTOR_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index AGENCIA_ESTAGIO_EMAIL_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."AGENCIA_ESTAGIO_EMAIL_PK" ON "SEMAD"."AGENCIA_ESTAGIO_EMAIL" ("ID_AGENCIA_ESTAGIO", "NB_AGENCIA_ESTAGIO_EMAIL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF1AGENCIA_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1AGENCIA_ESTAGIO" ON "SEMAD"."AGENCIA_ESTAGIO" ("ID_USUARIO_CADASTRO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF1AGENTE_SETORIAL_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1AGENTE_SETORIAL_ESTAGIO" ON "SEMAD"."AGENTE_SETORIAL_ESTAGIO" ("ID_USUARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF1CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1CONTRATO_ESTAGIO" ON "SEMAD"."CONTRATO_ESTAGIO" ("ID_PESSOA_ESTAGIARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF1CURSO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1CURSO_ESTAGIO" ON "SEMAD"."CURSO_ESTAGIO" ("CS_AREA_CONHECIMENTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF1ITEM_PAG_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1ITEM_PAG_ESTAGIO" ON "SEMAD"."ITEM_PAG_ESTAGIO" ("ID_PAGAMENTO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF1ORGAO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1ORGAO_ESTAGIO" ON "SEMAD"."ORGAO_ESTAGIO" ("ID_UNIDADE_ORG") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF1PAGAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1PAGAMENTO_ESTAGIO" ON "SEMAD"."PAGAMENTO_ESTAGIO" ("ID_ORGAO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF1RECESSO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1RECESSO_ESTAGIO" ON "SEMAD"."RECESSO_ESTAGIO" ("ID_CONTRATO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF1RECRUTAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1RECRUTAMENTO_ESTAGIO" ON "SEMAD"."RECRUTAMENTO_ESTAGIO" ("ID_QUADRO_VAGAS_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF1SELECAO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1SELECAO_ESTAGIO" ON "SEMAD"."SELECAO_ESTAGIO" ("ID_USUARIO_CADASTRO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF1SOLICITACAO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1SOLICITACAO_ESTAGIO" ON "SEMAD"."SOLICITACAO_ESTAGIO" ("ID_USUARIO_CADASTRO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF1VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1VAGAS_ESTAGIO" ON "SEMAD"."VAGAS_ESTAGIO" ("ID_QUADRO_VAGAS_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF10CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF10CONTRATO_ESTAGIO" ON "SEMAD"."CONTRATO_ESTAGIO" ("ID_UNIDADE_ORG") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF11CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF11CONTRATO_ESTAGIO" ON "SEMAD"."CONTRATO_ESTAGIO" ("ID_SELECAO_ESTAGIO", "ID_RECRUTAMENTO_ESTAGIO", "NB_VAGAS_RECRUTAMENTO", "NB_CANDIDATO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF12CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF12CONTRATO_ESTAGIO" ON "SEMAD"."CONTRATO_ESTAGIO" ("ID_AGENCIA_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF2AGENCIA_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF2AGENCIA_ESTAGIO" ON "SEMAD"."AGENCIA_ESTAGIO" ("ID_USUARIO_ATUALIZACAO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF2CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF2CONTRATO_ESTAGIO" ON "SEMAD"."CONTRATO_ESTAGIO" ("ID_ORGAO_GESTOR_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF2ITEM_PAG_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF2ITEM_PAG_ESTAGIO" ON "SEMAD"."ITEM_PAG_ESTAGIO" ("ID_ITEM_PAGAMENTO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF2ORGAO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF2ORGAO_ESTAGIO" ON "SEMAD"."ORGAO_ESTAGIO" ("ID_USUARIO_CADASTRO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF2PAGAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF2PAGAMENTO_ESTAGIO" ON "SEMAD"."PAGAMENTO_ESTAGIO" ("ID_ORGAO_GESTOR_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF2QUADRO_VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF2QUADRO_VAGAS_ESTAGIO" ON "SEMAD"."QUADRO_VAGAS_ESTAGIO" ("ID_ORGAO_GESTOR_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF2RECESSO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF2RECESSO_ESTAGIO" ON "SEMAD"."RECESSO_ESTAGIO" ("ID_ORGAO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF2RECRUTAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF2RECRUTAMENTO_ESTAGIO" ON "SEMAD"."RECRUTAMENTO_ESTAGIO" ("ID_ORGAO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF2SOLICITACAO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF2SOLICITACAO_ESTAGIO" ON "SEMAD"."SOLICITACAO_ESTAGIO" ("ID_USUARIO_ATUALIZACAO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF2SUPERVISOR_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF2SUPERVISOR_ESTAGIO" ON "SEMAD"."SUPERVISOR_ESTAGIO" ("ID_PESSOA_FUNCIONARIO", "NB_FUNCIONARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF2VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF2VAGAS_ESTAGIO" ON "SEMAD"."VAGAS_ESTAGIO" ("ID_ORGAO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF3CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF3CONTRATO_ESTAGIO" ON "SEMAD"."CONTRATO_ESTAGIO" ("ID_ORGAO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF3ITEM_PAG_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF3ITEM_PAG_ESTAGIO" ON "SEMAD"."ITEM_PAG_ESTAGIO" ("ID_USUARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF3ORGAO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF3ORGAO_ESTAGIO" ON "SEMAD"."ORGAO_ESTAGIO" ("ID_USUARIO_ATUALIZACAO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF3PAGAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF3PAGAMENTO_ESTAGIO" ON "SEMAD"."PAGAMENTO_ESTAGIO" ("ID_AGENCIA_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF3QUADRO_VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF3QUADRO_VAGAS_ESTAGIO" ON "SEMAD"."QUADRO_VAGAS_ESTAGIO" ("ID_USUARIO_CADASTRO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF3RECESSO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF3RECESSO_ESTAGIO" ON "SEMAD"."RECESSO_ESTAGIO" ("ID_AGENCIA_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF3RECRUTAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF3RECRUTAMENTO_ESTAGIO" ON "SEMAD"."RECRUTAMENTO_ESTAGIO" ("ID_USUARIO_CADASTRO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF3SELECAO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF3SELECAO_ESTAGIO" ON "SEMAD"."SELECAO_ESTAGIO" ("ID_ORGAO_GESTOR_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF3SOLICITACAO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF3SOLICITACAO_ESTAGIO" ON "SEMAD"."SOLICITACAO_ESTAGIO" ("ID_ORGAO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF3SUPERVISOR_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF3SUPERVISOR_ESTAGIO" ON "SEMAD"."SUPERVISOR_ESTAGIO" ("ID_CONSELHO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF3VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF3VAGAS_ESTAGIO" ON "SEMAD"."VAGAS_ESTAGIO" ("CS_TIPO_VAGA_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF4CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF4CONTRATO_ESTAGIO" ON "SEMAD"."CONTRATO_ESTAGIO" ("ID_QUADRO_VAGAS_ESTAGIO", "ID_ORGAO_ESTAGIO", "CS_TIPO_VAGA_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF4ITEM_PAG_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF4ITEM_PAG_ESTAGIO" ON "SEMAD"."ITEM_PAG_ESTAGIO" ("ID_CONTRATO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF4PAGAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF4PAGAMENTO_ESTAGIO" ON "SEMAD"."PAGAMENTO_ESTAGIO" ("ID_USUARIO_CADASTRO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF4QUADRO_VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF4QUADRO_VAGAS_ESTAGIO" ON "SEMAD"."QUADRO_VAGAS_ESTAGIO" ("ID_USUARIO_ATUALIZACAO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF4RECRUTAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF4RECRUTAMENTO_ESTAGIO" ON "SEMAD"."RECRUTAMENTO_ESTAGIO" ("ID_USUARIO_ATUALIZACAO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF4SELECAO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF4SELECAO_ESTAGIO" ON "SEMAD"."SELECAO_ESTAGIO" ("ID_ORGAO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF4SOLICITACAO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF4SOLICITACAO_ESTAGIO" ON "SEMAD"."SOLICITACAO_ESTAGIO" ("ID_ORGAO_GESTOR_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF4VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF4VAGAS_ESTAGIO" ON "SEMAD"."VAGAS_ESTAGIO" ("ID_USUARIO_CADASTRO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF5CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF5CONTRATO_ESTAGIO" ON "SEMAD"."CONTRATO_ESTAGIO" ("ID_CURSO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF5PAGAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF5PAGAMENTO_ESTAGIO" ON "SEMAD"."PAGAMENTO_ESTAGIO" ("ID_USUARIO_ATUALIZACAO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF5SELECAO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF5SELECAO_ESTAGIO" ON "SEMAD"."SELECAO_ESTAGIO" ("ID_USUARIO_ATUALIZACAO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF5SEMADSOLICITACAO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF5SEMADSOLICITACAO_ESTAGIO" ON "SEMAD"."SOLICITACAO_ESTAGIO" ("ID_QUADRO_VAGAS_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF5VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF5VAGAS_ESTAGIO" ON "SEMAD"."VAGAS_ESTAGIO" ("ID_USUARIO_ATUALIZACAO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF6CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF6CONTRATO_ESTAGIO" ON "SEMAD"."CONTRATO_ESTAGIO" ("ID_PESSOA_SUPERVISOR") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF6PAGAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF6PAGAMENTO_ESTAGIO" ON "SEMAD"."PAGAMENTO_ESTAGIO" ("CS_TIPO_PAG_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF6RECESSO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF6RECESSO_ESTAGIO" ON "SEMAD"."RECESSO_ESTAGIO" ("ID_SETORIAL_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF6VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF6VAGAS_ESTAGIO" ON "SEMAD"."VAGAS_ESTAGIO" ("ID_CURSO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF7CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF7CONTRATO_ESTAGIO" ON "SEMAD"."CONTRATO_ESTAGIO" ("ID_INSTITUICAO_ENSINO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF7RECESSO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF7RECESSO_ESTAGIO" ON "SEMAD"."RECESSO_ESTAGIO" ("ID_USUARIO_CADASTRO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF8CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF8CONTRATO_ESTAGIO" ON "SEMAD"."CONTRATO_ESTAGIO" ("ID_BOLSA_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF8RECESSO_ESTAGIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF8RECESSO_ESTAGIO" ON "SEMAD"."RECESSO_ESTAGIO" ("ID_USUARIO_ATUALIZACAO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKAGENCIA_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKAGENCIA_ESTAGIO" ON "SEMAD"."AGENCIA_ESTAGIO" ("ID_AGENCIA_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKAGENTE_SETORIAL_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKAGENTE_SETORIAL_ESTAGIO" ON "SEMAD"."AGENTE_SETORIAL_ESTAGIO" ("ID_SETORIAL_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKBOLSA_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKBOLSA_ESTAGIO" ON "SEMAD"."BOLSA_ESTAGIO" ("ID_BOLSA_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKCONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKCONTRATO_ESTAGIO" ON "SEMAD"."CONTRATO_ESTAGIO" ("ID_CONTRATO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKCURSO_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKCURSO_ESTAGIO" ON "SEMAD"."CURSO_ESTAGIO" ("ID_CURSO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKITEM_PAGAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKITEM_PAGAMENTO_ESTAGIO" ON "SEMAD"."ITEM_PAGAMENTO_ESTAGIO" ("ID_ITEM_PAGAMENTO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKITEM_PAG_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKITEM_PAG_ESTAGIO" ON "SEMAD"."ITEM_PAG_ESTAGIO" ("ID_PAGAMENTO_ESTAGIO", "ID_ITEM_PAGAMENTO_ESTAGIO", "ID_CONTRATO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKORGAO_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKORGAO_ESTAGIO" ON "SEMAD"."ORGAO_ESTAGIO" ("ID_ORGAO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKPAGAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKPAGAMENTO_ESTAGIO" ON "SEMAD"."PAGAMENTO_ESTAGIO" ("ID_PAGAMENTO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKQUADRO_VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKQUADRO_VAGAS_ESTAGIO" ON "SEMAD"."QUADRO_VAGAS_ESTAGIO" ("ID_QUADRO_VAGAS_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKRECESSO_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKRECESSO_ESTAGIO" ON "SEMAD"."RECESSO_ESTAGIO" ("ID_RECESSO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKRECRUTAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKRECRUTAMENTO_ESTAGIO" ON "SEMAD"."RECRUTAMENTO_ESTAGIO" ("ID_RECRUTAMENTO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKSELECAO_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKSELECAO_ESTAGIO" ON "SEMAD"."SELECAO_ESTAGIO" ("ID_SELECAO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKSOLICITACAO_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKSOLICITACAO_ESTAGIO" ON "SEMAD"."SOLICITACAO_ESTAGIO" ("ID_SOLICITACAO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKSUPERVISOR_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKSUPERVISOR_ESTAGIO" ON "SEMAD"."SUPERVISOR_ESTAGIO" ("ID_PESSOA_SUPERVISOR") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKTIPO_PAG_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKTIPO_PAG_ESTAGIO" ON "SEMAD"."TIPO_PAG_ESTAGIO" ("CS_TIPO_PAG_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKTIPO_VAGA_ESTAGIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKTIPO_VAGA_ESTAGIO" ON "SEMAD"."TIPO_VAGA_ESTAGIO" ("CS_TIPO_VAGA_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index ESTAGIARIO_SELECAO_INDEX1
--------------------------------------------------------

  CREATE INDEX "SEMAD"."ESTAGIARIO_SELECAO_INDEX1" ON "SEMAD"."ESTAGIARIO_SELECAO" ("ID_SELECAO_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index ESTAGIARIO_SELECAO_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."ESTAGIARIO_SELECAO_PK" ON "SEMAD"."ESTAGIARIO_SELECAO" ("ID_SELECAO_ESTAGIO", "ID_PESSOA_ESTAGIARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF1ESTAGIARIO_VAGA
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF1ESTAGIARIO_VAGA" ON "SEMAD"."ESTAGIARIO_VAGA" ("ID_RECRUTAMENTO_ESTAGIO", "NB_VAGAS_RECRUTAMENTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF2ESTAGIARIO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF2ESTAGIARIO" ON "SEMAD"."ESTAGIARIO" ("ID_PESSOA_FUNCIONARIO", "NB_FUNCIONARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF2ESTAGIARIO_VAGA
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF2ESTAGIARIO_VAGA" ON "SEMAD"."ESTAGIARIO_VAGA" ("ID_PESSOA_ESTAGIARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XIF4ESTAGIARIO_SELECAO
--------------------------------------------------------

  CREATE INDEX "SEMAD"."XIF4ESTAGIARIO_SELECAO" ON "SEMAD"."ESTAGIARIO_SELECAO" ("ID_USUARIO_CADASTRO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKESTAGIARIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKESTAGIARIO" ON "SEMAD"."ESTAGIARIO" ("ID_PESSOA_ESTAGIARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index XPKESTAGIARIO_VAGA
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."XPKESTAGIARIO_VAGA" ON "SEMAD"."ESTAGIARIO_VAGA" ("ID_RECRUTAMENTO_ESTAGIO", "NB_VAGAS_RECRUTAMENTO", "NB_CANDIDATO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  DDL for Index SYS_C0082037
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEMAD"."SYS_C0082037" ON "SEMAD"."VAGAS_ESTAGIO" ("ID_QUADRO_VAGAS_ESTAGIO", "ID_ORGAO_ESTAGIO", "CS_TIPO_VAGA_ESTAGIO", "ID_AGENCIA_ESTAGIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA" ;
--------------------------------------------------------
--  Constraints for Table ORGAO_GESTOR_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ORGAO_GESTOR_ESTAGIO" MODIFY ("ID_ORGAO_GESTOR_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ORGAO_GESTOR_ESTAGIO" MODIFY ("TX_ORGAO_GESTOR_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ORGAO_GESTOR_ESTAGIO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ORGAO_GESTOR_ESTAGIO" MODIFY ("DT_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ORGAO_GESTOR_ESTAGIO" MODIFY ("ID_UNIDADE_ORG" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ORGAO_GESTOR_ESTAGIO" ADD PRIMARY KEY ("ID_ORGAO_GESTOR_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
 
  ALTER TABLE "SEMAD"."ORGAO_GESTOR_ESTAGIO" MODIFY ("TX_CNPJ" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table AGENCIA_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO" MODIFY ("ID_AGENCIA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO" MODIFY ("TX_AGENCIA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO" MODIFY ("DT_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO" MODIFY ("TX_SIGLA" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO" MODIFY ("TX_CNPJ" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO" MODIFY ("ID_USUARIO_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO" MODIFY ("ID_USUARIO_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO" ADD PRIMARY KEY ("ID_AGENCIA_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
--------------------------------------------------------
--  Constraints for Table AGENCIA_ESTAGIO_EMAIL
--------------------------------------------------------

  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO_EMAIL" ADD CONSTRAINT "AGENCIA_ESTAGIO_EMAIL_PK" PRIMARY KEY ("ID_AGENCIA_ESTAGIO", "NB_AGENCIA_ESTAGIO_EMAIL")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
 
  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO_EMAIL" MODIFY ("ID_AGENCIA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO_EMAIL" MODIFY ("NB_AGENCIA_ESTAGIO_EMAIL" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO_EMAIL" MODIFY ("TX_AGENCIA_EMAIL" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table AGENTE_SETORIAL_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."AGENTE_SETORIAL_ESTAGIO" MODIFY ("ID_SETORIAL_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENTE_SETORIAL_ESTAGIO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENTE_SETORIAL_ESTAGIO" MODIFY ("DT_ATULIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENTE_SETORIAL_ESTAGIO" ADD PRIMARY KEY ("ID_SETORIAL_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
 
  ALTER TABLE "SEMAD"."AGENTE_SETORIAL_ESTAGIO" MODIFY ("ID_USUARIO_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENTE_SETORIAL_ESTAGIO" MODIFY ("ID_USUARIO_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENTE_SETORIAL_ESTAGIO" MODIFY ("ID_USUARIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."AGENTE_SETORIAL_ESTAGIO" MODIFY ("TX_EMAIL" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BOLSA_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."BOLSA_ESTAGIO" MODIFY ("ID_BOLSA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."BOLSA_ESTAGIO" MODIFY ("TX_BOLSA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."BOLSA_ESTAGIO" MODIFY ("NB_VALOR" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."BOLSA_ESTAGIO" ADD PRIMARY KEY ("ID_BOLSA_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
--------------------------------------------------------
--  Constraints for Table CONTRATO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_QUADRO_VAGAS_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_PESSOA_SUPERVISOR" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("DT_DESLIGAMENTO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("TX_PLANO_ATIVIDADE" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_RECRUTAMENTO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("NB_VAGAS_RECRUTAMENTO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_AGENCIA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("TX_EMAIL" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("TX_TELEFONE" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("TX_ENDERECO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_PESSOA_ESTAGIARIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_CONTRATO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_ORGAO_GESTOR_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_ORGAO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_CURSO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_INSTITUICAO_ENSINO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_BOLSA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("DT_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("DT_INICIO_VIGENCIA" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("DT_FIM_VIGENCIA" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_UNIDADE_ORG" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("CS_TIPO_VAGA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" ADD PRIMARY KEY ("ID_CONTRATO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("CS_PERIODO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("CS_HORARIO_CURSO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("NB_INICIO_HORARIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("NB_FIM_HORARIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("CS_TIPO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_USUARIO_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("ID_USUARIO_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" MODIFY ("CS_SELECAO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CURSO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."CURSO_ESTAGIO" MODIFY ("ID_CURSO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CURSO_ESTAGIO" MODIFY ("TX_CURSO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."CURSO_ESTAGIO" ADD PRIMARY KEY ("ID_CURSO_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ITEM_PAGAMENTO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ITEM_PAGAMENTO_ESTAGIO" MODIFY ("ID_ITEM_PAGAMENTO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAGAMENTO_ESTAGIO" MODIFY ("TX_CODIGO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAGAMENTO_ESTAGIO" MODIFY ("TX_DESCRICAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAGAMENTO_ESTAGIO" MODIFY ("TX_SIGLA" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAGAMENTO_ESTAGIO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAGAMENTO_ESTAGIO" MODIFY ("DT_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAGAMENTO_ESTAGIO" MODIFY ("CS_TIPO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAGAMENTO_ESTAGIO" MODIFY ("CS_SITUACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAGAMENTO_ESTAGIO" ADD PRIMARY KEY ("ID_ITEM_PAGAMENTO_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ITEM_PAG_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ITEM_PAG_ESTAGIO" MODIFY ("ID_PAGAMENTO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAG_ESTAGIO" MODIFY ("ID_ITEM_PAGAMENTO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAG_ESTAGIO" MODIFY ("DT_PROCESSAMENTO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAG_ESTAGIO" MODIFY ("NB_VALOR_BASE" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAG_ESTAGIO" MODIFY ("NB_VALOR_CALCULADO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAG_ESTAGIO" MODIFY ("ID_USUARIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAG_ESTAGIO" MODIFY ("ID_CONTRATO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ITEM_PAG_ESTAGIO" ADD PRIMARY KEY ("ID_PAGAMENTO_ESTAGIO", "ID_ITEM_PAGAMENTO_ESTAGIO", "ID_CONTRATO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ORGAO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ORGAO_ESTAGIO" MODIFY ("ID_ORGAO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ORGAO_ESTAGIO" MODIFY ("TX_ORGAO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ORGAO_ESTAGIO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ORGAO_ESTAGIO" MODIFY ("DT_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ORGAO_ESTAGIO" MODIFY ("ID_USUARIO_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ORGAO_ESTAGIO" MODIFY ("ID_USUARIO_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ORGAO_ESTAGIO" ADD PRIMARY KEY ("ID_ORGAO_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
 
  ALTER TABLE "SEMAD"."ORGAO_ESTAGIO" MODIFY ("CS_STATUS" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table PAGAMENTO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("ID_PAGAMENTO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("DT_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("NB_ANO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("NB_MES" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("CS_SITUACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("NB_DIAS_UTEIS" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("ID_ORGAO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("ID_ORGAO_GESTOR_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("ID_AGENCIA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("ID_USUARIO_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("ID_USUARIO_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("CS_TIPO_PAG_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("DT_INICIO_COMPETENCIA" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("DT_FIM_COMPETENCIA" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("DT_INICIO_FREQUENCIA" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" MODIFY ("DT_FIM_FREQUENCIA" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" ADD PRIMARY KEY ("ID_PAGAMENTO_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
--------------------------------------------------------
--  Constraints for Table QUADRO_VAGAS_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" MODIFY ("ID_QUADRO_VAGAS_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" MODIFY ("ID_ORGAO_GESTOR_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" MODIFY ("DT_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" MODIFY ("ID_USUARIO_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" ADD PRIMARY KEY ("ID_QUADRO_VAGAS_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
 
  ALTER TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" MODIFY ("ID_USUARIO_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" MODIFY ("CS_SITUACAO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table RECESSO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("ID_RECESSO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("TX_CODIGO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("TX_CARGO_AGENTE" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("TX_EMAIL_AGENTE" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("TX_TELEFONE_AGENTE" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("DT_INICIO_VIG_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("ID_CONTRATO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("ID_SETORIAL_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("ID_AGENCIA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("ID_ORGAO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("DT_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("CS_SITUACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("DT_FIM_VIGENCIA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("DT_INICIO_RECESSO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("DT_FIM_RECESSO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("NB_MES_REFERENCIA" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("NB_ANO_REFERENCIA" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("DT_ASSINATURA" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("CS_REALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" MODIFY ("ID_ORGAO_GESTOR_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" ADD CONSTRAINT "XPKRECESSO_ESTAGIO" PRIMARY KEY ("ID_RECESSO_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
--------------------------------------------------------
--  Constraints for Table RECRUTAMENTO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" MODIFY ("ID_RECRUTAMENTO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" MODIFY ("DT_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" MODIFY ("ID_USUARIO_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" MODIFY ("ID_USUARIO_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" MODIFY ("TX_COD_RECRUTAMENTO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" ADD PRIMARY KEY ("ID_RECRUTAMENTO_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" MODIFY ("CS_SITUACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" MODIFY ("ID_SOLICITACAO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" MODIFY ("ID_QUADRO_VAGAS_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" MODIFY ("ID_ORGAO_ESTAGIO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SELECAO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" MODIFY ("ID_SELECAO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" MODIFY ("DT_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" MODIFY ("ID_ORGAO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" MODIFY ("ID_USUARIO_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" MODIFY ("ID_ORGAO_GESTOR_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" MODIFY ("ID_USUARIO_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" ADD PRIMARY KEY ("ID_SELECAO_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
 
  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" MODIFY ("CS_SITUACAO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SOLICITACAO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."SOLICITACAO_ESTAGIO" MODIFY ("ID_SOLICITACAO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."SOLICITACAO_ESTAGIO" MODIFY ("ID_ORGAO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."SOLICITACAO_ESTAGIO" MODIFY ("ID_ORGAO_GESTOR_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."SOLICITACAO_ESTAGIO" ADD PRIMARY KEY ("ID_SOLICITACAO_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SUPERVISOR_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."SUPERVISOR_ESTAGIO" MODIFY ("ID_PESSOA_SUPERVISOR" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."SUPERVISOR_ESTAGIO" MODIFY ("ID_PESSOA_FUNCIONARIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."SUPERVISOR_ESTAGIO" MODIFY ("NB_FUNCIONARIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."SUPERVISOR_ESTAGIO" ADD PRIMARY KEY ("ID_PESSOA_SUPERVISOR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TIPO_PAG_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."TIPO_PAG_ESTAGIO" MODIFY ("CS_TIPO_PAG_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."TIPO_PAG_ESTAGIO" MODIFY ("TX_TIPO_PAG_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."TIPO_PAG_ESTAGIO" ADD PRIMARY KEY ("CS_TIPO_PAG_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TIPO_VAGA_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."TIPO_VAGA_ESTAGIO" MODIFY ("CS_TIPO_VAGA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."TIPO_VAGA_ESTAGIO" MODIFY ("TX_TIPO_VAGA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."TIPO_VAGA_ESTAGIO" ADD PRIMARY KEY ("CS_TIPO_VAGA_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
--------------------------------------------------------
--  Constraints for Table VAGAS_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" MODIFY ("ID_QUADRO_VAGAS_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" MODIFY ("ID_ORGAO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" MODIFY ("NB_QUANTIDADE" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" MODIFY ("CS_TIPO_VAGA_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" MODIFY ("DT_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" MODIFY ("ID_USUARIO_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" MODIFY ("ID_USUARIO_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" ADD CONSTRAINT "SYS_C0082037" PRIMARY KEY ("ID_QUADRO_VAGAS_ESTAGIO", "ID_ORGAO_ESTAGIO", "CS_TIPO_VAGA_ESTAGIO", "ID_AGENCIA_ESTAGIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" MODIFY ("ID_AGENCIA_ESTAGIO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table ESTAGIARIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ESTAGIARIO" MODIFY ("ID_PESSOA_ESTAGIARIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO" ADD PRIMARY KEY ("ID_PESSOA_ESTAGIARIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ESTAGIARIO_CONTRATO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ESTAGIARIO_CONTRATO" ADD CONSTRAINT "ESTAGIARIO_CONTRATO_PK" PRIMARY KEY ("ID_CONTRATO", "NB_ESTAGIARIO_CONTRATO") DISABLE;
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_CONTRATO" MODIFY ("ID_CONTRATO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_CONTRATO" MODIFY ("NB_ESTAGIARIO_CONTRATO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_CONTRATO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_CONTRATO" MODIFY ("DT_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_CONTRATO" MODIFY ("ID_USUARIO_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_CONTRATO" MODIFY ("ID_USUARIO_ATUALIZACAO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table ESTAGIARIO_SELECAO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" ADD CONSTRAINT "ESTAGIARIO_SELECAO_PK" PRIMARY KEY ("ID_SELECAO_ESTAGIO", "ID_PESSOA_ESTAGIARIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" MODIFY ("ID_SELECAO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" MODIFY ("CS_SITUACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" MODIFY ("ID_USUARIO_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" MODIFY ("ID_PESSOA_ESTAGIARIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" MODIFY ("ID_USUARIO_ATUALIZACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" MODIFY ("DT_CADASTRO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" MODIFY ("DT_ATUALIZACAO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table ESTAGIARIO_VAGA
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ESTAGIARIO_VAGA" MODIFY ("ID_RECRUTAMENTO_ESTAGIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_VAGA" MODIFY ("NB_VAGAS_RECRUTAMENTO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_VAGA" MODIFY ("NB_CANDIDATO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_VAGA" MODIFY ("CS_SITUACAO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_VAGA" MODIFY ("ID_PESSOA_ESTAGIARIO" NOT NULL ENABLE);
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_VAGA" ADD CONSTRAINT "XPKESTAGIARIO_VAGA" PRIMARY KEY ("ID_RECRUTAMENTO_ESTAGIO", "NB_VAGAS_RECRUTAMENTO", "NB_CANDIDATO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "PMM_DATA"  ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ORGAO_GESTOR_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ORGAO_GESTOR_ESTAGIO" ADD FOREIGN KEY ("ID_UNIDADE_ORG")
	  REFERENCES "SEMAD"."UNIDADE_ORG" ("ID_UNIDADE_ORG") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table AGENCIA_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_ATUALIZACAO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."AGENCIA_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_CADASTRO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table AGENTE_SETORIAL_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."AGENTE_SETORIAL_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table CONTRATO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" ADD FOREIGN KEY ("ID_UNIDADE_ORG")
	  REFERENCES "SEMAD"."UNIDADE_ORG" ("ID_UNIDADE_ORG") ENABLE;
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" ADD FOREIGN KEY ("ID_BOLSA_ESTAGIO")
	  REFERENCES "SEMAD"."BOLSA_ESTAGIO" ("ID_BOLSA_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" ADD FOREIGN KEY ("ID_INSTITUICAO_ENSINO")
	  REFERENCES "SEMAD"."INSTITUICAO_ENSINO" ("ID_INSTITUICAO_ENSINO") ENABLE;
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" ADD FOREIGN KEY ("ID_CURSO_ESTAGIO")
	  REFERENCES "SEMAD"."CURSO_ESTAGIO" ("ID_CURSO_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" ADD FOREIGN KEY ("ID_ORGAO_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_ESTAGIO" ("ID_ORGAO_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" ADD FOREIGN KEY ("ID_ORGAO_GESTOR_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_GESTOR_ESTAGIO" ("ID_ORGAO_GESTOR_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" ADD FOREIGN KEY ("ID_PESSOA_ESTAGIARIO")
	  REFERENCES "SEMAD"."ESTAGIARIO" ("ID_PESSOA_ESTAGIARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" ADD FOREIGN KEY ("ID_AGENCIA_ESTAGIO")
	  REFERENCES "SEMAD"."AGENCIA_ESTAGIO" ("ID_AGENCIA_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" ADD FOREIGN KEY ("ID_PESSOA_SUPERVISOR")
	  REFERENCES "SEMAD"."SUPERVISOR_ESTAGIO" ("ID_PESSOA_SUPERVISOR") ENABLE;
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" ADD CONSTRAINT "XFK1_CONTRATO" FOREIGN KEY ("ID_USUARIO_CADASTRO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."CONTRATO_ESTAGIO" ADD CONSTRAINT "XFK2_CONTRATO" FOREIGN KEY ("ID_USUARIO_ATUALIZACAO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table CURSO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."CURSO_ESTAGIO" ADD FOREIGN KEY ("CS_AREA_CONHECIMENTO")
	  REFERENCES "SEMAD"."AREA_CONHECIMENTO_GE" ("CS_AREA_CONHECIMENTO") ON DELETE SET NULL ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ITEM_PAG_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ITEM_PAG_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."ITEM_PAG_ESTAGIO" ADD FOREIGN KEY ("ID_ITEM_PAGAMENTO_ESTAGIO")
	  REFERENCES "SEMAD"."ITEM_PAGAMENTO_ESTAGIO" ("ID_ITEM_PAGAMENTO_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."ITEM_PAG_ESTAGIO" ADD FOREIGN KEY ("ID_PAGAMENTO_ESTAGIO")
	  REFERENCES "SEMAD"."PAGAMENTO_ESTAGIO" ("ID_PAGAMENTO_ESTAGIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ORGAO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ORGAO_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_ATUALIZACAO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."ORGAO_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_CADASTRO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."ORGAO_ESTAGIO" ADD FOREIGN KEY ("ID_UNIDADE_ORG")
	  REFERENCES "SEMAD"."UNIDADE_ORG" ("ID_UNIDADE_ORG") ON DELETE SET NULL ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table PAGAMENTO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" ADD FOREIGN KEY ("CS_TIPO_PAG_ESTAGIO")
	  REFERENCES "SEMAD"."TIPO_PAG_ESTAGIO" ("CS_TIPO_PAG_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_ATUALIZACAO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_CADASTRO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" ADD FOREIGN KEY ("ID_AGENCIA_ESTAGIO")
	  REFERENCES "SEMAD"."AGENCIA_ESTAGIO" ("ID_AGENCIA_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" ADD FOREIGN KEY ("ID_ORGAO_GESTOR_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_GESTOR_ESTAGIO" ("ID_ORGAO_GESTOR_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."PAGAMENTO_ESTAGIO" ADD FOREIGN KEY ("ID_ORGAO_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_ESTAGIO" ("ID_ORGAO_ESTAGIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table QUADRO_VAGAS_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" ADD CONSTRAINT "R_3017" FOREIGN KEY ("ID_CONTRATO_CP")
	  REFERENCES "SEMAD"."CONTRATO_CP" ("ID_CONTRATO_CP") ENABLE;
 
  ALTER TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_ATUALIZACAO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ON DELETE SET NULL ENABLE;
 
  ALTER TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_CADASTRO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."QUADRO_VAGAS_ESTAGIO" ADD FOREIGN KEY ("ID_ORGAO_GESTOR_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_GESTOR_ESTAGIO" ("ID_ORGAO_GESTOR_ESTAGIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table RECESSO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" ADD CONSTRAINT "R_2997" FOREIGN KEY ("ID_CONTRATO")
	  REFERENCES "SEMAD"."CONTRATO_ESTAGIO" ("ID_CONTRATO") ENABLE;
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" ADD CONSTRAINT "R_2998" FOREIGN KEY ("ID_ORGAO_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_ESTAGIO" ("ID_ORGAO_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" ADD CONSTRAINT "R_2999" FOREIGN KEY ("ID_AGENCIA_ESTAGIO")
	  REFERENCES "SEMAD"."AGENCIA_ESTAGIO" ("ID_AGENCIA_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" ADD CONSTRAINT "R_3003" FOREIGN KEY ("ID_SETORIAL_ESTAGIO")
	  REFERENCES "SEMAD"."AGENTE_SETORIAL_ESTAGIO" ("ID_SETORIAL_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" ADD CONSTRAINT "R_3004" FOREIGN KEY ("ID_USUARIO_CADASTRO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" ADD CONSTRAINT "R_3005" FOREIGN KEY ("ID_USUARIO_ATUALIZACAO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ON DELETE SET NULL ENABLE;
 
  ALTER TABLE "SEMAD"."RECESSO_ESTAGIO" ADD CONSTRAINT "R_3042" FOREIGN KEY ("ID_ORGAO_GESTOR_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_GESTOR_ESTAGIO" ("ID_ORGAO_GESTOR_ESTAGIO") ON DELETE SET NULL ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table RECRUTAMENTO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" ADD CONSTRAINT "RECRUTAMENTO_ESTAGIO_SOLI_FK1" FOREIGN KEY ("ID_SOLICITACAO_ESTAGIO")
	  REFERENCES "SEMAD"."SOLICITACAO_ESTAGIO" ("ID_SOLICITACAO_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_ATUALIZACAO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_CADASTRO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" ADD FOREIGN KEY ("ID_ORGAO_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_ESTAGIO" ("ID_ORGAO_ESTAGIO") ON DELETE SET NULL ENABLE;
 
  ALTER TABLE "SEMAD"."RECRUTAMENTO_ESTAGIO" ADD FOREIGN KEY ("ID_QUADRO_VAGAS_ESTAGIO")
	  REFERENCES "SEMAD"."QUADRO_VAGAS_ESTAGIO" ("ID_QUADRO_VAGAS_ESTAGIO") ON DELETE SET NULL ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SELECAO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" ADD CONSTRAINT "SELECAO_ESTAGIO_OFERTA_VA_FK1" FOREIGN KEY ("ID_OFERTA_VAGA")
	  REFERENCES "SEMAD"."OFERTA_VAGA" ("ID_OFERTA_VAGA") ENABLE;
 
  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_ATUALIZACAO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" ADD FOREIGN KEY ("ID_ORGAO_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_ESTAGIO" ("ID_ORGAO_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" ADD FOREIGN KEY ("ID_ORGAO_GESTOR_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_GESTOR_ESTAGIO" ("ID_ORGAO_GESTOR_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."SELECAO_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_CADASTRO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SOLICITACAO_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."SOLICITACAO_ESTAGIO" ADD FOREIGN KEY ("ID_ORGAO_GESTOR_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_GESTOR_ESTAGIO" ("ID_ORGAO_GESTOR_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."SOLICITACAO_ESTAGIO" ADD FOREIGN KEY ("ID_ORGAO_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_ESTAGIO" ("ID_ORGAO_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."SOLICITACAO_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_ATUALIZACAO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ON DELETE SET NULL ENABLE;
 
  ALTER TABLE "SEMAD"."SOLICITACAO_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_CADASTRO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ON DELETE SET NULL ENABLE;
 
  ALTER TABLE "SEMAD"."SOLICITACAO_ESTAGIO" ADD FOREIGN KEY ("ID_QUADRO_VAGAS_ESTAGIO")
	  REFERENCES "SEMAD"."QUADRO_VAGAS_ESTAGIO" ("ID_QUADRO_VAGAS_ESTAGIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SUPERVISOR_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."SUPERVISOR_ESTAGIO" ADD FOREIGN KEY ("ID_CONSELHO")
	  REFERENCES "SEMAD"."CONSELHO_PROFISSIONAL" ("ID_CONSELHO") ON DELETE SET NULL ENABLE;
 
  ALTER TABLE "SEMAD"."SUPERVISOR_ESTAGIO" ADD FOREIGN KEY ("ID_PESSOA_FUNCIONARIO", "NB_FUNCIONARIO")
	  REFERENCES "SEMAD"."FUNCIONARIO_PE" ("ID_PESSOA_FUNCIONARIO", "NB_FUNCIONARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."SUPERVISOR_ESTAGIO" ADD FOREIGN KEY ("ID_PESSOA_SUPERVISOR")
	  REFERENCES "SEMAD"."PESSOA_FISICA" ("ID_PESSOA") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table VAGAS_ESTAGIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" ADD FOREIGN KEY ("ID_CURSO_ESTAGIO")
	  REFERENCES "SEMAD"."CURSO_ESTAGIO" ("ID_CURSO_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_ATUALIZACAO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" ADD FOREIGN KEY ("ID_USUARIO_CADASTRO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" ADD FOREIGN KEY ("CS_TIPO_VAGA_ESTAGIO")
	  REFERENCES "SEMAD"."TIPO_VAGA_ESTAGIO" ("CS_TIPO_VAGA_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" ADD FOREIGN KEY ("ID_ORGAO_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_ESTAGIO" ("ID_ORGAO_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" ADD FOREIGN KEY ("ID_QUADRO_VAGAS_ESTAGIO")
	  REFERENCES "SEMAD"."QUADRO_VAGAS_ESTAGIO" ("ID_QUADRO_VAGAS_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."VAGAS_ESTAGIO" ADD CONSTRAINT "VAGAS_ESTAGIO_AGENCIA_EST_FK1" FOREIGN KEY ("ID_AGENCIA_ESTAGIO")
	  REFERENCES "SEMAD"."AGENCIA_ESTAGIO" ("ID_AGENCIA_ESTAGIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ESTAGIARIO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ESTAGIARIO" ADD FOREIGN KEY ("ID_PESSOA_FUNCIONARIO", "NB_FUNCIONARIO")
	  REFERENCES "SEMAD"."FUNCIONARIO_PE" ("ID_PESSOA_FUNCIONARIO", "NB_FUNCIONARIO") ON DELETE SET NULL ENABLE;
 
  ALTER TABLE "SEMAD"."ESTAGIARIO" ADD FOREIGN KEY ("ID_PESSOA_ESTAGIARIO")
	  REFERENCES "SEMAD"."PESSOA_FISICA" ("ID_PESSOA") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ESTAGIARIO_SELECAO
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" ADD CONSTRAINT "ESTAGIARIO_SELECAO_BOLSA__FK1" FOREIGN KEY ("ID_BOLSA_ESTAGIO")
	  REFERENCES "SEMAD"."BOLSA_ESTAGIO" ("ID_BOLSA_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" ADD CONSTRAINT "ESTAGIARIO_SELECAO_CURSO__FK1" FOREIGN KEY ("ID_CURSO_ESTAGIO")
	  REFERENCES "SEMAD"."CURSO_ESTAGIO" ("ID_CURSO_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" ADD CONSTRAINT "ESTAGIARIO_SELECAO_INSTIT_FK1" FOREIGN KEY ("ID_INSTITUICAO_ENSINO")
	  REFERENCES "SEMAD"."INSTITUICAO_ENSINO" ("ID_INSTITUICAO_ENSINO") ENABLE;
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" ADD CONSTRAINT "ESTAGIARIO_SELECAO_ORGAO__FK1" FOREIGN KEY ("ID_ORGAO_ESTAGIO")
	  REFERENCES "SEMAD"."ORGAO_ESTAGIO" ("ID_ORGAO_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" ADD CONSTRAINT "ESTAGIARIO_SELECAO_SUPERV_FK1" FOREIGN KEY ("ID_PESSOA_SUPERVISOR")
	  REFERENCES "SEMAD"."SUPERVISOR_ESTAGIO" ("ID_PESSOA_SUPERVISOR") ENABLE;
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" ADD CONSTRAINT "ESTAGIARIO_SELECAO_TIPO_V_FK1" FOREIGN KEY ("CS_TIPO_VAGA_ESTAGIO")
	  REFERENCES "SEMAD"."TIPO_VAGA_ESTAGIO" ("CS_TIPO_VAGA_ESTAGIO") ENABLE;
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" ADD CONSTRAINT "ESTAGIARIO_SELECAO_USUARI_FK1" FOREIGN KEY ("ID_USUARIO_ATUALIZACAO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" ADD CONSTRAINT "PESSOA_ESTAGIARIO_SELECAO_FK1" FOREIGN KEY ("ID_PESSOA_ESTAGIARIO")
	  REFERENCES "SEMAD"."ESTAGIARIO" ("ID_PESSOA_ESTAGIARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" ADD FOREIGN KEY ("ID_USUARIO_CADASTRO")
	  REFERENCES "SEMAD"."USUARIO" ("ID_USUARIO") ENABLE;
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_SELECAO" ADD FOREIGN KEY ("ID_SELECAO_ESTAGIO")
	  REFERENCES "SEMAD"."SELECAO_ESTAGIO" ("ID_SELECAO_ESTAGIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ESTAGIARIO_VAGA
--------------------------------------------------------

  ALTER TABLE "SEMAD"."ESTAGIARIO_VAGA" ADD CONSTRAINT "R_2914" FOREIGN KEY ("ID_RECRUTAMENTO_ESTAGIO", "NB_VAGAS_RECRUTAMENTO")
	  REFERENCES "SEMAD"."VAGAS_RECRUTAMENTO" ("ID_RECRUTAMENTO_ESTAGIO", "NB_VAGAS_RECRUTAMENTO") ENABLE;
 
  ALTER TABLE "SEMAD"."ESTAGIARIO_VAGA" ADD FOREIGN KEY ("ID_PESSOA_ESTAGIARIO")
	  REFERENCES "SEMAD"."ESTAGIARIO" ("ID_PESSOA_ESTAGIARIO") ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_ORGAO_GESTOR_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_ORGAO_GESTOR_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Orgao_Gestor_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('ORGAO_GESTOR_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Orgao_Gestor_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_GESTOR_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Gestor_Estagio,
          :old.ID_Orgao_Gestor_Estagio);

-- insere valor do campo tx_Orgao_Gestor_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('TX_ORGAO_GESTOR_ESTAGIO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Orgao_Gestor_Estagio,
          :old.tx_Orgao_Gestor_Estagio);

-- insere valor do campo dt_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('DT_CADASTRO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Cadastro,
          :old.dt_Cadastro);

-- insere valor do campo dt_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_ATUALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Atualizacao,
          :old.dt_Atualizacao);

-- insere valor do campo ID_Unidade_Org --
  pnb_Campo := F_AVS_Busca_Campo('ID_UNIDADE_ORG',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Unidade_Org,
          :old.ID_Unidade_Org);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_ORGAO_GESTOR_ESTAGIO" DISABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_AGENCIA_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_AGENCIA_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Agencia_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('AGENCIA_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Agencia_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_AGENCIA_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Agencia_Estagio,
          :old.ID_Agencia_Estagio);

-- insere valor do campo tx_Agencia_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('TX_AGENCIA_ESTAGIO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Agencia_Estagio,
          :old.tx_Agencia_Estagio);

-- insere valor do campo dt_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('DT_CADASTRO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Cadastro,
          :old.dt_Cadastro);

-- insere valor do campo dt_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_ATUALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Atualizacao,
          :old.dt_Atualizacao);

-- insere valor do campo tx_Sigla --
  pnb_Campo := F_AVS_Busca_Campo('TX_SIGLA',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Sigla,
          :old.tx_Sigla);

-- insere valor do campo tx_CNPJ --
  pnb_Campo := F_AVS_Busca_Campo('TX_CNPJ',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_CNPJ,
          :old.tx_CNPJ);

-- insere valor do campo ID_Usuario_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_CADASTRO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Cadastro,
          :old.ID_Usuario_Cadastro);

-- insere valor do campo ID_Usuario_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_ATUALIZACAO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Atualizacao,
          :old.ID_Usuario_Atualizacao);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_AGENCIA_ESTAGIO" DISABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_AGENTE_SET_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_AGENTE_SET_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Agente_Setorial_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('AGENTE_SETORIAL_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Setorial_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_SETORIAL_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Setorial_Estagio,
          :old.ID_Setorial_Estagio);

-- insere valor do campo ID_Usuario_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_CADASTRO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Cadastro,
          :old.ID_Usuario_Cadastro);

-- insere valor do campo ID_Usuario_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_ATUALIZACAO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Atualizacao,
          :old.ID_Usuario_Atualizacao);

-- insere valor do campo ID_Usuario --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario,
          :old.ID_Usuario);

-- insere valor do campo dt_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('DT_CADASTRO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Cadastro,
          :old.dt_Cadastro);

-- insere valor do campo dt_Atulizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_ATULIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Atulizacao,
          :old.dt_Atulizacao);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_AGENTE_SET_ESTAGIO" DISABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_BOLSA_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_BOLSA_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Bolsa_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('BOLSA_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Bolsa_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_BOLSA_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Bolsa_Estagio,
          :old.ID_Bolsa_Estagio);

-- insere valor do campo tx_Bolsa_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('TX_BOLSA_ESTAGIO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Bolsa_Estagio,
          :old.tx_Bolsa_Estagio);

-- insere valor do campo nb_Valor --
  pnb_Campo := F_AVS_Busca_Campo('NB_VALOR',pID_Tabela,'NUMBER(12,2)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Valor,
          :old.nb_Valor);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_BOLSA_ESTAGIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_CONTRATO_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on SEMAD.Contrato_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('CONTRATO_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Contrato --
  pnb_Campo := F_AVS_Busca_Campo('ID_CONTRATO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Contrato,
          :old.ID_Contrato);

-- insere valor do campo ID_Pessoa_Estagiario --
  pnb_Campo := F_AVS_Busca_Campo('ID_PESSOA_ESTAGIARIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Pessoa_Estagiario,
          :old.ID_Pessoa_Estagiario);

-- insere valor do campo dt_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('DT_CADASTRO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Cadastro,
          :old.dt_Cadastro);

-- insere valor do campo dt_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_ATUALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Atualizacao,
          :old.dt_Atualizacao);

-- insere valor do campo dt_Inicio_Vigencia --
  pnb_Campo := F_AVS_Busca_Campo('DT_INICIO_VIGENCIA',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Inicio_Vigencia,
          :old.dt_Inicio_Vigencia);

-- insere valor do campo dt_Fim_Vigencia --
  pnb_Campo := F_AVS_Busca_Campo('DT_FIM_VIGENCIA',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Fim_Vigencia,
          :old.dt_Fim_Vigencia);

-- insere valor do campo dt_Desligamento --
  pnb_Campo := F_AVS_Busca_Campo('DT_DESLIGAMENTO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Desligamento,
          :old.dt_Desligamento);

-- insere valor do campo nb_Inicio_Horario --
  pnb_Campo := F_AVS_Busca_Campo('NB_INICIO_HORARIO',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Inicio_Horario,
          :old.nb_Inicio_Horario);

-- insere valor do campo nb_Fim_Horario --
  pnb_Campo := F_AVS_Busca_Campo('NB_FIM_HORARIO',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Fim_Horario,
          :old.nb_Fim_Horario);

-- insere valor do campo ID_Orgao_Gestor_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_GESTOR_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Gestor_Estagio,
          :old.ID_Orgao_Gestor_Estagio);

-- insere valor do campo ID_Orgao_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Estagio,
          :old.ID_Orgao_Estagio);

-- insere valor do campo ID_Quadro_Vagas_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_QUADRO_VAGAS_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Quadro_Vagas_Estagio,
          :old.ID_Quadro_Vagas_Estagio);

-- insere valor do campo ID_Curso_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_CURSO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Curso_Estagio,
          :old.ID_Curso_Estagio);

-- insere valor do campo ID_Pessoa_Supervisor --
  pnb_Campo := F_AVS_Busca_Campo('ID_PESSOA_SUPERVISOR',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Pessoa_Supervisor,
          :old.ID_Pessoa_Supervisor);

-- insere valor do campo ID_Instituicao_Ensino --
  pnb_Campo := F_AVS_Busca_Campo('ID_INSTITUICAO_ENSINO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Instituicao_Ensino,
          :old.ID_Instituicao_Ensino);

-- insere valor do campo ID_Bolsa_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_BOLSA_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Bolsa_Estagio,
          :old.ID_Bolsa_Estagio);

-- insere valor do campo tx_Plano_Atividade --
  pnb_Campo := F_AVS_Busca_Campo('TX_PLANO_ATIVIDADE',pID_Tabela,'VARCHAR2(2000)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Plano_Atividade,
          :old.tx_Plano_Atividade);

-- insere valor do campo cs_Tipo --
  pnb_Campo := F_AVS_Busca_Campo('CS_TIPO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Tipo,
          :old.cs_Tipo);

-- insere valor do campo tx_TCE --
  pnb_Campo := F_AVS_Busca_Campo('TX_TCE',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_TCE,
          :old.tx_TCE);

-- insere valor do campo ID_Unidade_Org --
  pnb_Campo := F_AVS_Busca_Campo('ID_UNIDADE_ORG',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Unidade_Org,
          :old.ID_Unidade_Org);

-- insere valor do campo ID_Selecao_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_SELECAO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Selecao_Estagio,
          :old.ID_Selecao_Estagio);

-- insere valor do campo ID_Recrutamento_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_RECRUTAMENTO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Recrutamento_Estagio,
          :old.ID_Recrutamento_Estagio);

-- insere valor do campo nb_Vagas_Recrutamento --
  pnb_Campo := F_AVS_Busca_Campo('NB_VAGAS_RECRUTAMENTO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Vagas_Recrutamento,
          :old.nb_Vagas_Recrutamento);

-- insere valor do campo nb_Candidato --
  pnb_Campo := F_AVS_Busca_Campo('NB_CANDIDATO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Candidato,
          :old.nb_Candidato);

-- insere valor do campo cs_Tipo_Vaga_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('CS_TIPO_VAGA_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Tipo_Vaga_Estagio,
          :old.cs_Tipo_Vaga_Estagio);

-- insere valor do campo cs_Periodo --
  pnb_Campo := F_AVS_Busca_Campo('CS_PERIODO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Periodo,
          :old.cs_Periodo);

-- insere valor do campo cs_Horario_Curso --
  pnb_Campo := F_AVS_Busca_Campo('CS_HORARIO_CURSO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Horario_Curso,
          :old.cs_Horario_Curso);

-- insere valor do campo ID_Agencia_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_AGENCIA_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Agencia_Estagio,
          :old.ID_Agencia_Estagio);

-- insere valor do campo tx_Email --
  pnb_Campo := F_AVS_Busca_Campo('TX_EMAIL',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Email,
          :old.tx_Email);

-- insere valor do campo tx_Codigo --
  pnb_Campo := F_AVS_Busca_Campo('TX_CODIGO',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Codigo,
          :old.tx_Codigo);

-- insere valor do campo cs_Selecao --
  pnb_Campo := F_AVS_Busca_Campo('CS_SELECAO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Selecao,
          :old.cs_Selecao);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_CONTRATO_ESTAGIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_CURSO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_CURSO_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Curso_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('CURSO_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Curso_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_CURSO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Curso_Estagio,
          :old.ID_Curso_Estagio);

-- insere valor do campo tx_Curso_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('TX_CURSO_ESTAGIO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Curso_Estagio,
          :old.tx_Curso_Estagio);

-- insere valor do campo cs_Area_Conhecimento --
  pnb_Campo := F_AVS_Busca_Campo('CS_AREA_CONHECIMENTO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Area_Conhecimento,
          :old.cs_Area_Conhecimento);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_CURSO_ESTAGIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_ITEM_PAG_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_ITEM_PAG_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Item_Pag_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('ITEM_PAG_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Pagamento_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_PAGAMENTO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Pagamento_Estagio,
          :old.ID_Pagamento_Estagio);

-- insere valor do campo ID_Item_Pagamento_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ITEM_PAGAMENTO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Item_Pagamento_Estagio,
          :old.ID_Item_Pagamento_Estagio);

-- insere valor do campo ID_Contrato --
  pnb_Campo := F_AVS_Busca_Campo('ID_CONTRATO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Contrato,
          :old.ID_Contrato);

-- insere valor do campo dt_Processamento --
  pnb_Campo := F_AVS_Busca_Campo('DT_PROCESSAMENTO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Processamento,
          :old.dt_Processamento);

-- insere valor do campo nb_Valor_Base --
  pnb_Campo := F_AVS_Busca_Campo('NB_VALOR_BASE',pID_Tabela,'NUMBER(12,2)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Valor_Base,
          :old.nb_Valor_Base);

-- insere valor do campo nb_Valor_Calculado --
  pnb_Campo := F_AVS_Busca_Campo('NB_VALOR_CALCULADO',pID_Tabela,'NUMBER(12,2)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Valor_Calculado,
          :old.nb_Valor_Calculado);

-- insere valor do campo nb_Valor_Unitario --
  pnb_Campo := F_AVS_Busca_Campo('NB_VALOR_UNITARIO',pID_Tabela,'NUMBER(12,2)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Valor_Unitario,
          :old.nb_Valor_Unitario);

-- insere valor do campo nb_Quantidade --
  pnb_Campo := F_AVS_Busca_Campo('NB_QUANTIDADE',pID_Tabela,'NUMBER(12,2)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Quantidade,
          :old.nb_Quantidade);

-- insere valor do campo ID_Usuario --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario,
          :old.ID_Usuario);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_ITEM_PAG_ESTAGIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_ORGAO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_ORGAO_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Orgao_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('ORGAO_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Orgao_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Estagio,
          :old.ID_Orgao_Estagio);

-- insere valor do campo tx_Orgao_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('TX_ORGAO_ESTAGIO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Orgao_Estagio,
          :old.tx_Orgao_Estagio);

-- insere valor do campo dt_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('DT_CADASTRO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Cadastro,
          :old.dt_Cadastro);

-- insere valor do campo dt_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_ATUALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Atualizacao,
          :old.dt_Atualizacao);

-- insere valor do campo ID_Unidade_Org --
  pnb_Campo := F_AVS_Busca_Campo('ID_UNIDADE_ORG',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Unidade_Org,
          :old.ID_Unidade_Org);

-- insere valor do campo ID_Usuario_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_CADASTRO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Cadastro,
          :old.ID_Usuario_Cadastro);

-- insere valor do campo ID_Usuario_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_ATUALIZACAO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Atualizacao,
          :old.ID_Usuario_Atualizacao);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_ORGAO_ESTAGIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_PAGAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_PAGAMENTO_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Pagamento_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('PAGAMENTO_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Pagamento_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_PAGAMENTO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Pagamento_Estagio,
          :old.ID_Pagamento_Estagio);

-- insere valor do campo dt_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('DT_CADASTRO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Cadastro,
          :old.dt_Cadastro);

-- insere valor do campo dt_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_ATUALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Atualizacao,
          :old.dt_Atualizacao);

-- insere valor do campo nb_Ano --
  pnb_Campo := F_AVS_Busca_Campo('NB_ANO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Ano,
          :old.nb_Ano);

-- insere valor do campo nb_Mes --
  pnb_Campo := F_AVS_Busca_Campo('NB_MES',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Mes,
          :old.nb_Mes);

-- insere valor do campo cs_Situacao --
  pnb_Campo := F_AVS_Busca_Campo('CS_SITUACAO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Situacao,
          :old.cs_Situacao);

-- insere valor do campo nb_Dias_Uteis --
  pnb_Campo := F_AVS_Busca_Campo('NB_DIAS_UTEIS',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Dias_Uteis,
          :old.nb_Dias_Uteis);

-- insere valor do campo ID_Orgao_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Estagio,
          :old.ID_Orgao_Estagio);

-- insere valor do campo ID_Orgao_Gestor_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_GESTOR_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Gestor_Estagio,
          :old.ID_Orgao_Gestor_Estagio);

-- insere valor do campo ID_Agencia_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_AGENCIA_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Agencia_Estagio,
          :old.ID_Agencia_Estagio);

-- insere valor do campo ID_Usuario_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_CADASTRO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Cadastro,
          :old.ID_Usuario_Cadastro);

-- insere valor do campo ID_Usuario_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_ATUALIZACAO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Atualizacao,
          :old.ID_Usuario_Atualizacao);

-- insere valor do campo cs_Tipo_Pag_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('CS_TIPO_PAG_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Tipo_Pag_Estagio,
          :old.cs_Tipo_Pag_Estagio);

-- insere valor do campo dt_Inicio_Competencia --
  pnb_Campo := F_AVS_Busca_Campo('DT_INICIO_COMPETENCIA',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Inicio_Competencia,
          :old.dt_Inicio_Competencia);

-- insere valor do campo dt_Fim_Competencia --
  pnb_Campo := F_AVS_Busca_Campo('DT_FIM_COMPETENCIA',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Fim_Competencia,
          :old.dt_Fim_Competencia);

-- insere valor do campo dt_Inicio_Frequencia --
  pnb_Campo := F_AVS_Busca_Campo('DT_INICIO_FREQUENCIA',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Inicio_Frequencia,
          :old.dt_Inicio_Frequencia);

-- insere valor do campo dt_Fim_Frequencia --
  pnb_Campo := F_AVS_Busca_Campo('DT_FIM_FREQUENCIA',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Fim_Frequencia,
          :old.dt_Fim_Frequencia);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_PAGAMENTO_ESTAGIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_QUADRO_VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_QUADRO_VAGAS_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Quadro_Vagas_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('QUADRO_VAGAS_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Quadro_Vagas_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_QUADRO_VAGAS_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Quadro_Vagas_Estagio,
          :old.ID_Quadro_Vagas_Estagio);

-- insere valor do campo ID_Agencia_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_AGENCIA_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Agencia_Estagio,
          :old.ID_Agencia_Estagio);

-- insere valor do campo ID_Orgao_Gestor_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_GESTOR_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Gestor_Estagio,
          :old.ID_Orgao_Gestor_Estagio);

-- insere valor do campo dt_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('DT_CADASTRO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Cadastro,
          :old.dt_Cadastro);

-- insere valor do campo dt_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_ATUALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Atualizacao,
          :old.dt_Atualizacao);

-- insere valor do campo ID_Usuario_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_CADASTRO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Cadastro,
          :old.ID_Usuario_Cadastro);

-- insere valor do campo ID_Usuario_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_ATUALIZACAO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Atualizacao,
          :old.ID_Usuario_Atualizacao);

-- insere valor do campo cs_Situacao --
  pnb_Campo := F_AVS_Busca_Campo('CS_SITUACAO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Situacao,
          :old.cs_Situacao);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_QUADRO_VAGAS_ESTAGIO" DISABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_RECESSO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_RECESSO_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on SEMAD.Recesso_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('RECESSO_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Recesso_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_RECESSO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Recesso_Estagio,
          :old.ID_Recesso_Estagio);

-- insere valor do campo tx_Codigo --
  pnb_Campo := F_AVS_Busca_Campo('TX_CODIGO',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Codigo,
          :old.tx_Codigo);

-- insere valor do campo tx_Cargo_Agente --
  pnb_Campo := F_AVS_Busca_Campo('TX_CARGO_AGENTE',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Cargo_Agente,
          :old.tx_Cargo_Agente);

-- insere valor do campo tx_Email_Agente --
  pnb_Campo := F_AVS_Busca_Campo('TX_EMAIL_AGENTE',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Email_Agente,
          :old.tx_Email_Agente);

-- insere valor do campo tx_Telefone_Agente --
  pnb_Campo := F_AVS_Busca_Campo('TX_TELEFONE_AGENTE',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Telefone_Agente,
          :old.tx_Telefone_Agente);

-- insere valor do campo dt_Inicio_Vig_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('DT_INICIO_VIG_ESTAGIO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Inicio_Vig_Estagio,
          :old.dt_Inicio_Vig_Estagio);

-- insere valor do campo tx_Justificativa_Adiamento --
  pnb_Campo := F_AVS_Busca_Campo('TX_JUSTIFICATIVA_ADIAMENTO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Justificativa_Adiamento,
          :old.tx_Justificativa_Adiamento);

-- insere valor do campo dt_Adiamento --
  pnb_Campo := F_AVS_Busca_Campo('DT_ADIAMENTO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Adiamento,
          :old.dt_Adiamento);

-- insere valor do campo ID_Contrato --
  pnb_Campo := F_AVS_Busca_Campo('ID_CONTRATO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Contrato,
          :old.ID_Contrato);

-- insere valor do campo ID_Setorial_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_SETORIAL_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Setorial_Estagio,
          :old.ID_Setorial_Estagio);

-- insere valor do campo ID_Agencia_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_AGENCIA_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Agencia_Estagio,
          :old.ID_Agencia_Estagio);

-- insere valor do campo ID_Usuario_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_CADASTRO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Cadastro,
          :old.ID_Usuario_Cadastro);

-- insere valor do campo ID_Orgao_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Estagio,
          :old.ID_Orgao_Estagio);

-- insere valor do campo ID_Usuario_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_ATUALIZACAO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Atualizacao,
          :old.ID_Usuario_Atualizacao);

-- insere valor do campo dt_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('DT_CADASTRO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Cadastro,
          :old.dt_Cadastro);

-- insere valor do campo dt_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_ATUALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Atualizacao,
          :old.dt_Atualizacao);

-- insere valor do campo cs_Situacao --
  pnb_Campo := F_AVS_Busca_Campo('CS_SITUACAO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Situacao,
          :old.cs_Situacao);

-- insere valor do campo dt_Fim_Vigencia_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('DT_FIM_VIGENCIA_ESTAGIO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Fim_Vigencia_Estagio,
          :old.dt_Fim_Vigencia_Estagio);

-- insere valor do campo dt_Inicio_Recesso --
  pnb_Campo := F_AVS_Busca_Campo('DT_INICIO_RECESSO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Inicio_Recesso,
          :old.dt_Inicio_Recesso);

-- insere valor do campo dt_Fim_Recesso --
  pnb_Campo := F_AVS_Busca_Campo('DT_FIM_RECESSO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Fim_Recesso,
          :old.dt_Fim_Recesso);

-- insere valor do campo nb_Mes_Referencia --
  pnb_Campo := F_AVS_Busca_Campo('NB_MES_REFERENCIA',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Mes_Referencia,
          :old.nb_Mes_Referencia);

-- insere valor do campo nb_Ano_Referencia --
  pnb_Campo := F_AVS_Busca_Campo('NB_ANO_REFERENCIA',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Ano_Referencia,
          :old.nb_Ano_Referencia);

-- insere valor do campo dt_Assinatura --
  pnb_Campo := F_AVS_Busca_Campo('DT_ASSINATURA',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Assinatura,
          :old.dt_Assinatura);

-- insere valor do campo tx_Matricula --
  pnb_Campo := F_AVS_Busca_Campo('TX_MATRICULA',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Matricula,
          :old.tx_Matricula);

-- insere valor do campo nb_Dias_Restantes --
  pnb_Campo := F_AVS_Busca_Campo('NB_DIAS_RESTANTES',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Dias_Restantes,
          :old.nb_Dias_Restantes);

-- insere valor do campo tx_Chefia_Imediata --
  pnb_Campo := F_AVS_Busca_Campo('TX_CHEFIA_IMEDIATA',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Chefia_Imediata,
          :old.tx_Chefia_Imediata);

-- insere valor do campo cs_Realizacao --
  pnb_Campo := F_AVS_Busca_Campo('CS_REALIZACAO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Realizacao,
          :old.cs_Realizacao);

-- insere valor do campo ID_Orgao_Gestor_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_GESTOR_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Gestor_Estagio,
          :old.ID_Orgao_Gestor_Estagio);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_RECESSO_ESTAGIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_RECRUTAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_RECRUTAMENTO_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Recrutamento_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('RECRUTAMENTO_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Recrutamento_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_RECRUTAMENTO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Recrutamento_Estagio,
          :old.ID_Recrutamento_Estagio);

-- insere valor do campo tx_Cod_Recrutamento --
  pnb_Campo := F_AVS_Busca_Campo('TX_COD_RECRUTAMENTO',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Cod_Recrutamento,
          :old.tx_Cod_Recrutamento);

-- insere valor do campo dt_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('DT_CADASTRO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Cadastro,
          :old.dt_Cadastro);

-- insere valor do campo dt_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_ATUALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Atualizacao,
          :old.dt_Atualizacao);

-- insere valor do campo tx_Doc_Autorizacao --
  pnb_Campo := F_AVS_Busca_Campo('TX_DOC_AUTORIZACAO',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Doc_Autorizacao,
          :old.tx_Doc_Autorizacao);

-- insere valor do campo tx_Motivo --
  pnb_Campo := F_AVS_Busca_Campo('TX_MOTIVO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Motivo,
          :old.tx_Motivo);

-- insere valor do campo ID_Quadro_Vagas_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_QUADRO_VAGAS_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Quadro_Vagas_Estagio,
          :old.ID_Quadro_Vagas_Estagio);

-- insere valor do campo ID_Orgao_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Estagio,
          :old.ID_Orgao_Estagio);

-- insere valor do campo ID_Usuario_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_CADASTRO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Cadastro,
          :old.ID_Usuario_Cadastro);

-- insere valor do campo ID_Usuario_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_ATUALIZACAO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Atualizacao,
          :old.ID_Usuario_Atualizacao);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_RECRUTAMENTO_ESTAGIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_SELECAO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_SELECAO_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Selecao_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('SELECAO_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Selecao_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_SELECAO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Selecao_Estagio,
          :old.ID_Selecao_Estagio);

-- insere valor do campo tx_Cod_Selecao --
  pnb_Campo := F_AVS_Busca_Campo('TX_COD_SELECAO',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Cod_Selecao,
          :old.tx_Cod_Selecao);

-- insere valor do campo dt_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_ATUALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Atualizacao,
          :old.dt_Atualizacao);

-- insere valor do campo dt_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('DT_CADASTRO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Cadastro,
          :old.dt_Cadastro);

-- insere valor do campo dt_Realizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_REALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Realizacao,
          :old.dt_Realizacao);

-- insere valor do campo dt_Agendamento --
  pnb_Campo := F_AVS_Busca_Campo('DT_AGENDAMENTO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Agendamento,
          :old.dt_Agendamento);

-- insere valor do campo ID_Usuario_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_CADASTRO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Cadastro,
          :old.ID_Usuario_Cadastro);

-- insere valor do campo ID_Usuario_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_ATUALIZACAO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Atualizacao,
          :old.ID_Usuario_Atualizacao);

-- insere valor do campo ID_Orgao_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Estagio,
          :old.ID_Orgao_Estagio);

-- insere valor do campo ID_Recrutamento_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_RECRUTAMENTO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Recrutamento_Estagio,
          :old.ID_Recrutamento_Estagio);

-- insere valor do campo ID_Orgao_Gestor_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_GESTOR_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Gestor_Estagio,
          :old.ID_Orgao_Gestor_Estagio);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_SELECAO_ESTAGIO" DISABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_SOLICITACAO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_SOLICITACAO_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Solicitacao_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('SEMAD.SOLICITACAO_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Solicitacao_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_SOLICITACAO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Solicitacao_Estagio,
          :old.ID_Solicitacao_Estagio);

-- insere valor do campo tx_Cod_Solicitacao --
  pnb_Campo := F_AVS_Busca_Campo('TX_COD_SOLICITACAO',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Cod_Solicitacao,
          :old.tx_Cod_Solicitacao);

-- insere valor do campo dt_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('DT_CADASTRO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Cadastro,
          :old.dt_Cadastro);

-- insere valor do campo dt_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_ATUALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Atualizacao,
          :old.dt_Atualizacao);

-- insere valor do campo tx_Justificativa --
  pnb_Campo := F_AVS_Busca_Campo('TX_JUSTIFICATIVA',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Justificativa,
          :old.tx_Justificativa);

-- insere valor do campo cs_Situacao --
  pnb_Campo := F_AVS_Busca_Campo('CS_SITUACAO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Situacao,
          :old.cs_Situacao);

-- insere valor do campo ID_Usuario_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_CADASTRO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Cadastro,
          :old.ID_Usuario_Cadastro);

-- insere valor do campo ID_Usuario_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_ATUALIZACAO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Atualizacao,
          :old.ID_Usuario_Atualizacao);

-- insere valor do campo ID_Orgao_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Estagio,
          :old.ID_Orgao_Estagio);

-- insere valor do campo ID_Orgao_Gestor_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_GESTOR_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Gestor_Estagio,
          :old.ID_Orgao_Gestor_Estagio);

-- insere valor do campo ID_Quadro_Vagas_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_QUADRO_VAGAS_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Quadro_Vagas_Estagio,
          :old.ID_Quadro_Vagas_Estagio);


end; -- T_PRM_B_I_Pessoa_Fisica

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_SOLICITACAO_ESTAGIO" DISABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_SUPERVISOR_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_SUPERVISOR_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Supervisor_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('SUPERVISOR_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Pessoa_Supervisor --
  pnb_Campo := F_AVS_Busca_Campo('ID_PESSOA_SUPERVISOR',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Pessoa_Supervisor,
          :old.ID_Pessoa_Supervisor);

-- insere valor do campo ID_Pessoa_Funcionario --
  pnb_Campo := F_AVS_Busca_Campo('ID_PESSOA_FUNCIONARIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Pessoa_Funcionario,
          :old.ID_Pessoa_Funcionario);

-- insere valor do campo nb_Funcionario --
  pnb_Campo := F_AVS_Busca_Campo('NB_FUNCIONARIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Funcionario,
          :old.nb_Funcionario);

-- insere valor do campo tx_Curriculo --
  pnb_Campo := F_AVS_Busca_Campo('TX_CURRICULO',pID_Tabela,'VARCHAR2(2000)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Curriculo,
          :old.tx_Curriculo);

-- insere valor do campo ID_Conselho --
  pnb_Campo := F_AVS_Busca_Campo('ID_CONSELHO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Conselho,
          :old.ID_Conselho);

-- insere valor do campo nb_Inscricao_Conselho --
  pnb_Campo := F_AVS_Busca_Campo('NB_INSCRICAO_CONSELHO',pID_Tabela,'VARCHAR2(80)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Inscricao_Conselho,
          :old.nb_Inscricao_Conselho);

-- insere valor do campo tx_Formacao --
  pnb_Campo := F_AVS_Busca_Campo('TX_FORMACAO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Formacao,
          :old.tx_Formacao);

-- insere valor do campo tx_Cargo --
  pnb_Campo := F_AVS_Busca_Campo('TX_CARGO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Cargo,
          :old.tx_Cargo);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_SUPERVISOR_ESTAGIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_TIPO_PAG_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_TIPO_PAG_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Tipo_Pag_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('TIPO_PAG_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo cs_Tipo_Pag_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('CS_TIPO_PAG_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Tipo_Pag_Estagio,
          :old.cs_Tipo_Pag_Estagio);

-- insere valor do campo tx_Tipo_Pag_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('TX_TIPO_PAG_ESTAGIO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Tipo_Pag_Estagio,
          :old.tx_Tipo_Pag_Estagio);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_TIPO_PAG_ESTAGIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_TIPO_VAGA_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_TIPO_VAGA_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Tipo_Vaga_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('TIPO_VAGA_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo cs_Tipo_Vaga_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('CS_TIPO_VAGA_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Tipo_Vaga_Estagio,
          :old.cs_Tipo_Vaga_Estagio);

-- insere valor do campo tx_Tipo_Vaga_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('TX_TIPO_VAGA_ESTAGIO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Tipo_Vaga_Estagio,
          :old.tx_Tipo_Vaga_Estagio);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_TIPO_VAGA_ESTAGIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_VAGAS_ESTAGIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Vagas_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('VAGAS_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Quadro_Vagas_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_QUADRO_VAGAS_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Quadro_Vagas_Estagio,
          :old.ID_Quadro_Vagas_Estagio);

-- insere valor do campo ID_Orgao_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ORGAO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Orgao_Estagio,
          :old.ID_Orgao_Estagio);

-- insere valor do campo cs_Tipo_Vaga_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('CS_TIPO_VAGA_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Tipo_Vaga_Estagio,
          :old.cs_Tipo_Vaga_Estagio);

-- insere valor do campo nb_Quantidade --
  pnb_Campo := F_AVS_Busca_Campo('NB_QUANTIDADE',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Quantidade,
          :old.nb_Quantidade);

-- insere valor do campo dt_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('DT_CADASTRO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Cadastro,
          :old.dt_Cadastro);

-- insere valor do campo dt_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_ATUALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Atualizacao,
          :old.dt_Atualizacao);

-- insere valor do campo ID_Usuario_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_CADASTRO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Cadastro,
          :old.ID_Usuario_Cadastro);

-- insere valor do campo ID_Usuario_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_ATUALIZACAO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Atualizacao,
          :old.ID_Usuario_Atualizacao);

-- insere valor do campo ID_Curso_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_CURSO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Curso_Estagio,
          :old.ID_Curso_Estagio);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_VAGAS_ESTAGIO" DISABLE;
--------------------------------------------------------
--  DDL for Trigger T_EST_U_SELECAO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_EST_U_SELECAO_ESTAGIO" 
  after
  UPDATE 
  on SEMAD.SELECAO_ESTAGIO
  referencing new as new old as old
   FOR EACH ROW
begin
  
  if :new.CS_SITUACAO = 2 then
    begin
      for CURSOR1 in (select ID_RECRUTAMENTO_ESTAGIO, NB_VAGAS_RECRUTAMENTO, NB_CANDIDATO, CS_SITUACAO, TX_MOTIVO_SITUACAO 
                        from ESTAGIARIO_SELECAO where ID_SELECAO_ESTAGIO = :new.ID_SELECAO_ESTAGIO) LOOP
                        
                          update ESTAGIARIO_VAGA set
                                  CS_SITUACAO = CURSOR1.CS_SITUACAO,
                                  TX_MOTIVO_SITUACAO = CURSOR1.TX_MOTIVO_SITUACAO
                          where ID_RECRUTAMENTO_ESTAGIO =  CURSOR1.ID_RECRUTAMENTO_ESTAGIO
                          and NB_VAGAS_RECRUTAMENTO = CURSOR1.NB_VAGAS_RECRUTAMENTO
                          and NB_CANDIDATO = CURSOR1.NB_CANDIDATO;
                        
                        end LOOP;
    end;
  else
    update ESTAGIARIO_VAGA set
                                  CS_SITUACAO = 1,
                                  TX_MOTIVO_SITUACAO = ''
                          where ID_RECRUTAMENTO_ESTAGIO =  :new.ID_RECRUTAMENTO_ESTAGIO;
  end if;
   
end; --
/
ALTER TRIGGER "SEMAD"."T_EST_U_SELECAO_ESTAGIO" DISABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_ESTAGIARIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_ESTAGIARIO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Estagiario
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('ESTAGIARIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Pessoa_Estagiario --
  pnb_Campo := F_AVS_Busca_Campo('ID_PESSOA_ESTAGIARIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Pessoa_Estagiario,
          :old.ID_Pessoa_Estagiario);

-- insere valor do campo ID_Pessoa_Funcionario --
  pnb_Campo := F_AVS_Busca_Campo('ID_PESSOA_FUNCIONARIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Pessoa_Funcionario,
          :old.ID_Pessoa_Funcionario);

-- insere valor do campo nb_Funcionario --
  pnb_Campo := F_AVS_Busca_Campo('NB_FUNCIONARIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Funcionario,
          :old.nb_Funcionario);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_ESTAGIARIO" DISABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_ESTAGIARIO_SELECAO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_ESTAGIARIO_SELECAO" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on SEMAD.Estagiario_Selecao
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('ESTAGIARIO_SELECAO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Selecao_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_SELECAO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Selecao_Estagio,
          :old.ID_Selecao_Estagio);

-- insere valor do campo ID_Recrutamento_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_RECRUTAMENTO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Recrutamento_Estagio,
          :old.ID_Recrutamento_Estagio);

-- insere valor do campo nb_Vagas_Recrutamento --
  pnb_Campo := F_AVS_Busca_Campo('NB_VAGAS_RECRUTAMENTO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Vagas_Recrutamento,
          :old.nb_Vagas_Recrutamento);

-- insere valor do campo nb_Candidato --
  pnb_Campo := F_AVS_Busca_Campo('NB_CANDIDATO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Candidato,
          :old.nb_Candidato);

-- insere valor do campo ID_Usuario_Selecionador --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO_SELECIONADOR',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario_Selecionador,
          :old.ID_Usuario_Selecionador);

-- insere valor do campo cs_Situacao --
  pnb_Campo := F_AVS_Busca_Campo('CS_SITUACAO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Situacao,
          :old.cs_Situacao);

-- insere valor do campo tx_Motivo_Situacao --
  pnb_Campo := F_AVS_Busca_Campo('TX_MOTIVO_SITUACAO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Motivo_Situacao,
          :old.tx_Motivo_Situacao);

-- insere valor do campo ID_Usuario --
  pnb_Campo := F_AVS_Busca_Campo('ID_USUARIO',pID_Tabela,'NUMBER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Usuario,
          :old.ID_Usuario);

-- insere valor do campo dt_Agendamento --
  pnb_Campo := F_AVS_Busca_Campo('DT_AGENDAMENTO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Agendamento,
          :old.dt_Agendamento);

-- insere valor do campo dt_Realizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_REALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Realizacao,
          :old.dt_Realizacao);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_ESTAGIARIO_SELECAO" DISABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_ESTAGIARIO_VAGA
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_ESTAGIARIO_VAGA" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on SEMAD.Estagiario_Vaga
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('ESTAGIARIO_VAGA');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Recrutamento_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_RECRUTAMENTO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Recrutamento_Estagio,
          :old.ID_Recrutamento_Estagio);

-- insere valor do campo nb_Vagas_Recrutamento --
  pnb_Campo := F_AVS_Busca_Campo('NB_VAGAS_RECRUTAMENTO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Vagas_Recrutamento,
          :old.nb_Vagas_Recrutamento);

-- insere valor do campo nb_Candidato --
  pnb_Campo := F_AVS_Busca_Campo('NB_CANDIDATO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.nb_Candidato,
          :old.nb_Candidato);

-- insere valor do campo cs_Situacao --
  pnb_Campo := F_AVS_Busca_Campo('CS_SITUACAO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Situacao,
          :old.cs_Situacao);

-- insere valor do campo tx_Motivo_Situacao --
  pnb_Campo := F_AVS_Busca_Campo('TX_MOTIVO_SITUACAO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Motivo_Situacao,
          :old.tx_Motivo_Situacao);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_ESTAGIARIO_VAGA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_GEST_I_D_V_ESTAGIARIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_GEST_I_D_V_ESTAGIARIO" 
  INSTEAD OF
  DELETE
    ON SEMAD.V_ESTAGIARIO REFERENCING OLD AS OLD NEW AS NEW DECLARE
    Pid_pessoa_estagiario estagiario.id_pessoa_estagiario%type;
  BEGIN
    Pid_pessoa_estagiario := :OLD.id_pessoa_estagiario;
    -- DELETE Estagiario
    DELETE
    FROM
      Estagiario
    WHERE
      id_pessoa_estagiario = Pid_pessoa_estagiario;
    -- DELETE TABLE Pessoa_Fisica
    --  DELETE FROM Pessoa_Fisica
    --  WHERE id_pessoa = Pid_pessoa_estagiario;
    -- DELETE TABLE Pessoa
    --  DELETE FROM Pessoa
    --  WHERE id_pessoa = Pid_pessoa_estagiario;
  END;
/
ALTER TRIGGER "SEMAD"."T_GEST_I_D_V_ESTAGIARIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_GEST_I_I_V_ESTAGIARIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_GEST_I_I_V_ESTAGIARIO" INSTEAD OF
  INSERT
    ON SEMAD.V_ESTAGIARIO REFERENCING OLD AS OLD NEW AS NEW DECLARE BEGIN
  -- INSERT TABLE Pessoa
  INSERT
  INTO
    Pessoa
    (
      ID_Pessoa,
      tx_Nome,
      cs_Tipo_Pessoa
    )
    VALUES
    (
      :new.ID_PESSOA_ESTAGIARIO,
      :new.tx_Nome,
      :new.cs_Tipo_Pessoa
    );
  -- INSERT TABLE Pessoa_Fisica
  INSERT
  INTO
    Pessoa_Fisica
    (
      ID_Pessoa,
      nb_cpf,
      nb_rg,
      cs_sexo,
      dt_atualizacao,
      dt_nascimento
    )
    VALUES
    (
      :new.ID_PESSOA_ESTAGIARIO,
      :new.nb_cpf,
      :new.nb_rg,
      :new.cs_sexo,
      sysdate,
      :new.dt_nascimento
    );
  -- INSERT TABLE Estagiario
  INSERT
  INTO
    Estagiario
    (
      ID_PESSOA_ESTAGIARIO,
      ID_PESSOA_FUNCIONARIO,
      NB_FUNCIONARIO,
      TX_CEP,
      TX_ENDERECO,
      NB_NUMERO,
      TX_COMPLEMENTO,
      TX_BAIRRO,
      TX_AGENCIA,
      TX_CONTA_CORRENTE,
      TX_CONTATO,
      TX_EMAIL
    )
    VALUES
    (
      :new.ID_PESSOA_ESTAGIARIO,
      :NEW.ID_PESSOA_FUNCIONARIO,
      :NEW.NB_FUNCIONARIO,
      :NEW.TX_CEP,
      :NEW.TX_ENDERECO,
      :NEW.NB_NUMERO,
      :NEW.TX_COMPLEMENTO,
      :NEW.TX_BAIRRO,
      :NEW.TX_AGENCIA,
      :NEW.TX_CONTA_CORRENTE,
      :NEW.TX_CONTATO,
      :NEW.TX_EMAIL
    );
END;
/
ALTER TRIGGER "SEMAD"."T_GEST_I_I_V_ESTAGIARIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_GEST_I_U_V_ESTAGIARIO
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_GEST_I_U_V_ESTAGIARIO" 
  INSTEAD OF
  UPDATE
    ON SEMAD.V_ESTAGIARIO REFERENCING OLD AS OLD NEW AS NEW DECLARE
    Pid_pessoa_estagiario estagiario.id_pessoa_estagiario%type;
  BEGIN
    Pid_pessoa_estagiario := :OLD.id_pessoa_estagiario;
    -- UPDATE TABLE Pessoa
    UPDATE
      Pessoa
    SET
      tx_Nome = :NEW.tx_Nome
    WHERE
      ID_Pessoa = Pid_pessoa_estagiario;
    -- UPDATE TABLE Pessoa_Fisica
    UPDATE
      Pessoa_Fisica
    SET
      nb_cpf              = :NEW.nb_cpf,
      nb_rg               = :NEW.nb_rg,
      cs_sexo             = :NEW.cs_sexo,
      dt_atualizacao      = :NEW.dt_atualizacao,
      dt_nascimento       = :NEW.dt_nascimento
    WHERE
      ID_Pessoa = Pid_pessoa_estagiario;
    -- UPDATE TABLE Estagiario
    UPDATE
      Estagiario
    SET
      ID_PESSOA_FUNCIONARIO = :NEW.ID_PESSOA_FUNCIONARIO,
      NB_FUNCIONARIO        = :NEW.NB_FUNCIONARIO,
      TX_CEP                = :NEW.TX_CEP,
      TX_ENDERECO           = :NEW.TX_ENDERECO,
      NB_NUMERO             = :NEW.NB_NUMERO,
      TX_COMPLEMENTO        = :NEW.TX_COMPLEMENTO,
      TX_BAIRRO             = :NEW.TX_BAIRRO,
      TX_AGENCIA            = :NEW.TX_AGENCIA,
      TX_CONTA_CORRENTE     = :NEW.TX_CONTA_CORRENTE,
      TX_CONTATO            = :NEW.TX_CONTATO,
      TX_EMAIL              = :NEW.TX_EMAIL
    WHERE
      ID_PESSOA_ESTAGIARIO = PID_PESSOA_ESTAGIARIO;
  END;
/
ALTER TRIGGER "SEMAD"."T_GEST_I_U_V_ESTAGIARIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_AVS_IUD_ITEM_PAG_EST
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEMAD"."T_AVS_IUD_ITEM_PAG_EST" 
  AFTER
  INSERT OR DELETE OR UPDATE
  on semad.Item_Pagamento_Estagio
  REFERENCING NEW AS NEW OLD AS OLD
 FOR EACH ROW

declare
  pnb_Valor_Historico number;
  pID_Tabela number;
  pnb_Campo number;
  pnb_Transacao number;
  pID_Usuario number;
  pcs_evento number;
begin
  select id_usuario into pid_usuario
  from usuario
  where tx_login = user;
  if inserting then
     pcs_evento := 1;
  else
     if updating then
        pcs_evento := 2;
     else
        pcs_evento := 3;
     end if;
  end if;
  pID_Tabela := F_AVS_Busca_Tabela('ITEM_PAGAMENTO_ESTAGIO');
  pnb_Transacao := F_AVS_Cadastra_Transacao(pID_Tabela,pID_usuario,pcs_evento );
  -- insere valor do campo ID_Item_Pagamento_Estagio --
  pnb_Campo := F_AVS_Busca_Campo('ID_ITEM_PAGAMENTO_ESTAGIO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.ID_Item_Pagamento_Estagio,
          :old.ID_Item_Pagamento_Estagio);

-- insere valor do campo tx_Codigo --
  pnb_Campo := F_AVS_Busca_Campo('TX_CODIGO',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Codigo,
          :old.tx_Codigo);

-- insere valor do campo tx_Descricao --
  pnb_Campo := F_AVS_Busca_Campo('TX_DESCRICAO',pID_Tabela,'VARCHAR2(255)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Descricao,
          :old.tx_Descricao);

-- insere valor do campo tx_Sigla --
  pnb_Campo := F_AVS_Busca_Campo('TX_SIGLA',pID_Tabela,'VARCHAR2(20)');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.tx_Sigla,
          :old.tx_Sigla);

-- insere valor do campo dt_Cadastro --
  pnb_Campo := F_AVS_Busca_Campo('DT_CADASTRO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Cadastro,
          :old.dt_Cadastro);

-- insere valor do campo dt_Atualizacao --
  pnb_Campo := F_AVS_Busca_Campo('DT_ATUALIZACAO',pID_Tabela,'DATE');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.dt_Atualizacao,
          :old.dt_Atualizacao);

-- insere valor do campo cs_Tipo --
  pnb_Campo := F_AVS_Busca_Campo('CS_TIPO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Tipo,
          :old.cs_Tipo);

-- insere valor do campo cs_Situacao --
  pnb_Campo := F_AVS_Busca_Campo('CS_SITUACAO',pID_Tabela,'INTEGER');
  pnb_Valor_Historico := F_G_PK_Valor_Historico(pID_Tabela,pnb_Transacao,pnb_Campo,pID_usuario);
  insert into semad.Valor_Historico
         (nb_Valor_Historico,
          ID_Tabela,
          nb_Transacao_Historico,
          nb_Campo,
          ID_Usuario,
          nb_Valor_Varchar2000,
          nb_Old_Varchar2000)
  Values (pnb_Valor_Historico,
          pID_Tabela,
          pnb_Transacao,
          pnb_Campo,
          pID_Usuario,
          :new.cs_Situacao,
          :old.cs_Situacao);


end; --

/
ALTER TRIGGER "SEMAD"."T_AVS_IUD_ITEM_PAG_EST" ENABLE;
--------------------------------------------------------
--  DDL for Function F_G_PK_ORGAO_GESTOR_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_ORGAO_GESTOR_ESTAGIO" RETURN NUMBER IS
V_S_Orgao_Gestor_Estagio NUMBER;
BEGIN
SELECT S_Orgao_Gestor_Estagio.NEXTVAL
INTO V_S_Orgao_Gestor_Estagio
FROM SYS.DUAL;
RETURN V_S_Orgao_Gestor_Estagio;
END;

/
--------------------------------------------------------
--  DDL for Function F_G_COD_CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_COD_CONTRATO_ESTAGIO" 
RETURN CONTRATO_ESTAGIO.TX_CODIGO%TYPE IS

PNB_CODIGO CONTRATO_ESTAGIO.TX_CODIGO%TYPE;
V_N_NB_DOCUMENTO NUMBER;
PANO VARCHAR(4);
PNB_EXERCICIO VARCHAR(4);

BEGIN

  SELECT TO_CHAR(SYSDATE, 'YYYY') INTO PNB_EXERCICIO
  FROM DUAL;

  SELECT MAX(SUBSTR(TX_CODIGO,1,5)), TO_CHAR(SYSDATE, 'YYYY') INTO PNB_CODIGO, PANO
  FROM CONTRATO_ESTAGIO
  WHERE SUBSTR(TX_CODIGO,7,4) = PNB_EXERCICIO;
  IF (PNB_CODIGO IS NULL) THEN
     V_N_NB_DOCUMENTO := 1;
  ELSE
     V_N_NB_DOCUMENTO := TO_NUMBER(PNB_CODIGO) + 1;
  END IF;
  PNB_CODIGO:= LPAD(V_N_NB_DOCUMENTO,5,'0')||'/'||PANO;
  RETURN PNB_CODIGO;

end;

/
--------------------------------------------------------
--  DDL for Function F_G_COD_QUADRO_VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_COD_QUADRO_VAGAS_ESTAGIO" 
RETURN QUADRO_VAGAS_ESTAGIO.TX_CODIGO%TYPE IS 

PNB_CODIGO QUADRO_VAGAS_ESTAGIO.TX_CODIGO%TYPE;
V_N_NB_DOCUMENTO NUMBER;
PANO VARCHAR(4);
PNB_EXERCICIO VARCHAR(4);

BEGIN

  SELECT TO_CHAR(SYSDATE, 'YYYY') INTO PNB_EXERCICIO
  FROM DUAL;
  
  SELECT MAX(SUBSTR(TX_CODIGO,1,5)), TO_CHAR(SYSDATE, 'YYYY') INTO PNB_CODIGO, PANO
  FROM QUADRO_VAGAS_ESTAGIO
  WHERE SUBSTR(TX_CODIGO,7,4) = PNB_EXERCICIO;
  IF (PNB_CODIGO IS NULL) THEN
     V_N_NB_DOCUMENTO := 1;
  ELSE
     V_N_NB_DOCUMENTO := TO_NUMBER(PNB_CODIGO) + 1;
  END IF;
  PNB_CODIGO:= LPAD(V_N_NB_DOCUMENTO,5,'0')||'/'||PANO;
  RETURN PNB_CODIGO;
  
END;

/
--------------------------------------------------------
--  DDL for Function F_G_COD_RECESSO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_COD_RECESSO_ESTAGIO" 
RETURN RECESSO_ESTAGIO.TX_CODIGO%TYPE IS

PNB_CODIGO RECESSO_ESTAGIO.TX_CODIGO%TYPE;
V_N_NB_DOCUMENTO NUMBER;
PANO VARCHAR(4);
PNB_EXERCICIO VARCHAR(4);

BEGIN

  SELECT TO_CHAR(SYSDATE, 'YYYY') INTO PNB_EXERCICIO
  FROM DUAL;

  SELECT MAX(SUBSTR(TX_CODIGO,1,5)), TO_CHAR(SYSDATE, 'YYYY') INTO PNB_CODIGO, PANO
  FROM RECESSO_ESTAGIO
  WHERE SUBSTR(TX_CODIGO,7,4) = PNB_EXERCICIO;
  IF (PNB_CODIGO IS NULL) THEN
     V_N_NB_DOCUMENTO := 1;
  ELSE
     V_N_NB_DOCUMENTO := TO_NUMBER(PNB_CODIGO) + 1;
  END IF;
  PNB_CODIGO:= LPAD(V_N_NB_DOCUMENTO,5,'0')||'/'||PANO;
  RETURN PNB_CODIGO;

end;

/
--------------------------------------------------------
--  DDL for Function F_G_COD_RECRUTAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_COD_RECRUTAMENTO_ESTAGIO" 
RETURN RECRUTAMENTO_ESTAGIO.TX_COD_RECRUTAMENTO%TYPE IS 

PNB_CODIGO RECRUTAMENTO_ESTAGIO.TX_COD_RECRUTAMENTO%TYPE;
V_N_NB_DOCUMENTO NUMBER;
PANO VARCHAR(4);
PNB_EXERCICIO VARCHAR(4);

BEGIN

  SELECT TO_CHAR(SYSDATE, 'YYYY') INTO PNB_EXERCICIO
  FROM DUAL;
  
  SELECT MAX(SUBSTR(TX_COD_RECRUTAMENTO,1,5)), TO_CHAR(SYSDATE, 'YYYY') INTO PNB_CODIGO, PANO
  FROM RECRUTAMENTO_ESTAGIO
  WHERE SUBSTR(TX_COD_RECRUTAMENTO,7,4) = PNB_EXERCICIO;
  IF (PNB_CODIGO IS NULL) THEN
     V_N_NB_DOCUMENTO := 1;
  ELSE
     V_N_NB_DOCUMENTO := TO_NUMBER(PNB_CODIGO) + 1;
  END IF;
  PNB_CODIGO:= LPAD(V_N_NB_DOCUMENTO,5,'0')||'/'||PANO;
  RETURN PNB_CODIGO;
  
END;

/
--------------------------------------------------------
--  DDL for Function F_G_COD_SELECAO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_COD_SELECAO_ESTAGIO" 
RETURN SELECAO_ESTAGIO.TX_COD_SELECAO%TYPE IS

PNB_CODIGO SELECAO_ESTAGIO.TX_COD_SELECAO%TYPE;
V_N_NB_DOCUMENTO NUMBER;
PANO VARCHAR(4);
PNB_EXERCICIO VARCHAR(4);

BEGIN

  SELECT TO_CHAR(SYSDATE, 'YYYY') INTO PNB_EXERCICIO
  FROM DUAL;

  SELECT MAX(SUBSTR(TX_COD_SELECAO,1,5)), TO_CHAR(SYSDATE, 'YYYY') INTO PNB_CODIGO, PANO
  FROM SELECAO_ESTAGIO
  WHERE SUBSTR(TX_COD_SELECAO,7,4) = PNB_EXERCICIO;
  IF (PNB_CODIGO IS NULL) THEN
     V_N_NB_DOCUMENTO := 1;
  ELSE
     V_N_NB_DOCUMENTO := TO_NUMBER(PNB_CODIGO) + 1;
  END IF;
  PNB_CODIGO:= LPAD(V_N_NB_DOCUMENTO,5,'0')||'/'||PANO;
  RETURN PNB_CODIGO;

END;

/
--------------------------------------------------------
--  DDL for Function F_G_COD_SOLICITACAO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_COD_SOLICITACAO_ESTAGIO" 
RETURN SOLICITACAO_ESTAGIO.TX_COD_SOLICITACAO%TYPE IS

PNB_CODIGO SOLICITACAO_ESTAGIO.TX_COD_SOLICITACAO%TYPE;
V_N_NB_DOCUMENTO NUMBER;
PANO VARCHAR(4);
PNB_EXERCICIO VARCHAR(4);

BEGIN

  SELECT TO_CHAR(SYSDATE, 'YYYY') INTO PNB_EXERCICIO
  FROM DUAL;

  SELECT MAX(SUBSTR(TX_COD_SOLICITACAO,1,5)), TO_CHAR(SYSDATE, 'YYYY') INTO PNB_CODIGO, PANO
  FROM SOLICITACAO_ESTAGIO
  WHERE SUBSTR(TX_COD_SOLICITACAO,7,4) = PNB_EXERCICIO;
  IF (PNB_CODIGO IS NULL) THEN
     V_N_NB_DOCUMENTO := 1;
  ELSE
     V_N_NB_DOCUMENTO := TO_NUMBER(PNB_CODIGO) + 1;
  END IF;
  PNB_CODIGO:= LPAD(V_N_NB_DOCUMENTO,5,'0')||'/'||PANO;
  RETURN PNB_CODIGO;

end;

/
--------------------------------------------------------
--  DDL for Function F_G_COD_TRANSFERENCIA_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_COD_TRANSFERENCIA_ESTAGIO" 
RETURN TRANSFERENCIA_VAGAS.TX_COD_TRANSFERENCIA%TYPE IS

PNB_CODIGO TRANSFERENCIA_VAGAS.TX_COD_TRANSFERENCIA%TYPE;
V_N_NB_DOCUMENTO NUMBER;
PANO VARCHAR(4);
PNB_EXERCICIO VARCHAR(4);

BEGIN

  SELECT TO_CHAR(SYSDATE, 'YYYY') INTO PNB_EXERCICIO
  FROM DUAL;

  SELECT MAX(SUBSTR(TX_COD_TRANSFERENCIA,1,5)), TO_CHAR(SYSDATE, 'YYYY') INTO PNB_CODIGO, PANO
  FROM TRANSFERENCIA_VAGAS
  WHERE SUBSTR(TX_COD_TRANSFERENCIA,7,4) = PNB_EXERCICIO;
  IF (PNB_CODIGO IS NULL) THEN
     V_N_NB_DOCUMENTO := 1;
  ELSE
     V_N_NB_DOCUMENTO := TO_NUMBER(PNB_CODIGO) + 1;
  END IF;
  PNB_CODIGO:= LPAD(V_N_NB_DOCUMENTO,5,'0')||'/'||PANO;
  RETURN PNB_CODIGO;

end;

/
--------------------------------------------------------
--  DDL for Function F_G_PK_AGENCIA_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_AGENCIA_ESTAGIO" RETURN NUMBER IS
V_S_Agencia_Estagio NUMBER;
BEGIN
SELECT S_Agencia_Estagio.NEXTVAL
INTO V_S_Agencia_Estagio
FROM SYS.DUAL;
RETURN V_S_Agencia_Estagio;
END;

/
--------------------------------------------------------
--  DDL for Function F_G_PK_AGENTE_SETORIAL_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_AGENTE_SETORIAL_ESTAGIO" RETURN NUMBER IS
V_S_Agente_Setorial_Estagio NUMBER;
BEGIN
SELECT S_Agente_Setorial_Estagio.NEXTVAL
INTO V_S_Agente_Setorial_Estagio
FROM SYS.DUAL;
RETURN V_S_Agente_Setorial_Estagio;
END;

/
--------------------------------------------------------
--  DDL for Function F_G_PK_BOLSA_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_BOLSA_ESTAGIO" RETURN NUMBER IS
V_S_Bolsa_Estagio NUMBER;
BEGIN
SELECT S_Bolsa_Estagio.NEXTVAL
INTO V_S_Bolsa_Estagio
FROM SYS.DUAL;
RETURN V_S_Bolsa_Estagio;
END;

/
--------------------------------------------------------
--  DDL for Function F_G_PK_CONTRATO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_CONTRATO_ESTAGIO" RETURN NUMBER IS
V_S_Contrato_Estagio NUMBER;
BEGIN
SELECT S_Contrato_Estagio.NEXTVAL
INTO V_S_Contrato_Estagio
FROM SYS.DUAL;
RETURN V_S_Contrato_Estagio;
END;

/
--------------------------------------------------------
--  DDL for Function F_G_PK_CURSO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_CURSO_ESTAGIO" RETURN NUMBER IS
V_S_Curso_Estagio NUMBER;
BEGIN
SELECT S_Curso_Estagio.NEXTVAL
INTO V_S_Curso_Estagio
FROM SYS.DUAL;
RETURN V_S_Curso_Estagio;
END;

/
--------------------------------------------------------
--  DDL for Function F_G_PK_ITEM_PAGAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_ITEM_PAGAMENTO_ESTAGIO" RETURN NUMBER IS
V_S_Item_Pagamento_Estagio NUMBER;
BEGIN
SELECT S_Item_Pagamento_Estagio.NEXTVAL
INTO V_S_Item_Pagamento_Estagio
FROM SYS.DUAL;
RETURN V_S_Item_Pagamento_Estagio;
END;

/
--------------------------------------------------------
--  DDL for Function F_G_PK_ORGAO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_ORGAO_ESTAGIO" RETURN NUMBER IS
V_S_Orgao_Estagio NUMBER;
BEGIN
SELECT S_Orgao_Estagio.NEXTVAL
INTO V_S_Orgao_Estagio
FROM SYS.DUAL;
RETURN V_S_Orgao_Estagio;
END;

/
--------------------------------------------------------
--  DDL for Function F_G_PK_PAGAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_PAGAMENTO_ESTAGIO" RETURN NUMBER IS
V_S_Pagamento_Estagio NUMBER;
BEGIN
SELECT S_Pagamento_Estagio.NEXTVAL
INTO V_S_Pagamento_Estagio
FROM SYS.DUAL;
RETURN V_S_Pagamento_Estagio;
END;

/
--------------------------------------------------------
--  DDL for Function F_G_PK_QUADRO_VAGAS_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_QUADRO_VAGAS_ESTAGIO" RETURN NUMBER IS
V_S_Quadro_Vagas_Estagio NUMBER;
BEGIN
SELECT S_Quadro_Vagas_Estagio.NEXTVAL
INTO V_S_Quadro_Vagas_Estagio
FROM SYS.DUAL;
RETURN V_S_Quadro_Vagas_Estagio;
END;

/
--------------------------------------------------------
--  DDL for Function F_G_PK_RECESSO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_RECESSO_ESTAGIO" RETURN NUMBER IS
  V_S_Recesso_Estagio NUMBER;
BEGIN
  SELECT S_Recesso_Estagio.NEXTVAL  INTO V_S_Recesso_Estagio  FROM SYS.DUAL;
  RETURN V_S_Recesso_Estagio;
END; -- F_G_PK_Recesso_Estagio

/
--------------------------------------------------------
--  DDL for Function F_G_PK_RECRUTAMENTO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_RECRUTAMENTO_ESTAGIO" RETURN NUMBER IS
V_S_Recrutamento_Estagio NUMBER;
BEGIN
SELECT S_Recrutamento_Estagio.NEXTVAL
INTO V_S_Recrutamento_Estagio
FROM SYS.DUAL;
RETURN V_S_Recrutamento_Estagio;
END;

/
--------------------------------------------------------
--  DDL for Function F_G_PK_SELECAO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_SELECAO_ESTAGIO" RETURN NUMBER IS
V_S_Selecao_Estagio NUMBER;
BEGIN
SELECT S_Selecao_Estagio.NEXTVAL
INTO V_S_Selecao_Estagio
FROM SYS.DUAL;
RETURN V_S_Selecao_Estagio;
END;

/
--------------------------------------------------------
--  DDL for Function F_G_PK_SOLICITACAO_ESTAGIO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_SOLICITACAO_ESTAGIO" RETURN NUMBER IS
V_S_Solicitacao_Estagio NUMBER;
BEGIN
SELECT S_Solicitacao_Estagio.NEXTVAL
INTO V_S_Solicitacao_Estagio
FROM SYS.DUAL;
RETURN V_S_Solicitacao_Estagio;
END;

/
--------------------------------------------------------
--  DDL for Function F_G_PK_ESTAGIARIO_VAGA
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_ESTAGIARIO_VAGA" 
(PID_RECRUTAMENTO_ESTAGIO INTEGER,PNB_VAGAS_RECRUTAMENTO INTEGER)
RETURN NUMBER IS V_N_ESTAGIARIO_VAGA NUMBER;
BEGIN
   SELECT COUNT (*) INTO  V_N_ESTAGIARIO_VAGA
   FROM ESTAGIARIO_VAGA
   WHERE(ID_RECRUTAMENTO_ESTAGIO = PID_RECRUTAMENTO_ESTAGIO AND NB_VAGAS_RECRUTAMENTO = PNB_VAGAS_RECRUTAMENTO );
    IF V_N_ESTAGIARIO_VAGA = 0 THEN
        V_N_ESTAGIARIO_VAGA := 1;
    ELSE
        SELECT MAX(NB_CANDIDATO) + 1
        INTO V_N_ESTAGIARIO_VAGA
        FROM ESTAGIARIO_VAGA
        WHERE (ID_RECRUTAMENTO_ESTAGIO = PID_RECRUTAMENTO_ESTAGIO AND NB_VAGAS_RECRUTAMENTO = PNB_VAGAS_RECRUTAMENTO );
     END IF;
     RETURN V_N_ESTAGIARIO_VAGA;
END; -- F_G_PK_ESTAGIARIO_VAGA

/
--------------------------------------------------------
--  DDL for Function F_AVS_BUSCA_CAMPO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_AVS_BUSCA_CAMPO" 
  (ptx_campo IN campo.tx_campo%type,
   pid_tabela IN tabela.id_tabela%type,
   ptx_tipo_campo IN tipo_campo.tx_tipo_campo%type)
RETURN  campo.nb_campo%type IS pnb_campo campo.nb_campo%type;

   pid_servidor   number;
   numregs        number;
   pcs_tipo_campo number;
BEGIN
    pnb_campo := 0;
    numregs := 0;
    
    select max(nb_campo) into numregs
    from campo
    where tx_campo = ptx_campo and
          id_tabela = pid_tabela;
     
    if numregs > 0 then
      select nb_campo into pnb_campo
      from campo
      where tx_campo = ptx_campo and
            id_tabela = pid_tabela;
    else
      select max(id_servidor) into pid_servidor
      from parametros_default;
      pcs_tipo_campo := F_Busca_Tipo_Campo(ptx_tipo_campo,pid_servidor);
      pnb_campo := F_G_PK_campo(pid_tabela);
      insert into campo (id_tabela, nb_campo, tx_campo,cs_tipo_campo)
             values (pid_tabela, pnb_campo, ptx_campo,pcs_tipo_campo);
    end if;

    RETURN pnb_campo;
END;


-- End of DDL script for F_AVS_BUSCA_CAMPO

/
--------------------------------------------------------
--  DDL for Function F_AVS_BUSCA_TABELA
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_AVS_BUSCA_TABELA" 
  (ptx_tabela IN Tabela.tx_nome%type)
RETURN  Tabela.ID_Tabela%type IS Pid_Tabela Tabela.ID_Tabela%type;
   pid_servidor number;
   numregs number;
BEGIN
    numregs := 0;
    select count(id_tabela) into numregs
    from tabela
    where tx_nome = ptx_tabela;
    if numregs <> 0 then
       select id_tabela into Pid_Tabela
       from tabela
       where tx_nome = ptx_tabela;
    else
      pid_tabela := F_G_PK_Tabela();
      select max(id_servidor) into pid_servidor
           from parametros_default;
      insert into tabela (id_tabela, tx_nome, id_servidor, cs_atualizacao)
             values (pid_tabela, ptx_tabela, pid_servidor,2);
    end if;
    RETURN Pid_Tabela;
END;


-- End of DDL script for F_AVS_BUSCA_TABELA

/
--------------------------------------------------------
--  DDL for Function F_AVS_CADASTRA_TRANSACAO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_AVS_CADASTRA_TRANSACAO" 
  ( pID_Tabela IN Tabela.ID_Tabela%type,
    pID_Usuario IN Usuario.ID_Usuario%type,
    pcs_evento IN number)
  RETURN  number IS pnb_Transacao number;
BEGIN
  pnb_transacao := F_G_PK_transacao_historico(pid_usuario,pid_tabela);
  insert into transacao_historico (id_tabela, id_usuario, nb_transacao_historico, dt_transacao_historico, cs_evento)
  values (pid_tabela, pid_usuario, pnb_transacao, sysdate, pcs_evento);
  RETURN pnb_transacao;
END; -- F_AVS_CADASTRA_TRANSACAO

-- End of DDL script for F_AVS_CADASTRA_TRANSACAO

/
--------------------------------------------------------
--  DDL for Function F_G_PK_VALOR_HISTORICO
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_VALOR_HISTORICO" 
(PID_TABELA NUMBER,PNB_TRANSACAO_HISTORICO NUMBER,PNB_CAMPO NUMBER,PID_USUARIO NUMBER)
RETURN NUMBER IS V_N_VALOR_HISTORICO NUMBER;
BEGIN
   SELECT COUNT (*) INTO  V_N_VALOR_HISTORICO
   FROM VALOR_HISTORICO
   WHERE(ID_TABELA = PID_TABELA AND NB_TRANSACAO_HISTORICO = PNB_TRANSACAO_HISTORICO AND NB_CAMPO = PNB_CAMPO AND ID_USUARIO = PID_USUARIO );
    IF V_N_VALOR_HISTORICO = 0 THEN
        V_N_VALOR_HISTORICO := 1;
    ELSE
        SELECT MAX(NB_VALOR_HISTORICO) + 1
        INTO V_N_VALOR_HISTORICO
        FROM VALOR_HISTORICO
        WHERE (ID_TABELA = PID_TABELA AND NB_TRANSACAO_HISTORICO = PNB_TRANSACAO_HISTORICO AND NB_CAMPO = PNB_CAMPO AND ID_USUARIO = PID_USUARIO );
     END IF;
     RETURN V_N_VALOR_HISTORICO;
END; -- F_G_PK_VALOR_HISTORICO

/
--------------------------------------------------------
--  DDL for Function F_G_PK_PLAQUETA_INATIVADA
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SEMAD"."F_G_PK_PLAQUETA_INATIVADA" 
(PID_RECIBO_PLAQUETA integer)
RETURN NUMBER IS V_N_PLAQUETA_INATIVADA NUMBER;
begin
   select NVL(max(NB_PLAQUETA_INATIVA),0) into V_N_PLAQUETA_INATIVADA
   FROM PLAQUETA_INATIVA
   WHERE(ID_RECIBO_PLAQUETA = PID_RECIBO_PLAQUETA);
    
    IF V_N_PLAQUETA_INATIVADA = 0 THEN
        V_N_PLAQUETA_INATIVADA := 1;
    else
        V_N_PLAQUETA_INATIVADA := V_N_PLAQUETA_INATIVADA+1;
     end if;
     
     return V_N_PLAQUETA_INATIVADA;
END; 

/

  GRANT EXECUTE ON "SEMAD"."F_G_PK_PLAQUETA_INATIVADA" TO "PATRIMONIO_MOVEL_CAD";
 
  GRANT EXECUTE ON "SEMAD"."F_G_PK_PLAQUETA_INATIVADA" TO "PATRIMONIO_MOVEL_MOV_IND";
 
  GRANT EXECUTE ON "SEMAD"."F_G_PK_PLAQUETA_INATIVADA" TO "PATRIMONIO_CONS";
--------------------------------------------------------
--  DDL for Package ARHP8170
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "OSMUNDO"."ARHP8170" AUTHID DEFINER IS

   -- Variaveis criadas a partir da SA 16299
   -- Alimentadas pela rotina ALTERA_SENHA
   vsid        NUMBER;
   vserial     NUMBER;
   vlckhandle  VARCHAR2(512)  := NULL;
   vlckwait    INTEGER        := 5;
   vlckreqwait INTEGER        := 30;
   vlckret     INTEGER        := -1;

   -- Funcoes criadas a partir da SA 16299
   -- Utilizadas na rotina ARHL002.CONEXAO_SISTEMA
   FUNCTION GET_SID    RETURN NUMBER;
   FUNCTION GET_SERIAL RETURN NUMBER;
   FUNCTION GET_SENHA_REGISTRADA(p_usuario IN VARCHAR2,
                                 p_sid     IN OUT NUMBER,
                                 p_serial  IN OUT NUMBER) RETURN VARCHAR2;
   PROCEDURE BLOQUEIA_SECAO_CRITICA(P_NOME_BLOCK VARCHAR2);
   PROCEDURE LIBERA_SECAO_CRITICA;

   FUNCTION AUTENTICACAO_AVANCADA RETURN BOOLEAN;

   FUNCTION AUTENTICACAO_INTERMEDIARIA RETURN BOOLEAN;

   FUNCTION VALIDA_PERFIL (P_USER_BANCO  IN VARCHAR2,
                           P_PFIS_NUMERO IN NUMBER,
                           P_PERFIL      IN NUMBER) RETURN BOOLEAN;

   FUNCTION GET_USUARIO_DEFAULT RETURN VARCHAR2;

   FUNCTION SENHA_EXPIRADA (P_PFIS_NUMERO IN NUMBER) RETURN BOOLEAN;

   FUNCTION SENHA_BLOQUEADA (P_PFIS_NUMERO IN NUMBER) RETURN BOOLEAN ;

   FUNCTION GET_SENHA_BANCO (P_USUARIO IN VARCHAR2) RETURN VARCHAR2;

   PROCEDURE SET_DADOS_SESSAO (P_USER_BANCO  IN VARCHAR2,
                               P_SENHA_BANCO IN VARCHAR2,
                               P_SENHA_PF    IN VARCHAR2,
                               P_PFIS_NUMERO IN NUMBER DEFAULT NULL,
                               P_EMPRESA     IN NUMBER DEFAULT NULL,
                               P_MATRICULA   IN NUMBER DEFAULT NULL,
                               P_CONTRATO    IN NUMBER DEFAULT NULL
                               );

   FUNCTION GET_INFO_CONEXAO (P_SENHA       IN VARCHAR2,
                              P_PFIS_NUMERO IN NUMBER DEFAULT NULL,
                              P_EMPRESA     IN NUMBER DEFAULT NULL,
                              P_MATRICULA   IN NUMBER DEFAULT NULL,
                              P_CONTRATO    IN NUMBER DEFAULT NULL,
                              P_PERFIL      IN NUMBER DEFAULT NULL) RETURN VARCHAR2;

   PROCEDURE VER;

   FUNCTION EXEC_FUNCAO (P_FUNCAO VARCHAR2) RETURN BOOLEAN;

   FUNCTION ALTERA_SENHA (p_usuario IN VARCHAR2) RETURN VARCHAR2;

   FUNCTION BUSCA_USUARIO (p_pfis_numero IN NUMBER, p_perfil IN NUMBER) RETURN VARCHAR2;
END ARHP8170;


/
--------------------------------------------------------
--  DDL for Package MD_META
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "OSMUNDO"."MD_META" 
AS
FUNCTION get_next_id RETURN NUMBER;
-- Following code taken directly from wwv_flow_random from APEX
--
-- seed random function
procedure srand( new_seed in number );

function rand return number;
pragma restrict_references( rand, WNDS  );

procedure get_rand( r OUT number );

function rand_max( n IN number ) return number;
pragma restrict_references( rand_max, WNDS);

procedure get_rand_max( r OUT number, n IN number );

function quote(catalog IN VARCHAR2, schema IN VARCHAR2, object IN VARCHAR2, connid LONG) RETURN VARCHAR2;
END;

/
--------------------------------------------------------
--  DDL for Package MIGRATION
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "OSMUNDO"."MIGRATION" 
AS

-- Public functions
FUNCTION copy_connection_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL,p_scratchModel BOOLEAN := FALSE) RETURN NUMBER;
FUNCTION transform_all_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE, p_prefixName VARCHAR2, p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_ARRAY;
FUNCTION transform_datatypes(p_connectionid MD_CONNECTIONS.ID%TYPE, p_mapid MIGR_DATATYPE_TRANSFORM_MAP.ID%TYPE, p_numbytesperchar INTEGER) RETURN NUMBER;
FUNCTION transform_identity_columns(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER;
FUNCTION transform_rewrite_trigger(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER;
FUNCTION gatherConnectionStats(p_connectionId MD_CONNECTIONS.ID%TYPE,p_comments MD_CONNECTIONS.COMMENTS%TYPE) RETURN NUMBER;
PROCEDURE transform_clashes(p_connectionid MD_CONNECTIONS.ID%TYPE, p_scratchModel BOOLEAN := FALSE);
PROCEDURE populate_derivatives_table(p_connectionid MD_CONNECTIONS.ID%TYPE);
PROCEDURE revert_derivatives_table(p_connectionid MD_CONNECTIONS.ID%TYPE);
END;

/
--------------------------------------------------------
--  DDL for Package MIGRATION_REPORT
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "OSMUNDO"."MIGRATION_REPORT" AS 
--get status
  FUNCTION getCaptureStatus(srcid IN NUMBER)  RETURN VARCHAR2;
  FUNCTION getConvertStatus(srcid IN NUMBER,convert_conn_id IN NUMBER)  RETURN VARCHAR2;
  FUNCTION getGenerateStatus(srcid IN NUMBER,convert_conn_id IN NUMBER)  RETURN VARCHAR2;
--migration details
  FUNCTION getDetails(capture_conn_id IN NUMBER,convert_conn_id IN NUMBER) RETURN MIGR_REPORT_DETAIL_TABLE PIPELINED; 
--migration summary
   FUNCTION getSum(capture_conn_id IN NUMBER,convert_conn_id IN NUMBER) RETURN MIGR_REPORT_SUM_TABLE PIPELINED;
END MIGRATION_REPORT;

/
--------------------------------------------------------
--  DDL for Package MIGRATION_TRANSFORMER
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "OSMUNDO"."MIGRATION_TRANSFORMER" AS
FUNCTION check_identifier_length(p_ident VARCHAR2) RETURN VARCHAR2;
FUNCTION add_suffix(p_work VARCHAR2, p_suffix VARCHAR2, p_maxlen NUMBER) RETURN VARCHAR2;
FUNCTION check_reserved_word(p_work VARCHAR2) RETURN VARCHAR2;
FUNCTION sys_check(p_work VARCHAR2) RETURN VARCHAR2;
FUNCTION check_allowed_chars(p_work NVARCHAR2) RETURN NVARCHAR2;
FUNCTION transform_identifier(p_identifier NVARCHAR2)  RETURN NVARCHAR2;
FUNCTION getDisallowedCharsNames(p_work NVARCHAR2) RETURN VARCHAR2;
FUNCTION getNameForNullCase(p_work NVARCHAR2) RETURN NVARCHAR2;
END;

/
--------------------------------------------------------
--  DDL for Package OFS
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "OSMUNDO"."OFS" is

  procedure init_root;
  function os_user return varchar2;

  -- Cursor type to return directory entries.
  -- Includes all OFS_ITEMS columns, except id, parent_id, and data.
  -- It also includes dbms_lob.getlength(data) as size.
  type dir_cursor is ref cursor;

  -- Get directory entries.
  -- %param p_path    \dir1\dir2
  -- %param p_mask    hello*.da?[; mask2[; ...]]
  -- %param p_alldirs 'Y' - include all subdirs, 'N' - subdirs according mask
  -- %param p_crs     cursor with the matching directory entries
  procedure get_dir(p_path    in varchar2,
                    p_mask    in varchar2,
                    p_alldirs in varchar2,
                    p_crs     in out dir_cursor);

  -- Read file data.
  -- %param p_filename \dir1\dir2\file.ext
  function read_file(p_filename in varchar2) return blob;

  -- Write file data.
  -- File must be unlocked or locked by current OS user and not read_only.
  -- For new files, parent directory must not be read_only. New files in a
  -- compressed directory are implicitly compressed.
  -- %param p_filename \dir1\dir2\file.ext
  -- %param p_data temporary BLOB with all file data
  procedure write_file(p_filename in varchar2,
                       p_data     in blob);

  -- Create directory.
  -- Parent directory must not be read_only.
  -- %param p_dirname \dir1\dir
  procedure create_dir(p_dirname in varchar2);

  -- Delete file or directory.
  -- File must be unlocked or locked by current OS user and not read_only.
  -- Directory must not be read_only.
  -- Parent directory must not be read_only.
  -- %param p_dirname \dir1\dir or \dir1\file.ext
  procedure delete(p_itemname in varchar2);

  -- Set file or directory attribute.
  -- File must be unlocked or locked by current OS user.
  -- Compression is ignored on Oracle9.2 or earlier (utl_compress dependency).
  -- %param p_itemname The name of the file or directory
  -- %param p_attrname 'READ_ONLY', 'COMPRESSED' or 'LOCKED'
  -- %param p_value    'Y' or 'N'
  procedure set_attr(p_itemname in varchar2,
                     p_attrname in varchar2,
                     p_value    in varchar2);

  -- Get file or directory attribute.
  -- %param p_itemname The name of the file or directory
  -- %param p_attrname 'READ_ONLY', 'COMPRESSED' or 'LOCKED'
  -- %return 'Y' or 'N'
  function get_attr(p_itemname in varchar2,
                    p_attrname in varchar2) return varchar2;

  -- Get file or directory last modification date.
  function get_date(p_itemname in varchar2) return date;

  -- Lock file.
  -- File must be unlocked and not read_only.
  -- %param p_filename \dir1\dir2\file.ext
  procedure lock_file(p_filename in varchar2);

  -- Unlock file.
  -- File must be locked by current OS user
  -- %param p_filename \dir1\dir2\file.ext
  procedure unlock_file(p_filename in varchar2);

  -- Rename file or directory.
  -- File must be unlocked or locked by current OS user and not read_only.
  -- %param p_itemname \dir1\dir2\file.ext
  -- %param p_newname  newfile.ext
  procedure rename(p_itemname in varchar2, p_newname in varchar2);

  -- Move file or directory.
  -- File must be unlocked or locked by current OS user and not read_only.
  -- %param p_itemname \dir1\dir2\file.ext
  -- %param p_newdir   \dir1\dir2
  procedure move(p_itemname in varchar2, p_newdir in varchar2);

  -- Copy file or directory.
  -- File must be unlocked or locked by current OS user and not read_only.
  -- %param p_itemname \dir1\dir2\file.ext
  -- %param p_newdir   \dir1\dir2
  procedure copy(p_itemname in varchar2, p_newdir in varchar2);

  -- Tests if a specified file exists.
  -- %param p_filename \dir1\dir2\file.ext
  -- %return 'Y' or 'N'
  function file_exists(p_filename in varchar2) return char;

  -- Tests if a specified directory exists.
  -- %param p_path \dir1\dir2
  -- %return 'Y' or 'N'
  function directory_exists(p_path in varchar2) return char;

end OFS;

/
--------------------------------------------------------
--  DDL for Package OFS_COMPRESS
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "OSMUNDO"."OFS_COMPRESS" is
  function is_active return boolean;
  procedure comp(src in     blob,
                 dst in out nocopy blob);
  function uncomp(src in blob) return blob;
  procedure uncomp(src in     blob,
                   dst in out nocopy blob);
end;

/
--------------------------------------------------------
--  DDL for Package OFS_PRIVATE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "OSMUNDO"."OFS_PRIVATE" is
  -- business rules enforcement routines
  procedure change_clear;
  procedure change_verify_row(p_new_id in OFS_ITEMS.id%type,
    p_new_item_type in OFS_ITEMS.item_type%type,
    p_old_item_type in OFS_ITEMS.item_type%type,
    p_old_locked_by in OFS_ITEMS.locked_by%type,
    p_new_locked_by in OFS_ITEMS.locked_by%type,
    p_old_read_only in OFS_ITEMS.read_only%type,
    p_new_read_only in OFS_ITEMS.read_only%type,
    p_op in char);
  procedure change_register(p_id in OFS_ITEMS.id%type,
    p_parent_id in OFS_ITEMS.id%type, p_op in char);
  procedure change_verify;
  function os_user return varchar2;
  procedure set_os_user(p_user in varchar2);
  procedure force_unlock(p_id in OFS_ITEMS.id%type);

  -- test helper routines
  procedure test_count_recs(p_num in integer,
    p_ok_msg in varchar2, p_err_msg in varchar2);
  procedure test_count_cursor(p_crs in ofs.dir_cursor,
    p_num in integer, p_ok_msg in varchar2,
    p_err_msg in varchar2);
  procedure test_error(p_error in varchar2,
    p_ok_msg in varchar2, p_err_msg in varchar2);
  procedure test_attr(p_path in varchar2, p_attr in varchar2,
    p_val in varchar2, p_ok_msg in varchar2, p_err_msg in varchar2);
end;

/
--------------------------------------------------------
--  DDL for Package Body ARHP8170
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "OSMUNDO"."ARHP8170" IS
vativa_trace   BOOLEAN := FALSE;
vmsg_ind       NUMBER  := 0;

PROCEDURE VER IS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Universo Desenvolvimento de Sistemas Ltda.');
  DBMS_OUTPUT.PUT_LINE('ARHP8170 - Vrs. '||ARHP8140.VERSAO_UNIVERSAL('22.08.2012'));
  DBMS_OUTPUT.PUT_LINE('Rotinas Autenticacao Avancada');
  DBMS_OUTPUT.PUT_LINE('Direitos Autorais (c) 1994-2012');

END VER;


FUNCTION DESCRIPTOGRAFA (p_senha IN VARCHAR2) RETURN VARCHAR2 IS
   vsemente      configuracoes_acesso.semente_criptografia%TYPE;
   vretorno      VARCHAR2(30);
   vchave_cliente configuracoes_acesso.semente_criptografia%TYPE;

BEGIN
   vmsg_ind := 1; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   BEGIN
     SELECT
        semente_criptografia
     INTO
        vchave_cliente
     FROM
        configuracoes_Acesso;
   EXCEPTION
   WHEN NO_DATA_FOUND THEN
      vchave_cliente := NULL;
   WHEN TOO_MANY_ROWS THEN
      vchave_cliente := NULL;
   END;

   vmsg_ind := 2; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;

   IF p_senha IS NOT NULL THEN
		vmsg_ind := 3; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
	   -- descriptografa a semente do cliente
	   dbms_obfuscation_toolkit.DESDecrypt
	      (input_string     => vchave_cliente,
	       key_string       => ARHP8150.GET_SEMENTE, -- carrega semente da Acao
	       decrypted_string => vsemente );
	   -- com a semente do cliente, descriptografa a senha
	   dbms_obfuscation_toolkit.DESDecrypt
	      (input_string     => p_senha,
	       key_string       => vsemente, -- carrega semente da CLIENTE
	       decrypted_string => vretorno );
   ELSE
		vmsg_ind := 4; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
      vretorno := NULL;
   END IF;

	vmsg_ind := 5; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   RETURN( REPLACE(vretorno, CHR(0),''));
END;

--============================================================================================--

FUNCTION AUTENTICACAO_AVANCADA RETURN BOOLEAN IS
   vexiste       NUMBER := 0;
   vexiste1      NUMBER := 0;
   vretorno      VARCHAR2(30);
   vruntime      runtimes.runt_runtime_id%TYPE := 'TIPO_AUTENTICACAO';
   vtipoAut      runtimes.runt_cmd%TYPE        := 'AVANCADO';
BEGIN
	vmsg_ind := 6; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   -- busca runtime
   BEGIN
      SELECT
         1
      INTO
         vexiste
      FROM
         runtimes
      WHERE
         runt_runtime_id = vruntime AND
         runt_cmd        = vtipoAut;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         vexiste := 0;
   END;
	vmsg_ind := 7; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;

   -- busca data de migracao do acesso simples para o avancado
   BEGIN
      SELECT
         SUM(1)
      INTO
         vexiste1
      FROM
         configuracoes_acesso
      WHERE
         dt_migracao IS NOT NULL;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         vexiste1 := 0;
   END;
	vmsg_ind := 8; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;

   -- AUTENTICACAO AVANCADA
   IF vexiste = 1 AND vexiste1 = 1 THEN
      RETURN(TRUE);
   -- AUTENTICACAO SIMPLES
   ELSE
      RETURN(FALSE);
   END IF;
END;

--============================================================================================--
FUNCTION AUTENTICACAO_INTERMEDIARIA RETURN BOOLEAN IS
	vexiste	NUMBER := 0;
	vruntime runtimes.runt_runtime_id%TYPE := 'TIPO_AUTENTICACAO';
   vtipoAut runtimes.runt_cmd%TYPE        := 'INTERMEDIARIO';


	BEGIN
		vmsg_ind := 9; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
		BEGIN
      	SELECT
         	1
      	INTO
         	vexiste
      	FROM
         	runtimes
      	WHERE
				runt_runtime_id = vruntime AND
         	runt_cmd        = vtipoAut;
   	EXCEPTION
      	WHEN NO_DATA_FOUND THEN
         	vexiste := 0;
   	END;

		vmsg_ind := 10; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
		IF vexiste = 1 THEN
			RETURN (TRUE);
		ELSE
			RETURN (FALSE);
		END IF;

	END;

--============================================================================================--
-- Essa rotina e executada quando o controle de acesso intermediario esta configurado.
-- Sua funcao e validar se a combinacao de Pessoa Fisica, Usuario de Banco e perfil de acesso
-- permite acesso ao sistema.
FUNCTION VALIDA_PERFIL(P_USER_BANCO  IN VARCHAR2,
		             P_PFIS_NUMERO IN NUMBER,
		             P_PERFIL       IN NUMBER) RETURN BOOLEAN IS
	vexiste NUMBER := 0;

BEGIN
	vmsg_ind := 11; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;

   SELECT
      COUNT(usua_username)
   INTO
      vexiste
   FROM
      reg_pfis_usuarios rpus,
      usuarios   usua
   WHERE
      rpus.usua_username = p_user_banco       AND
      rpus.pfis_numero   = p_pfis_numero      AND
      rpus.dt_ini_vig   <= TRUNC(SYSDATE)     AND
     (rpus.dt_fim_vig    > TRUNC(SYSDATE) OR
      rpus.dt_fim_vig 	IS NULL
     )				 AND
   usua.username 	= rpus.usua_username AND
  usua.peac_cod	 = p_perfil;

 	vmsg_ind := 12; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;

   IF vexiste != 0 THEN
      RETURN(TRUE);
   ELSE
      RETURN(FALSE);
   END IF;
END;

--============================================================================================--

FUNCTION GET_USUARIO_DEFAULT RETURN VARCHAR2 IS
   vusuario_def configuracoes_acesso.usua_username%TYPE;

BEGIN
	vmsg_ind := 13; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   BEGIN
      SELECT
         usua_username
      INTO
         vusuario_def
      FROM
         configuracoes_acesso;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         vusuario_def := NULL;
      WHEN TOO_MANY_ROWS THEN
         vusuario_def := NULL;
   END;

   RETURN(vusuario_def);
END;

--============================================================================================--

FUNCTION BUSCA_PF (P_EMPRESA   IN NUMBER,
                   P_MATRICULA IN NUMBER,
                   P_CONTRATO  IN NUMBER) RETURN NUMBER IS
   vnumero pessoas_fisicas.numero%TYPE := NULL;

BEGIN
	vmsg_ind := 14; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   IF p_empresa   IS NOT NULL AND
      p_matricula IS NOT NULL THEN

       BEGIN
          SELECT
             pfis_numero
          INTO
             vnumero
          FROM
             reg_empregos
          WHERE
             emp_cod = p_empresa AND
             chapa   = p_matricula;
       EXCEPTION
          WHEN NO_DATA_FOUND THEN
             vnumero := NULL;
       END;

	vmsg_ind := 15; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;

   ELSIF p_empresa IS NOT NULL AND
         p_contrato IS NOT NULL THEN
			vmsg_ind := 16; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
       BEGIN
          SELECT
             pfis_numero
          INTO
             vnumero
          FROM
             elo_contratos
          WHERE
             emp_cod  = p_empresa AND
             contrato = p_contrato;
       EXCEPTION
          WHEN NO_DATA_FOUND THEN
             vnumero := NULL;
       END;
   END IF;

    RETURN(vnumero);
END;

--============================================================================================--
FUNCTION ALTERA_SENHA (p_usuario IN VARCHAR2) RETURN VARCHAR2 IS
   vsenha_nova VARCHAR2(30)   := NULL;
   vsenha      VARCHAR2(30)   := NULL;
   vcmd        VARCHAR2(1024) := NULL;
   vnumrows    INTEGER        := 1;
   vprogram    VARCHAR2(7)    := 'FRMWEB%';
   vurhprefix  VARCHAR2(5)    := 'URHCA';

   -- As informacoes de variavel de contexto de pessoa fisica e
   -- ultimo programa executado pelo usuario estao registradas na
   -- tabela virtual V$SESSION,colunas ACTION e MODULE respectivamente.
BEGIN

   vmsg_ind := 17; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   vsenha := GET_SENHA_REGISTRADA(p_usuario,vsid,vserial);

   vmsg_ind := 18; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   IF vsenha IS NULL THEN
      vsenha_nova := DBMS_RANDOM.STRING ('U',1) || DBMS_RANDOM.STRING ('X',5); -- a senha nao pode comecar com numeros
      BEGIN
         IF vativa_trace THEN
            dbms_output.put_line('senha '||p_usuario||'*'||vsenha_nova);
         END IF;

         vcmd := 'ALTER USER '||p_usuario||' IDENTIFIED BY '||vsenha_nova;

         IF vativa_trace THEN
            dbms_output.put_line(vcmd);
         END IF;

         arhp8003.exec_sql(vcmd);
      EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR(-20101,'Nao foi possivel carregar a senha da pessoa fisica. '||SQLERRM);
         RETURN(NULL);
      END;
      RETURN(vsenha_nova);
   ELSE
      -- Substituicao da ARHP8200.DESCRIPTOGRAFA_SENHA em funcao
      -- da ocorrencia do erro ORA-28232 durante a execucao do
      -- package DBMS_OBFUSCATION_TOOLKIT. Este erro ocorre quando
      -- ocorre multiplas conexoes de forma simultanea. Por esse motivo,
      -- a senha do usuario do banco sera descritograda com a rotina
      -- ARHP8200.UNPROTECT
      --RETURN(ARHP8200.DESCRIPTOGRAFA_SENHA(vsenha));
      RETURN(vsenha);
   END IF;
EXCEPTION
WHEN OTHERS THEN
   RAISE_APPLICATION_ERROR(-20102,'Nao foi possivel carregar a senha da pessoa fisica. '||SQLERRM);
   RETURN(NULL);
END;

--============================================================================================--
FUNCTION BUSCA_USUARIO (p_pfis_numero IN NUMBER, p_perfil IN NUMBER) RETURN VARCHAR2 IS
   vusuario        reg_pfis_usuarios.usua_username%TYPE;
   vtot_usuarios   NUMBER(3);
   vtot_perfis     NUMBER(3);

   CURSOR c_perf IS
      SELECT
        peac_cod,
        COUNT(*) tot
      FROM
        usuarios u,
        reg_pfis_usuarios r
      WHERE
        u.username    = r.usua_username   AND
        (r.dt_fim_vig > TRUNC(SYSDATE)   OR
        r.dt_fim_vig  IS NULL  )          AND
        r.dt_ini_vig  <= TRUNC(SYSDATE)   AND
        r.pfis_numero  = p_pfis_numero
      GROUP BY peac_cod;
   r1 c_perf%ROWTYPE;
BEGIN
	vmsg_ind := 19; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   SELECT
		COUNT(usua_username)
   INTO
   	vtot_usuarios
   FROM
   	reg_pfis_usuarios
   WHERE
   	(dt_fim_vig > TRUNC(SYSDATE) OR
      dt_fim_vig  IS NULL  )        AND
      dt_ini_vig  <= TRUNC(SYSDATE) AND
      pfis_numero  = p_pfis_numero;

    IF vtot_usuarios = 0 THEN
       vusuario := ARHP8170.get_usuario_default;
       IF vusuario IS NULL THEN
          RAISE_APPLICATION_ERROR(-20103,'Erro: ESSA PESSOA FISICA NAO POSSUI PERFIL. NAO EXISTE INFORMACAO DE USUARIO DEFAULT CADASTRADO.');
       END IF;
    ELSIF vtot_usuarios = 1 THEN
		  vmsg_ind := 20; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
        BEGIN
           SELECT
              usua_username
           INTO
              vusuario
           FROM
              reg_pfis_usuarios
           WHERE
              (dt_fim_vig > TRUNC(SYSDATE) OR
              dt_fim_vig  IS NULL  )        AND
              dt_ini_vig  <= TRUNC(SYSDATE) AND
              pfis_numero  = p_pfis_numero;
        EXCEPTION
           WHEN NO_DATA_FOUND THEN
              -- busca usuario default
              vusuario := ARHP8170.get_usuario_default;
        END;
    ELSIF vtot_usuarios > 1 AND p_perfil IS NULL THEN
		 vmsg_ind := 21; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
       vtot_perfis := 0;

       OPEN c_perf;
       LOOP
         FETCH c_perf INTO r1;
			vmsg_ind := 22; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
         EXIT WHEN c_perf%NOTFOUND;
         IF r1.tot > 1 THEN
            vtot_perfis := vtot_perfis + 1;
         END IF;
       END LOOP;

		 vmsg_ind := 23; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
       vusuario := NULL;

       IF vtot_perfis = 0 THEN
          RAISE_APPLICATION_ERROR(-20104,'Erro: O PERFIL DEVE SER INFORMADO. PESSOA FISICA POSSUI MAIS DE UM PERFIL.');
       ELSE
          RAISE_APPLICATION_ERROR(-20107,'Erro: PESSOA FISICA POSSUI MAIS DE UM USUARIO NO MESMO PERFIL.');
       END IF;
    ELSIF vtot_usuarios > 1 AND p_perfil IS NOT NULL THEN
		  vmsg_ind := 24; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
        BEGIN
           SELECT
              r.usua_username
           INTO
              vusuario
           FROM
              usuarios u,
              reg_pfis_usuarios r
           WHERE
              u.username    = r.usua_username   AND
              u.peac_cod    = p_perfil     AND
              (r.dt_fim_vig > TRUNC(SYSDATE)   OR
              r.dt_fim_vig  IS NULL  )          AND
              r.dt_ini_vig  <= TRUNC(SYSDATE)   AND
              r.pfis_numero  = p_pfis_numero;
        EXCEPTION
           WHEN NO_DATA_FOUND THEN
              RAISE_APPLICATION_ERROR(-20105,'Erro: O PERFIL INFORMADO NAO ESTA DISPONIVEL PARA ESSA PESSOA FISICA.');
           WHEN TOO_MANY_ROWS THEN
              RAISE_APPLICATION_ERROR(-20106,'Erro: ESTE PERFIL POSSUI MAIS DE UM USUARIO ASSOCIADO. CONTATE O ADMINISTRADOR DO SISTEMA.');
        END;
    END IF;

    RETURN(vusuario);

END;
--============================================================================================--
PROCEDURE VALIDA_PF(p_pfis_numero IN NUMBER,
                    p_senha       IN VARCHAR2) IS
   vfuncao              configuracoes_acesso.password_authentic_function%TYPE;
   vind_senha_bloqueada pessoas_fisicas.ind_senha_bloqueada%TYPE;
   vind_senha_expirada  pessoas_fisicas.ind_senha_expirada%TYPE;

BEGIN
	vmsg_ind := 25; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   BEGIN
      SELECT
         password_authentic_function
      INTO
         vfuncao
      FROM
         configuracoes_acesso;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         vfuncao := NULL;
      WHEN TOO_MANY_ROWS THEN
         RAISE_APPLICATION_ERROR(-20007,'Verifique as configuracoes de acesso');
   END;

   BEGIN
      SELECT
         ind_senha_bloqueada,
         ind_senha_expirada
      INTO
         vind_senha_bloqueada,
         vind_senha_expirada
      FROM
         pessoas_fisicas
      WHERE
         numero = p_pfis_numero;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         vind_senha_bloqueada := 'N';
         vind_senha_expirada := 'N';
   END;

   IF vind_senha_bloqueada = 'S' THEN
      RAISE_APPLICATION_ERROR(-20008,'Erro: PESSOA FISICA ESTA BLOQUEADA');
   END IF;

   IF vind_senha_expirada = 'S' THEN
      RAISE_APPLICATION_ERROR(-20009,'ASSINATURA ELETRONICA ESTA EXPIRADA. DEVE SER ALTERADA.');
   END IF;

	vmsg_ind := 26; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   IF vfuncao IS NOT NULL THEN
      vfuncao := vfuncao ||'('||TO_CHAR(p_pfis_numero)||','''||NVL(p_senha,'NULL')||''')';
      IF NOT EXEC_FUNCAO(vfuncao) THEN
         RAISE_APPLICATION_ERROR(-20010,'A assinatura eletronica nao foi validada pela funcao '||SUBSTR(vfuncao,1,INSTR(vfuncao,'(')-1)||'. Entre em contato com o Administrador');
      END IF;
   END IF;

END;
--============================================================================================--

FUNCTION GET_INFO_CONEXAO (P_SENHA       IN VARCHAR2,
                           P_PFIS_NUMERO IN NUMBER DEFAULT NULL,
                           P_EMPRESA     IN NUMBER DEFAULT NULL,
                           P_MATRICULA   IN NUMBER DEFAULT NULL,
                           P_CONTRATO    IN NUMBER DEFAULT NULL,
                           P_PERFIL      IN NUMBER DEFAULT NULL) RETURN VARCHAR2 IS
   vusuario         reg_pfis_usuarios.usua_username%TYPE;
   vsenha           VARCHAR2(100);
   vsenha_banco     VARCHAR2(100);
   vsenha_encrypt   pessoas_fisicas.senha_avancada%TYPE;
   vperfil_acesso   perfis_acesso.cod%TYPE;
   vnumero_pf       pessoas_fisicas.numero%type := NULL;
   vfuncao          configuracoes_acesso.password_authentic_function%TYPE;

   -- Variaveis temporarias para uso na chamada da rotina
   -- GET_SENHA_REGISTRADA
   vsid_tmp         NUMBER := NULL;
   vserial_tmp	    NUMBER := NULL;
BEGIN
   vmsg_ind := 27; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   IF (P_PFIS_NUMERO IS NULL
      ) AND
      (P_EMPRESA     IS NULL OR
       P_MATRICULA   IS NULL
      )  AND
      (P_EMPRESA     IS NULL OR
       P_CONTRATO    IS NULL
      ) THEN
       RAISE_APPLICATION_ERROR(-20011,'Pelo menos Numero Pessoa Fisica, ou Empresa e Matricula, ou Empresa e Contrato devem ser informados para efetuar a identificacao de usuario.');
       RETURN(NULL);
   END IF;

   IF P_PFIS_NUMERO IS NULL THEN
      vnumero_pf := BUSCA_PF(P_EMPRESA,P_MATRICULA,P_CONTRATO);
   ELSE
      vnumero_pf := P_PFIS_NUMERO;
   END IF;

   BEGIN
      SELECT
         senha_avancada
      INTO
         vsenha_encrypt
      FROM
         pessoas_fisicas
      WHERE
         numero = vnumero_pf;
   EXCEPTION
   WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20012,'Senha da pessoa fisica e nula. '||vnumero_pf);
   WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR(-20013,'Erro na funÃ§Ã£o GET_INFO_CONEX:'|| SQLERRM);
   END;

   vmsg_ind := 28; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;

   IF DESCRIPTOGRAFA(vsenha_encrypt) <> p_senha THEN
      RAISE_APPLICATION_ERROR(-20014,'Senha da pessoa fisica nao e valida.');
   ELSE
      VALIDA_PF(vnumero_pf,p_senha);
   END IF;

   vusuario := BUSCA_USUARIO(vnumero_pf,p_perfil);

   vmsg_ind := 29; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;

   BEGIN
      SELECT
         password_authentic_function
      INTO
         vfuncao
      FROM
         configuracoes_acesso;
   EXCEPTION
   WHEN NO_DATA_FOUND THEN
      vfuncao := NULL;
   WHEN TOO_MANY_ROWS THEN
      RAISE_APPLICATION_ERROR(-20015,'Verifique as configuracoes de acesso');
   END;

   IF vfuncao IS NOT NULL THEN
      vfuncao := vfuncao ||'('||TO_CHAR(vnumero_pf)||','''||NVL(p_senha,'NULL')||''')';
      IF NOT EXEC_FUNCAO(vfuncao) THEN
         RAISE_APPLICATION_ERROR(-20016,'A assinatura eletronica nao foi validada pela funcao '||SUBSTR(vfuncao,1,INSTR(vfuncao,'(')-1)||'. Entre em contato com o Administrador');
      END IF;
   END IF;

   vsenha := GET_SENHA_REGISTRADA(vusuario, vsid_tmp, vserial_tmp);

   IF vsenha IS NOT NULL THEN
      vsenha := DESCRIPTOGRAFA(vsenha);
   ELSE
      vsenha := ALTERA_SENHA(vusuario);
   END IF;

   RETURN (vusuario || '/' || vsenha);
END;

--============================================================================================--

FUNCTION EXEC_FUNCAO (P_FUNCAO IN VARCHAR2) RETURN BOOLEAN IS
   vretorno NUMBER;
   vcomando VARCHAR2(2000);
   vcid     NUMBER;
   vret     NUMBER;

BEGIN
	vmsg_ind := 30; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   vcomando := 'BEGIN :retorno := '|| P_FUNCAO ||'; END;';
   vcid := DBMS_SQL.OPEN_CURSOR;
   DBMS_SQL.PARSE(vcid, vcomando, DBMS_SQL.NATIVE);
   DBMS_SQL.BIND_VARIABLE(vcid,':retorno',vretorno);
   vret := DBMS_SQL.EXECUTE(vcid);
   DBMS_SQL.VARIABLE_VALUE(vcid,':retorno',vretorno);
   DBMS_SQL.CLOSE_CURSOR(vcid);

	vmsg_ind := 31; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;

   IF vretorno = 0 THEN
      RETURN(FALSE);
   ELSE
      RETURN(TRUE);
   END IF;

END;

--============================================================================================--

FUNCTION GET_SENHA_BANCO (P_USUARIO IN VARCHAR2) RETURN VARCHAR2 IS
   vsenha      VARCHAR2(30) := NULL;

   -- Variaveis temporarias para uso na chamada da rotina
   -- GET_SENHA_REGISTRADA
   vsid_tmp    NUMBER := NULL;
   vserial_tmp NUMBER := NULL;

BEGIN
   vmsg_ind := 32; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   vsenha   := GET_SENHA_REGISTRADA(p_usuario, vsid_tmp, vserial_tmp);

   RETURN(DESCRIPTOGRAFA(vsenha));
END;

--============================================================================================--

PROCEDURE SET_DADOS_SESSAO (P_USER_BANCO  IN VARCHAR2,
                            P_SENHA_BANCO IN VARCHAR2,
                            P_SENHA_PF    IN VARCHAR2,
                            P_PFIS_NUMERO IN NUMBER DEFAULT NULL,
                            P_EMPRESA     IN NUMBER DEFAULT NULL,
                            P_MATRICULA   IN NUMBER DEFAULT NULL,
                            P_CONTRATO    IN NUMBER DEFAULT NULL
                            ) IS
   vsenha_cript VARCHAR2(100);

BEGIN
   vmsg_ind := 33; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;

   DBMS_APPLICATION_INFO.SET_CLIENT_INFO(ARHP8200.CRIPTOGRAFA_SENHA(P_SENHA_BANCO));

   vsenha_cript := ARHP8200.CRIPTOGRAFA_SENHA(p_senha_pf);

   vmsg_ind := 34; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;

   IF (NOT ARHP8040.CRIA_CONTEXTO(p_pfis_numero,
                                  p_empresa,
                                  p_matricula,
                                  p_contrato,
                                  vsenha_cript,
                                  p_user_banco)) THEN
      RAISE_APPLICATION_ERROR(-20020,'Erro na geracao do contexto: '|| SQLERRM);
   END IF;
END;

--============================================================================================--

FUNCTION SENHA_EXPIRADA (P_PFIS_NUMERO IN NUMBER) RETURN BOOLEAN IS
   vind_senha_expirada  pessoas_fisicas.ind_senha_expirada%TYPE;
BEGIN
   vmsg_ind := 35; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   BEGIN
      SELECT
         ind_senha_expirada
      INTO
         vind_senha_expirada
      FROM
         pessoas_fisicas
      WHERE
         numero = p_pfis_numero;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         vind_senha_expirada := 'N';
   END;
   IF vind_senha_expirada = 'S' THEN
      RETURN(TRUE);
   ELSE
      RETURN(FALSE);
   END IF;
END;

--============================================================================================--

FUNCTION SENHA_BLOQUEADA (P_PFIS_NUMERO IN NUMBER) RETURN BOOLEAN IS
   vind_senha_bloqueada pessoas_fisicas.ind_senha_bloqueada%TYPE;

BEGIN
   vmsg_ind := 36; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   BEGIN
      SELECT
         ind_senha_bloqueada
      INTO
         vind_senha_bloqueada
      FROM
         pessoas_fisicas
      WHERE
         numero = p_pfis_numero;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         vind_senha_bloqueada := 'N';
   END;
   IF vind_senha_bloqueada = 'S' THEN
      RETURN(TRUE);
   ELSE
      RETURN(FALSE);
   END IF;
END;

--============================================================================================--

PROCEDURE BLOQUEIA_SECAO_CRITICA(P_NOME_BLOCK VARCHAR2) IS
BEGIN
    vmsg_ind := 37; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
    BEGIN
       DBMS_LOCK.ALLOCATE_UNIQUE(P_NOME_BLOCK,vlckhandle,vlckwait);
    EXCEPTION
    WHEN OTHERS THEN
       RAISE_APPLICATION_ERROR(-20108,'Falha ao obter identificador de bloqueio, nomeado como '||
                                      P_NOME_BLOCK||'.'||CHR(10)||SQLERRM);
    END;
    vmsg_ind := 38; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
    BEGIN
       vlckret  := DBMS_LOCK.REQUEST(vlckhandle, DBMS_LOCK.X_MODE, vlckreqwait);
    EXCEPTION
    WHEN OTHERS THEN
       RAISE_APPLICATION_ERROR(-20109,'Falha ao requisitar bloqueio exclusivo do identificador '||
                                      P_NOME_BLOCK||'.'||CHR(10)||SQLERRM);
    END;
END;

--============================================================================================--

PROCEDURE LIBERA_SECAO_CRITICA IS
BEGIN
   vmsg_ind := 39; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   IF (vlckhandle IS NOT NULL) THEN
      vmsg_ind := 40; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
      BEGIN
         vlckret := DBMS_LOCK.RELEASE(vlckhandle);
      EXCEPTION
      WHEN OTHERS THEN
         RAISE_APPLICATION_ERROR(-20110,'Falha ao liberar bloqueio exclusivo, identificado como '||
                                        TO_CHAR(vlckhandle)||'.'||CHR(10)||SQLERRM);
      END;
   END IF;
END;

--============================================================================================--
-- Esta rotina se destina a retornar o criptograma que representa a senha do usuario
-- de banco de dados e permite que outras rotinas deste package utilizem os mesma
-- consulta para recuperar a senha criptografada na v$session
-- Esta rotina e utilizada por:
--  * ALTERA_SENHA
--  * GET_INFO_CONEXAO
--  * GET_SENHA_BANCO
FUNCTION GET_SENHA_REGISTRADA(p_usuario IN VARCHAR2,
                              p_sid     IN OUT NUMBER,
                              p_serial  IN OUT NUMBER) RETURN VARCHAR2 IS

   vsenha_registrada VARCHAR2(30)  := NULL;
   vnumrows          INTEGER       := 1;
   vprogram          VARCHAR2(7)   := 'FRMWEB%';
   vurhprefix        VARCHAR2(5)   := 'URHCA';
   vCmdSQL           VARCHAR2(512) := NULL;
   vTabSession       VARCHAR2(30)  := NULL;
BEGIN
   BEGIN
      -- O marcador URHCA e adicionado a nova senha na rotina
      -- ARHL002.CONEXAO_SISTEMA. O objetivo identificar e recuperar
      -- apenas registros na V$SESSION que tenham esse marcador.
      -- Recupera informacao da coluna CLIENT_INFO, eliminando o marcardor
      -- atraves da funcao SUBSTR para recuperar apenas o critograma
      -- da senha do usuario de banco.
      vmsg_ind := 41; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;

      IF DBMS_UTILITY.IS_CLUSTER_DATABASE THEN
         -- Se o ambiente roda em Oracle RAC, utiliza a VG$SESSION
         -- para recuperar informacao do usuario administrado pelo
         -- UNIVERSALRH.
         vTabSession := '  gv$session';
      ELSE
         -- Se o ambiente roda em Oracle standalone, utiliza a V$SESSION
         -- para recuperar informacao do usuario administrado pelo
         -- UNIVERSALRH.
         vTabSession := '  v$session';
      END IF;

      vmsg_ind := 42; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
      vCmdSQL := 'SELECT '||CHR(10)||
                 '  SUBSTR(sess.client_info,6),'||CHR(10)||
                 '  sess.sid,'||CHR(10)||
                 '  sess.serial# '||CHR(10)||
                 'FROM '||vTabSession||' sess '||CHR(10)||
                 'WHERE '||CHR(10)||
                 '  ROWNUM = :1 AND '||CHR(10)||
                 '  sess.username = UPPER(:2) AND '||CHR(10)||
                 '  UPPER(sess.program) LIKE :3  AND '||CHR(10)||
                 '  INSTR(sess.client_info,:4) > 0';

      vmsg_ind := 43; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
      EXECUTE IMMEDIATE vCmdSQL
      INTO
         vsenha_registrada,
         p_sid,
         p_serial
      USING
      IN vnumrows,
      IN p_usuario,
      IN vprogram,
      IN vurhprefix;

   EXCEPTION
   WHEN NO_DATA_FOUND THEN
      vmsg_ind := 44; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
      vsenha_registrada := NULL;
   END;

   vmsg_ind := 45; IF vativa_trace THEN DBMS_OUTPUT.PUT_LINE(vmsg_ind); END IF;
   RETURN vsenha_registrada;
END;

--============================================================================================--
-- GET_SID e GET_SERIAL: Funcoes criadas para determinar o id da sessao de banco retornada
-- pela rotina ALTERA SENHA.
-- Essas informacoes serao utilizadas pela rotina ARHL002.CONEXAO_SISTEMA
---
FUNCTION GET_SID    RETURN NUMBER IS
BEGIN
   RETURN vsid;
END;

--============================================================================================--

FUNCTION GET_SERIAL RETURN NUMBER IS
BEGIN
   RETURN vserial;
END;

--============================================================================================--
BEGIN
   NULL;
END;


/
--------------------------------------------------------
--  DDL for Package Body MD_META
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "OSMUNDO"."MD_META" AS

    multiplier constant number  := 22695477;
    increment  constant number  := 1;
    "2^32"     constant number  := 2 ** 32;
    "2^16"     constant number  := 2 ** 16;
    "0x7fff"   constant number  := 32767;
    Seed       number := 1;
    g_curr_val NUMBER DEFAULT NULL;
/*
 * Get the next available id for objectids.
 * @return the next id that can be used in objectid fields
 * This code is taken from wwv_flows
 */
FUNCTION get_next_id RETURN NUMBER
IS
BEGIN
/*
	select  to_number(
                 to_char(dbobjectid_sequence.nextval) ||
                      lpad( substr( abs(rand), 1, 5 ),5, '0' ) ||
                   ltrim(to_char(mod(abs(hsecs),1000000),'000000')))
    into    g_curr_val
    from   sys.v_$timer;

	select to_number(
				to_char(dbobjectid_sequence.nextval) ||
					lpad( substr( abs(rand), 1, 5 ), 5, '0') ||
				ltrim(to_char(mod(dbms_random.value(100000000000, 999999999999),1000000),'000000')))
    into    g_curr_val
	from dual;				
*/
	select dbobjectid_sequence.nextval
    into    g_curr_val
	from dual;	
    return g_curr_val;
END get_next_id;
-- Following code taken from wwv_flows_random 
 procedure srand( new_seed in number ) is
 begin
  Seed := new_seed;
 end srand;
--
  function rand return number is
    s number;
  begin
    seed := mod( multiplier * seed + increment, "2^32" );
    begin
       return bitand( seed/"2^16", "0x7fff" );
    --mhichwa
    exception when others then
       select dbobjectid_sequence.nextval into s from dual;
       return s||to_char(sysdate,'HH24MISS');
    end;
  end rand;
--
  procedure get_rand( r OUT number ) is
  begin
    r := rand;
  end get_rand;
--
  function rand_max( n IN number ) return number is
  begin
    return mod( rand, n ) + 1;
  end rand_max;
--
  procedure get_rand_max( r OUT number, n IN number )  is
  begin
    r := rand_max( n );
  end get_rand_max;
  
 FUNCTION quote(catalog IN VARCHAR2, schema IN VARCHAR2, object IN VARCHAR2, connid LONG ) RETURN VARCHAR2
  AS
  v_plugin VARCHAR2(1000);
  v_result VARCHAR2(4000) :='';
  v_ldelim VARCHAR2(1);
  v_rdelim VARCHAR2(1);
  v_isCatalogRequired BOOLEAN;
  v_isSchemaRequired BOOLEAN;
  v_maxCharsToDelim INT;
  BEGIN
  -- get database type using connid
   SELECT lower(VALUE) 
   INTO v_plugin
   FROM MD_ADDITIONAL_PROPERTIES
   WHERE LOWER(PROP_KEY) = 'plugin_id'
   AND connection_id_fk = connid;
    
    -- get the delimeter
    IF      v_plugin like '%sybase12%'   THEN
            v_ldelim := '[';
            v_rdelim := ']';     
            v_isCatalogRequired := true;
            v_isSchemaRequired := true;
            v_maxCharsToDelim := 28;
    ELSIF   v_plugin like '%sybase%'   THEN
            v_ldelim := '[';
            v_rdelim := ']';     
            v_isCatalogRequired := true;
            v_isSchemaRequired := true;    
            v_maxCharsToDelim := 300;
    ELSIF   v_plugin like '%sqlserver%' THEN 
            v_ldelim := '[';
            v_rdelim := ']';    
            v_isCatalogRequired := true;
            v_isSchemaRequired := true;
            v_maxCharsToDelim := 300;
    ELSIF  v_plugin like '%msaccess%'  THEN
            v_ldelim := '[';
            v_rdelim := ']'; 
            v_isCatalogRequired := false;
            v_isSchemaRequired :=false;
            v_maxCharsToDelim := 300;
    ELSIF v_plugin like '%mysql%'    THEN
            v_ldelim :='`'; 
            v_rdelim :='`';
            v_isCatalogRequired :=false;
            v_isSchemaRequired := true;
            v_maxCharsToDelim := 300;
    ELSIF v_plugin like '%db2%'        THEN
            v_ldelim :='"';
            v_rdelim :='"';
            v_isCatalogRequired := false;
            v_isSchemaRequired := true;
            v_maxCharsToDelim := 300;
    ELSIF v_plugin like '%teradata%'   THEN
            v_ldelim :='"';
            v_rdelim :='"';
            v_isCatalogRequired :=false;
            v_isSchemaRequired := true;
            v_maxCharsToDelim := 300;
    ELSE
            v_ldelim :='[';
            v_rdelim :=']';
            v_isCatalogRequired := true;
            v_isSchemaRequired := true;
            v_maxCharsToDelim := 300;
    END IF;
       
    IF LENGTH(catalog) > v_maxCharsToDelim THEN
      v_result := v_result || catalog ;-- do not quote as it is using the max amount of chars allowed 
    ELSE  
      v_result := v_result || v_ldelim || catalog ||v_rdelim;
    END IF ;
    
    IF LENGTH(schema) > v_maxCharsToDelim THEN
      v_result := v_result || '.' || schema ;-- do not quote as it is using the max amount of chars allowed 
    ELSE  
      v_result := v_result ||'.' || v_ldelim || schema || v_rdelim;
    END IF ;
    
    IF LENGTH(object) > v_maxCharsToDelim THEN
      v_result := v_result ||'.' || object ;-- do not quote as it is using the max amount of chars allowed 
    ELSE  
      v_result := v_result ||'.' || v_ldelim || object ||v_rdelim;
    END IF;      
    
    
   return v_result; 
END quote;  
  
--
-- One time initialisation
begin
  select to_char(sysdate,'JSSSSS')
    into seed
    from dual;
end;

/
--------------------------------------------------------
--  DDL for Package Body MIGRATION
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "OSMUNDO"."MIGRATION" AS
/**
 * The migration package contains all of the PL/SQL Procedures and functions required by the migration
 * system.
 * @author Barry McGillin
 * @author Dermot Daly.
 */
--a.id schema_id, A.name schema_name, b.id catalog_id, B.CATALOG_NAME, 
--B.DUMMY_FLAG, A.type, A.character_set, A.version_tag 
TYPE DERIVATIVE_REC IS RECORD (
     schema_id          NUMBER,
     schema_name        VARCHAR2(4000 BYTE),
     catalog_id         NUMBER,
     catalog_name       VARCHAR2(4000 BYTE),
     dummy_flag         CHAR(1 BYTE),
     cap_type           CHAR(1 BYTE),    
     character_set      VARCHAR2(4000 BYTE),
     version_tag        VARCHAR2(40 BYTE)
     ); 
     
TYPE DERIVATIVE_REC2 IS RECORD (
     schemaid  NUMBER, 
     newid     NUMBER
);     
     
v_prefixName VARCHAR2(4) :=''; --text to prefix objects with ,set using transform_all_identifiers
-- Constants that are used throughout the package body.
C_CONNECTIONTYPE_CONVERTED   CONSTANT MD_CONNECTIONS.TYPE%TYPE := 'CONVERTED';
C_CONNECTIONTYPE_SCRATCH   CONSTANT MD_CONNECTIONS.TYPE%TYPE := 'SCRATCH'; -- enterprise capture/convert
-- Supported object types.
C_OBJECTTYPE_CONNECTIONS     CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_CONNECTIONS';
C_OBJECTTYPE_CATALOGS        CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_CATALOGS';
C_OBJECTTYPE_SCHEMAS         CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_SCHEMAS';
C_OBJECTTYPE_TABLES          CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_TABLES';
C_OBJECTTYPE_COLUMNS         CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_COLUMNS';
C_OBJECTTYPE_CNSTRNT_DETAILS CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_CONSTRAINT_DETAILS';
C_OBJECTTYPE_CONSTRAINTS     CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_CONSTRAINTS';
C_OBJECTTYPE_INDEX_DETAILS   CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_INDEX_DETAILS';
C_OBJECTTYPE_INDEXES         CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_INDEXES';
C_OBJECTTYPE_TRIGGERS        CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_TRIGGERS';
C_OBJECTTYPE_VIEWS           CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_VIEWS';
C_OBJECTTYPE_USERS           CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_USERS';
C_OBJECTTYPE_GROUP_MEMBERS   CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_GROUPMEMBERS';
C_OBJECTTYPE_GROUPS          CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_GROUPS';
C_OBJECTTYPE_OTHER_OBJECTS   CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_OTHER_OBJECTS';
C_OBJECTTYPE_TABLESPACES     CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_TABLESPACES';
C_OBJECTTYPE_UDDT            CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_USER_DEFINED_DATA_TYPES';
C_OBJECTTYPE_STORED_PROGRAMS CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_STORED_PROGRAMS';
C_OBJECTTYPE_PACKAGES        CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_PACKAGES';
C_OBJECTTYPE_SYNONYMS        CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_SYNONYMS';
C_OBJECTTYPE_SEQUENCES       CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_SEQUENCES';
C_OBJECTTYPE_PRIVILEGES      CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_PRIVILEGES';
C_OBJECTTYPE_USER_PRIVILEGES CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_USER_PRIVILEGES';
-- Dummy flag for a dummy catalog.
C_DUMMYFLAG_TRUE             CONSTANT MD_CATALOGS.DUMMY_FLAG%TYPE := 'Y';
-- Flag in MD_DERIVATIVES to show if something has been transformed
C_TRANSFORMED_TRUE           CONSTANT MD_DERIVATIVES.TRANSFORMED%TYPE := 'Y';
-- Flag in MD_SYNONYMS.PRIVATE_VISIBILITY to highlight that a synonym is marked as private
C_SYNONYM_PRIVATE            CONSTANT MD_SYNONYMS.PRIVATE_VISIBILITY%TYPE := 'Y';
-- Flag in MD_GROUPS.GROUP_FLAG to show this is a role
C_ROLE_FLAG                  CONSTANT MD_GROUPS.GROUP_FLAG%TYPE := 'R';
-- Flag in MD_COLUMNS TO SHOW A COLUMN IS NULLABLE
C_NULLABLE_YES               CONSTANT MD_COLUMNS.NULLABLE%TYPE := 'Y';
-- Special defined additional properties.
C_PROPKEY_SEEDVALUE          CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'SEEDVALUE';
C_PROPKEY_INCREMENT          CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'INCREMENT';
C_PROPKEY_LASTVALUE          CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'LASTVALUE';
C_PROPKEY_EXTENDEDINDEXTYPE	 CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'EXTENDEDINDEXTYPE';
C_PROPKEY_SEQUENCEID	       CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'SEQUENCEID';
C_PROPKEY_TRIGGER_REWRITE	   CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'TRIGGER_REWRITE';
-- Name spaces for identifiers
C_NS_SCHEMA_OBJS             CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_SCHEMAOBJS';
C_NS_INDEXES                 CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_INDEXES';
C_NS_CONSTRAINTS             CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_CONSTRAINTS';
C_NS_CLUSTERS                CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_CLUSTERS';
C_NS_DB_TRIGGERS             CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_DB_TRIGGERS';
C_NS_PRIVATE_DBLINKS         CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_PRIVATEDBLINKS';
C_NS_DIMENSIONS              CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_DIMENSIONS';
C_NS_USER_ROLES              CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_USERROLES';
C_NS_PUBLIC_SYNONYMS         CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_PUB_SYNONYMS';
C_NS_PUBLIC_DBLINKS          CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_PUBLICDBLINKS';
C_NS_TABLESPACES             CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_TABLESPACES';
C_NS_PROFILES                CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_PROFILES';
C_NS_DATABASE                CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_DATABASE';
C_NS_USERS                   CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_USERS';
-- Constants for Filter Types
 -- Filter Types are 0-> ALL, 1->NAMELIST, 2->WHERE CLAUSE, 3->OBJECTID LIST
C_FILTERTYPE_ALL	     CONSTANT INTEGER := 0;
C_FILTERTYPE_NAMELIST	     CONSTANT INTEGER := 1;
C_FILTERTYPE_WHERECLAUSE     CONSTANT INTEGER := 2;
C_FILTERTYPE_OBJECTIDLIST    CONSTANT INTEGER := 3;
-- Constatns for TEXT INDEX TYPES
-- see http://download-west.oracle.com/docs/cd/B10501_01/text.920/a96518/csql.htm#19446
-- Use this index type when there is one CLOB or BLOB column in the index only
C_INDEXTYPE_CONTEXT	CONSTANT MD_ADDITIONAL_PROPERTIES.VALUE%TYPE := 'ctxsys.context';
-- Use this index type when the index containst a CLOB or BLOB column.
C_INDEXTYPE_CTXCAT CONSTANT  MD_ADDITIONAL_PROPERTIES.VALUE%TYPE := 'ctxsys.ctxcat';
-- Constant for LANGUAGE - Used in MD_TRIGGERS, MD_PACKAGES, MD_STORED_PROGRAMS, MD_VIEWS, and MD_CONSTRAINTS
C_LANGUAGEID_ORACLE CONSTANT MD_TRIGGERS.LANGUAGE%TYPE := 'OracleSQL';
-- Type for a generic REF CURSOR
TYPE REF_CURSOR IS REF CURSOR;
/**
 * Find a filter element from a filter list
 */
FUNCTION find_filter_for_type(p_filterSet MIGR_FILTER_SET, p_objtype MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE) RETURN MIGR_FILTER
IS
BEGIN
  IF p_filterset is NULL OR p_objtype is NULL then
    return NULL;
  END IF;
  FOR indx in p_filterset.FIRST .. p_filterset.LAST
  LOOP
    if p_filterset(indx).OBJTYPE = p_objtype THEN
      return p_filterset(indx);
    end if;
  END LOOP;
  return NULL;
END find_filter_for_type;

/**
 * Convert a name list from a filter into a condition for use in a where clause.
 * @param p_nameList the set of names that form part of the filter
 * @param p_nameField the name of the field to be compared against.
 * @return A condition that can be used in a where clause.
 */
FUNCTION namelist_to_where_clause(p_nameList NAMELIST, p_nameField VARCHAR2) RETURN VARCHAR2
IS
  v_ret VARCHAR2(4000);
BEGIN
  v_ret := p_nameField || ' IN (';
  FOR indx IN p_nameList.FIRST .. p_nameList.LAST
  LOOP
    v_ret := v_ret || '''' || p_nameList(indx) || '''';
    IF  indx != p_nameList.LAST THEN
      v_ret := v_ret || ', ';
    END IF;
  END LOOP;
  v_ret := v_ret || ')';
  return v_ret;
END namelist_to_where_clause;

/**
 * Convert an object id list from a filter into a condition for use in a where clause.
 * @param p_oidList The list of object ids taken from the filter.
 * @param p_idFIeld The field to be tested against.
 * @return A condition that can be used in a where clause.
 */
FUNCTION objectIdList_to_where_clause(p_oidList OBJECTIDLIST, p_idField VARCHAR2) RETURN VARCHAR2
IS
  v_ret VARCHAR2(4000);
BEGIN
  V_RET := p_idField || ' IN (';
  FOR indx IN p_oidList.FIRST .. p_oidList.LAST
  LOOP
    v_ret := v_ret || TO_CHAR(p_oidList(indx));
    IF indx != p_oidList.LAST THEN
      v_ret := v_ret || ', ';
    END IF;
  END LOOP;
  v_ret := v_ret || ')';
  return v_ret;
END objectIdList_to_where_clause;

/**
 * Convert a filter to a condition for use in a where clause.
 * @param p_filter The filter
 * @param p_nameFileld The name field that will be used in the names list or where clause.
 * @param p_idField The id field that will be used if the filter is an objectid list.
 * @return A condition that could be used in a where clause.  NULL if no additional filtering is required.
 */
FUNCTION where_clause_from_filter(p_filter MIGR_FILTER, p_nameField VARCHAR2, p_idField VARCHAR2) RETURN VARCHAR2
IS
BEGIN
	IF p_filter.FILTER_TYPE = C_FILTERTYPE_ALL THEN
	  RETURN NULL;
    ELSIF p_filter.FILTER_TYPE = C_FILTERTYPE_NAMELIST THEN
      RETURN namelist_to_where_clause(p_filter.NAMES, p_nameField);
    ELSIF p_filter.FILTER_TYPE = C_FILTERTYPE_WHERECLAUSE THEN
	  RETURN p_nameField || ' ' || p_filter.WHERECLAUSE;
    ELSE
	  RETURN objectidlist_to_where_clause(p_filter.OBJECTIDS, p_idField);
	END IF;
END where_clause_from_filter;

/**
 * Apply a filter to an existing select statement
 * @param p_filter_set The filter set.
 * @param p_filter_type The type of the object, for finding in the filter set.
 * @param p_name_field The name field of the table being filtered
 * @param p_id_field The id field of the table being filtered.
 * @param p_select_stmt The select statment to tag the new condition on to
 * @return The select statement with the new condition added to it (or the original statement if
 *         there is no applicable filter for this object type.
 */
FUNCTION apply_filter(p_filter_set MIGR_FILTER_SET,
                      p_filter_type MD_DERIVATIVES.SRC_TYPE%TYPE,
                      p_name_field VARCHAR2,
                      p_id_field VARCHAR2,
                      p_select_stmt VARCHAR2) RETURN VARCHAR2
IS
  v_filt MIGR_FILTER;
  v_condition VARCHAR2(4000);
BEGIN
  v_filt := find_filter_for_type(p_filter_set, p_filter_type);
  --if the filter is null, then we need to set a value that will fail always so nothing is moved.
  -- ie 1=2
  IF v_filt IS NOT NULL THEN
    v_condition := where_clause_from_filter(v_filt, p_name_field, p_id_field);
    IF v_condition IS NOT NULL THEN
      RETURN p_select_stmt || ' AND ' || v_condition;
    ELSE
     RETURN p_select_stmt;
    END IF;
  END IF;
  RETURN p_select_stmt || ' AND 1=2';
END apply_filter;
                      
                      
/**
 * Find the copy of a particular object.  This function checks for a copied object of a particular
 * type by searching the MD_DERIVATIVES table.
 * @param p_objectid The id of the object to search for.
 * @param p_objecttype The type of the object to search for.
 * @return the id of the copy object if it is present, or NULL if it is not.
 */
FUNCTION find_object_copy(p_objectid md_projects.id%TYPE, p_objecttype MD_DERIVATIVES.SRC_TYPE%TYPE, p_derivedconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS 
  v_ret MD_DERIVATIVES.DERIVED_ID%TYPE;
BEGIN
  SELECT derived_id INTO v_ret FROM MD_DERIVATIVES
    WHERE src_id = p_objectid 
     AND src_type = p_objecttype
     AND derived_type = p_objecttype 
     AND derived_connection_id_fk = p_derivedconnectionid;
  RETURN v_ret;
EXCEPTION
  WHEN NO_DATA_FOUND then
    -- Should we raise an error?
    RETURN NULL;
END find_object_copy;

/**
 * Copy additional properties. function copies the additional properties for an object.
 * @param p_refobjectid The object id whose additional properties have to be copied
 * @param p_newrefobject The id of the copied object the new properties should refer to
 * @return number of additional properties copied
 */
FUNCTION copy_additional_properties(p_refobjectid MD_ADDITIONAL_PROPERTIES.REF_ID_FK%TYPE, p_newrefobject MD_PROJECTS.ID%TYPE, p_newconnectionid MD_ADDITIONAL_PROPERTIES.CONNECTION_ID_FK%TYPE) RETURN NUMBER
IS
  CURSOR ORIGINAL_RECS IS SELECT PROPERTY_ORDER, PROP_KEY, REF_TYPE, VALUE FROM MD_ADDITIONAL_PROPERTIES WHERE REF_ID_FK=p_refobjectid;
  v_numcopied NUMBER := 0;
BEGIN
  for newrec in ORIGINAL_RECS LOOP
    INSERT INTO MD_ADDITIONAL_PROPERTIES (ref_id_fk, ref_type, property_order, prop_key, value, connection_id_fk)
      VALUES (p_newrefobject, newrec.ref_type, newrec.property_order, newrec.prop_key, newrec.value, p_newconnectionid);
    v_numcopied := v_numcopied + 1;
  END LOOP;
  commit;
  return v_numcopied;
END copy_additional_properties;

FUNCTION copy_connection(p_connectionid MD_CONNECTIONS.ID%TYPE, p_scratchModel BOOLEAN := FALSE) RETURN NUMBER
IS
  newrec MD_CONNECTIONS%ROWTYPE;
  newid MD_CONNECTIONS.ID%TYPE;
  origName MD_CONNECTIONS.NAME%TYPE;
BEGIN
  SELECT * INTO newrec from MD_CONNECTIONS WHERE id = p_connectionid;

  newrec.HOST := NULL;
  newrec.PORT := NULL;
  newrec.USERNAME := NULL;
  newrec.DBURL := NULL;
  -- TODO.  Need to do this in a more i18n friendly manner.
  origName := newrec.NAME;
  
  IF p_scratchModel = FALSE 
  THEN
     newrec.TYPE :=C_CONNECTIONTYPE_CONVERTED;  
     newrec.NAME := 'Converted:' || newrec.NAME;
  ELSE
     newrec.TYPE :=C_CONNECTIONTYPE_SCRATCH;  
     newrec.NAME := 'Scratch:' || newrec.NAME;     
  END IF;
  -- Let the trigger create the new ID
  newrec.ID := NULL;
  INSERT INTO MD_CONNECTIONS VALUES newrec
  	RETURNING id into newid;
  INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, derived_connection_id_fk, original_identifier, new_identifier)
    VALUES (p_connectionid, C_OBJECTTYPE_CONNECTIONS, newid, C_OBJECTTYPE_CONNECTIONS, newid, origName, newrec.NAME);
  commit;
  return newid;
END copy_connection;


FUNCTION create_dummy_catalog(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  newid MD_CATALOGS.ID%TYPE;
BEGIN
  INSERT INTO MD_CATALOGS (CONNECTION_ID_FK, CATALOG_NAME, DUMMY_FLAG, NATIVE_SQL, NATIVE_KEY)
  VALUES (p_connectionid, ' ', C_DUMMYFLAG_TRUE, NULL, NULL)
  RETURNING ID INTO newid;
  RETURN newid;
END create_dummy_catalog;

FUNCTION find_or_create_dummy_catalog(p_connectionid MD_CONNECTIONS.ID%TYPE, p_catalogid MD_CATALOGS.ID%TYPE) RETURN NUMBER
IS
  newrec MD_CATALOGS%ROWTYPE;
  newid MD_CATALOGS.ID%TYPE;
BEGIN
  SELECT * INTO newrec from MD_CATALOGS where connection_id_fk = p_connectionid and "ID" = p_catalogid;
  return newrec.id;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
  INSERT INTO MD_CATALOGS (CONNECTION_ID_FK, CATALOG_NAME, DUMMY_FLAG, NATIVE_SQL, NATIVE_KEY)
  VALUES (p_connectionid, ' ', C_DUMMYFLAG_TRUE, NULL, NULL)
  RETURNING ID INTO newid;
  INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, derived_connection_id_fk, DERIVED_OBJECT_NAMESPACE)
    VALUES (p_catalogid, C_OBJECTTYPE_CATALOGS, newid, C_OBJECTTYPE_CATALOGS, p_connectionid, C_NS_DATABASE);
  commit;
  return newid;
END find_or_create_dummy_catalog;

-- Enterprise convert may have 1 catalog belonging to a given connection id
PROCEDURE create_dummy_catalogs(p_connectionid MD_CONNECTIONS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_scratchModel BOOLEAN) 
IS
  CURSOR curcats(connId MD_CONNECTIONS.ID%TYPE) IS select * from MD_CATALOGS where connection_id_fk = connId;
  cat_row MD_CATALOGS%ROWTYPE;
  newid MD_CATALOGS."ID"%TYPE;
  v_sql VARCHAR2(300);
BEGIN
   OPEN curcats(p_connectionid);
   FETCH curcats INTO cat_row;  
   LOOP
     EXIT WHEN curcats%NOTFOUND;
     newid := find_or_create_dummy_catalog(p_newconnectionid, cat_row."ID");
     v_sql := 'UPDATE MD_CATALOGS SET CATALOG_NAME = ''' || cat_row."CATALOG_NAME"  || ''' WHERE ID = ' || TO_CHAR(newid);
     EXECUTE IMMEDIATE v_sql;
     FETCH curcats INTO cat_row;  
   END LOOP;
  CLOSE curcats; 
  COMMIT;
END create_dummy_catalogs;


FUNCTION copy_individual_catalog(p_catalogid MD_CATALOGS.ID%TYPE) RETURN NUMBER
IS
  newrec MD_CATALOGS%ROWTYPE;
  newconnectionid MD_CATALOGS.CONNECTION_ID_FK%TYPE;
  dummycatalogid MD_CATALOGS.ID%TYPE;
  originalconnectionid MD_CATALOGS.CONNECTION_ID_FK%TYPE;
BEGIN
  -- Catalogs aren't copied as such. Instead, we make a single DUMMY catalog
  -- Within the new connection
  -- So..first see if one exists for the copied connection
  SELECT CONNECTION_ID_FK INTO originalconnectionid FROM MD_CATALOGS WHERE ID = p_catalogid;
  -- For connections, we have a special case.  We can't store the new connection, but 0 is ok.
  newconnectionid := find_object_copy(originalconnectionid, C_OBJECTTYPE_CONNECTIONS, 0);
  IF newconnectionid IS NULL THEN
    newconnectionid := copy_connection(originalconnectionid);
  END IF;
  dummycatalogid := find_or_create_dummy_catalog(newconnectionid, p_catalogid);
  RETURN dummycatalogid;  
END copy_individual_catalog;

FUNCTION copy_individual_schema(p_schemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  newid MD_SCHEMAS.ID%TYPE;
  newrec MD_SCHEMAS%ROWTYPE;
  newcatalogid MD_CATALOGS.ID%TYPE;
  originalcatalogname MD_CATALOGS.CATALOG_NAME%TYPE;
  originalcatalogid MD_SCHEMAS.CATALOG_ID_FK%TYPE;
  originalschemaname MD_SCHEMAS.NAME%TYPE;
  originalisdummy CHAR;
BEGIN
  SELECT * INTO newrec FROM md_schemas WHERE id = p_schemaid;
  newcatalogid := find_object_copy(newrec.catalog_id_fk,   C_OBJECTTYPE_CATALOGS, p_newconnectionid);
  originalcatalogid := newrec.catalog_id_fk;
  originalschemaname := newrec.NAME;
  select CATALOG_NAME, DUMMY_FLAG into originalcatalogname, originalisdummy from MD_CATALOGS WHERE ID = originalcatalogid;
  IF newcatalogid IS NULL THEN
    newcatalogid := copy_individual_catalog(newrec.catalog_id_fk);
  END IF;

  newrec.catalog_id_fk := newcatalogid;
  if originalisdummy <> C_DUMMYFLAG_TRUE THEN
    newrec.name := originalcatalogname || '_' || newrec.name;
  end if;
  -- Let the trigger work out the new id
  newrec.ID := NULL;
  INSERT INTO MD_SCHEMAS VALUES newrec RETURNING ID INTO newid;
  INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, original_identifier, new_identifier, DERIVED_OBJECT_NAMESPACE)
    VALUES (p_schemaid, C_OBJECTTYPE_SCHEMAS, newid, C_OBJECTTYPE_SCHEMAS, originalschemaname, newrec.name, C_NS_DATABASE);
  INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type)
    VALUES (originalcatalogid, C_OBJECTTYPE_CATALOGS, newid, C_OBJECTTYPE_SCHEMAS);
  COMMIT;
  return newid;
END copy_individual_schema;

FUNCTION copy_individual_table(p_tableid MD_TABLES.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  newrec MD_TABLES%rowtype;
  newid MD_TABLES.ID%TYPE;
  newschemaid MD_SCHEMAS.ID%TYPE;
BEGIN
  SELECT * INTO newrec FROM MD_tables WHERE id = p_tableid;
  newschemaid := find_object_copy(newrec.schema_id_fk,   C_OBJECTTYPE_SCHEMAS, p_newconnectionid);
  IF newschemaid IS NULL THEN
    newschemaid := copy_individual_schema(newrec.schema_id_fk, p_newconnectionid);
  END IF;

  newrec.schema_id_fk := newschemaid;
  -- Let the trigger work out the new id
  newrec.ID := NULL;
  INSERT INTO MD_TABLES VALUES newrec RETURNING ID INTO newid;
  INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, derived_connection_id_fk, original_identifier, new_identifier, DERIVED_OBJECT_NAMESPACE)
    VALUES(p_tableid,   C_OBJECTTYPE_TABLES,   newid,   C_OBJECTTYPE_TABLES, p_newconnectionid, newrec.table_name, newrec.table_name, C_NS_SCHEMA_OBJS || TO_CHAR(newschemaid));
  COMMIT;
  RETURN newid;
END copy_individual_table;

FUNCTION copy_individual_column(p_columnid MD_COLUMNS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  newid MD_COLUMNS.ID%TYPE;
  newrec MD_COLUMNS%rowtype;
  newtableid MD_TABLES.ID%TYPE;
BEGIN
  SELECT * INTO newrec FROM md_columns WHERE id = p_columnid;
  -- TODO: How do I check if this worked?
  -- OK. We need to fix up table id
  newtableid := find_object_copy(newrec.table_id_fk,   C_OBJECTTYPE_TABLES, p_newconnectionid);

  IF newtableid IS NULL THEN
    newtableid := copy_individual_table(newrec.table_id_fk, p_newconnectionid);
  END IF;

  newrec.table_id_fk := newtableid;
  -- Let the trigger work out the new id
  newrec.ID := NULL;
  INSERT INTO md_columns VALUES newrec RETURNING ID INTO newid;
  -- Columns have their own namespace.  They must be unique within the given table.  So..we'll use the table id as the namespace
  INSERT INTO md_derivatives(src_id,   src_type,   derived_id,   derived_type, derived_connection_id_fk, original_identifier, new_identifier, DERIVED_OBJECT_NAMESPACE)
    VALUES(p_columnid,   C_OBJECTTYPE_COLUMNS,   newid,   C_OBJECTTYPE_COLUMNS, p_newconnectionid, newrec.column_name, newrec.column_name, C_OBJECTTYPE_COLUMNS || TO_CHAR(newtableid));
  COMMIT;
  RETURN newid;
END copy_individual_column;

FUNCTION copy_all_tables(p_connectionid MD_CONNECTIONS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR all_tables_cursor is select table_id from mgv_all_tables where connection_id = p_connectionid;
  v_count NUMBER := 0;
  newid MD_TABLES.ID%TYPE;
BEGIN
  FOR v_tableid IN all_tables_cursor LOOP
    newid := copy_individual_table(v_tableid.table_id, p_newconnectionid);
    v_count := v_count + 1;
  END LOOP;
  RETURN v_count;
END copy_all_tables;

FUNCTION copy_all_columns(p_connectionid MD_CONNECTIONS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR all_columns_cursor is select id from MD_COLUMNS where table_id_fk in 
    (select table_id from MGV_ALL_TABLES where connection_id = p_connectionid);
  v_count NUMBER :=0;
  newid MD_COLUMNS.ID%TYPE;
BEGIN
  FOR v_columnid IN all_columns_cursor LOOP
    newid := copy_individual_column(v_columnid.id, p_newconnectionid);
    v_count := v_count + 1;
  END LOOP;
  return v_count;
END copy_all_columns;

FUNCTION copy_constraint_details(p_oldconsid MD_CONSTRAINTS.ID%TYPE, p_newconsid MD_CONSTRAINTS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR curs is SELECT * FROM MD_CONSTRAINT_DETAILS WHERE CONSTRAINT_ID_FK = p_oldconsid;
  v_newid MD_CONSTRAINT_DETAILS.ID%TYPE;
  v_count NUMBER := 0;
  v_originalid MD_CONSTRAINT_DETAILS.ID%TYPE;
  v_ret NUMBER;
BEGIN
  FOR v_row IN curs LOOP
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.COLUMN_ID_FK := find_object_copy(v_row.COLUMN_ID_FK , C_OBJECTTYPE_COLUMNS, p_newconnectionid);
    v_row.CONSTRAINT_ID_FK := p_newconsid;
    INSERT INTO MD_CONSTRAINT_DETAILS values v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- Constraint details don't have an identifier, so don't need a namespace.
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK)
      VALUES(v_originalid, C_OBJECTTYPE_CNSTRNT_DETAILS, v_newid, C_OBJECTTYPE_CNSTRNT_DETAILS, p_newconnectionid);
  END LOOP;
  return v_count;
END copy_constraint_details;

FUNCTION copy_all_constraints_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
   v_selectStmt VARCHAR2(4000) :=     
  'SELECT * FROM MD_CONSTRAINTS WHERE TABLE_ID_FK IN       
    (SELECT SRC_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = ''' || C_OBJECTTYPE_TABLES ||''' AND DERIVED_TYPE = '''
    || C_OBJECTTYPE_TABLES || ''' AND DERIVED_ID IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE SCHEMA_ID = ' || p_newschemaid || '))';
  v_count NUMBER := 0;
  v_newid MD_CONSTRAINTS.ID%TYPE;
  v_originalid MD_CONSTRAINTS.ID%TYPE;
  v_ret NUMBER;
  v_row MD_CONSTRAINTS%ROWTYPE;
  v_storeRefTableId MD_TABLES.ID%TYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_CONSTRAINTS, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.TABLE_ID_FK := find_object_copy(v_row.TABLE_ID_FK , C_OBJECTTYPE_TABLES, p_newconnectionid);
    if v_row.REFTABLE_ID_FK IS NOT NULL THEN
      v_storeRefTableId := v_row.REFTABLE_ID_FK;
      v_row.REFTABLE_ID_FK := find_object_copy(v_row.REFTABLE_ID_FK , C_OBJECTTYPE_TABLES, p_newconnectionid);
    END IF;
    INSERT INTO MD_CONSTRAINTS values v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid, C_OBJECTTYPE_CONSTRAINTS, v_newid, C_OBJECTTYPE_CONSTRAINTS, p_newconnectionid, v_row.NAME, v_row.NAME, C_NS_CONSTRAINTS|| TO_CHAR(p_newschemaid));
    v_ret := copy_constraint_details(v_originalid, v_newid, p_newconnectionid);
  END LOOP;
  CLOSE cv_curs;
  return v_count;    
END copy_all_constraints_cascade;

FUNCTION copy_all_columns_cascade(p_oldtableid MD_TABLES.ID%TYPE, p_newtableid MD_TABLES.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_COLUMNS WHERE TABLE_ID_FK = ' || p_oldtableid;
  v_originalId MD_COLUMNS.ID%TYPE;
  v_newid MD_COLUMNS.ID%TYPE;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_COLUMNS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_COLUMNS, 'COLUMN_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.TABLE_ID_FK := p_newtableid;
    INSERT INTO MD_COLUMNS values  v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- Columns don't need a namespace as such, they must not clash within the table.  We'll handle this
	-- As a special case.
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, original_identifier, new_identifier, DERIVED_OBJECT_NAMESPACE)
    VALUES(v_originalid, C_OBJECTTYPE_COLUMNS, v_newid, C_OBJECTTYPE_COLUMNS, p_newconnectionid, v_row.column_name, v_row.column_name, C_OBJECTTYPE_COLUMNS || TO_CHAR(p_newtableid));
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_columns_cascade;

FUNCTION copy_index_details(p_oldindexid MD_INDEXES.ID%TYPE, p_newindexid MD_INDEXES.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR curs is SELECT * FROM MD_INDEX_DETAILS WHERE MD_INDEX_DETAILS.INDEX_ID_FK = p_oldindexid;
  v_originalid MD_INDEX_DETAILS.ID%TYPE;
  v_newid MD_INDEX_DETAILS.ID%TYPE;
  v_count NUMBER := 0;
  v_ret NUMBER;
BEGIN
  FOR v_row IN CURS LOOP
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.INDEX_ID_FK := p_newindexid;
    v_row.COLUMN_ID_FK := find_object_copy(v_row.COLUMN_ID_FK, C_OBJECTTYPE_COLUMNS, p_newconnectionid);
    INSERT INTO MD_INDEX_DETAILS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- Index details don't have identifiers, so don't need a namespace.
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK)
    VALUES(v_originalid, C_OBJECTTYPE_INDEX_DETAILS, v_newid, C_OBJECTTYPE_INDEX_DETAILS, p_newconnectionid);
  END LOOP;
  RETURN v_count;
END copy_index_details;

FUNCTION copy_all_indexes(p_oldtableid MD_TABLES.ID%TYPE, p_newtableid MD_TABLES.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_filter_set MIGR_FILTER_SET) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_INDEXES WHERE MD_INDEXES.TABLE_ID_FK = ' || p_oldtableid;
  v_originalid MD_INDEXES.ID%TYPE;
  v_newid MD_INDEXES.ID%TYPE;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_INDEXES%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_INDEXES, 'INDEX_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    
    v_row.ID := NULL;
    v_row.TABLE_ID_FK := p_newtableid;
    INSERT INTO MD_INDEXES values v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
    VALUES(v_originalid, C_OBJECTTYPE_INDEXES, v_newid, C_OBJECTTYPE_INDEXES, p_newconnectionid, v_row.INDEX_NAME, v_row.INDEX_NAME, C_NS_INDEXES || p_newschemaid);
    v_ret := copy_index_details(v_originalid, v_newid, p_newconnectionid);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_indexes;

FUNCTION copy_all_table_triggers(p_oldtableid MD_TABLES.ID%TYPE, p_newtableid MD_TABLES.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_TRIGGERS WHERE MD_TRIGGERS.TABLE_OR_VIEW_ID_FK = ' || p_oldtableid;
  v_originalid MD_TRIGGERS.ID%TYPE;
  v_newid MD_TRIGGERS.ID%TYPE;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_TRIGGERS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_TRIGGERS, 'TRIGGER_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.TABLE_OR_VIEW_ID_FK := p_newtableid;
    INSERT INTO MD_TRIGGERS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
    VALUES(v_originalid, C_OBJECTTYPE_TRIGGERS, v_newid, C_OBJECTTYPE_TRIGGERS, p_newconnectionid, v_row.TRIGGER_NAME, v_row.TRIGGER_NAME, C_NS_DB_TRIGGERS);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_table_triggers;

FUNCTION copy_all_tables_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET :=NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  /*CURSOR curs IS SELECT * FROM MD_TABLES where SCHEMA_ID_FK = p_oldschemaid; */
  v_newid MD_TABLES.ID%TYPE := NULL;
  v_originalid MD_TABLES.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_TABLES%ROWTYPE;
  v_filt MIGR_FILTER;
  v_condition VARCHAR2(4000);
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_TABLES where SCHEMA_ID_FK = ' || p_oldschemaid;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_TABLES, 'TABLE_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_TABLES values v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid, C_OBJECTTYPE_TABLES, v_newid, C_OBJECTTYPE_TABLES, p_newconnectionid, v_row.TABLE_NAME, v_row.TABLE_NAME,  C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
    v_ret := copy_all_columns_cascade(v_originalid, v_newid, p_newconnectionid, p_filter_set);
    v_ret := copy_all_indexes(v_originalid, v_newid, p_newconnectionid, p_newschemaid, p_filter_set);
    v_ret := copy_all_table_triggers(v_originalid, v_newid, p_newconnectionid, p_filter_set);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_tables_cascade;

FUNCTION copy_all_view_triggers(p_oldviewid MD_VIEWS.ID%TYPE, p_newviewid MD_VIEWS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR curs IS SELECT * FROM MD_TRIGGERS WHERE MD_TRIGGERS.TABLE_OR_VIEW_ID_FK = p_oldviewid;
  v_originalid MD_TRIGGERS.ID%TYPE;
  v_newid MD_TRIGGERS.ID%TYPE;
  v_count NUMBER := 0;
  v_ret NUMBER;
BEGIN
  FOR v_row IN curs LOOP
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.TABLE_OR_VIEW_ID_FK := p_newviewid;
    INSERT INTO MD_TRIGGERS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
    VALUES(v_originalid, C_OBJECTTYPE_TRIGGERS, v_newid, C_OBJECTTYPE_TRIGGERS, p_newconnectionid, v_row.TRIGGER_NAME, v_row.TRIGGER_NAME, C_NS_DB_TRIGGERS);
  END LOOP;
  return v_count;
END copy_all_view_triggers;

FUNCTION copy_all_views_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_VIEWS WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_VIEWS.ID%TYPE := NULL;
  v_originalid MD_VIEWS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_VIEWS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_VIEWS, 'VIEW_NAME' ,'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs into v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_VIEWS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_VIEWS,   v_newid,   C_OBJECTTYPE_VIEWS, p_newconnectionid, v_row.VIEW_NAME, v_row.VIEW_NAME, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
    v_ret := copy_all_view_triggers(v_originalid, v_newid, p_newconnectionid);
  END LOOP;
  CLOSE cv_curs;
  RETURN v_count;
END copy_all_views_cascade;

FUNCTION copy_group_members(p_oldgroupid MD_GROUPS.ID%TYPE, p_newgroupid MD_GROUPS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR curs IS SELECT * FROM MD_GROUP_MEMBERS WHERE GROUP_ID_FK = p_oldgroupid;
  v_newid MD_GROUP_MEMBERS.ID%TYPE := NULL;
  v_originalid MD_GROUP_MEMBERS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
BEGIN
  FOR v_row IN curs LOOP
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.GROUP_ID_FK := p_newgroupid;
    v_row.USER_ID_FK := find_object_copy(v_row.USER_ID_FK, C_OBJECTTYPE_USERS, p_newconnectionid);
    INSERT INTO MD_GROUP_MEMBERS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- Group members do not have identifiers, so don't need a namespace
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK)
      VALUES(v_originalid,   C_OBJECTTYPE_GROUP_MEMBERS,   v_newid,   C_OBJECTTYPE_GROUP_MEMBERS, p_newconnectionid);
  END LOOP;
  return v_count;
END copy_group_members;

FUNCTION copy_all_groups_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_GROUPS WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_GROUPS.ID%TYPE := NULL;
  v_originalid MD_GROUPS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_namespace MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := NULL;
  v_row MD_GROUPS%ROWTYPE;
  v_catalogname MD_CATALOGS.CATALOG_NAME%TYPE;
  v_catalogdummy MD_CATALOGS.DUMMY_FLAG%TYPE;
  v_oldname MD_GROUPS.GROUP_NAME%TYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_GROUPS, 'GROUP_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    SELECT CATALOG_NAME, DUMMY_FLAG INTO v_catalogname, v_catalogdummy
      FROM MD_CATALOGS, MD_SCHEMAS WHERE MD_CATALOGS.ID = MD_SCHEMAS.CATALOG_ID_FK 
      AND MD_SCHEMAS.ID = p_oldschemaid;
    v_oldname := v_row.GROUP_NAME;
    if v_catalogdummy <> C_DUMMYFLAG_TRUE then
      v_row.GROUP_NAME := v_row.GROUP_NAME || '_' || v_catalogname;
    END IF;
    INSERT INTO MD_GROUPS values v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	IF v_row.GROUP_FLAG = C_ROLE_FLAG THEN
		v_namespace := C_NS_USER_ROLES;
	ELSE
		v_namespace := C_NS_DATABASE;
	END IF;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid, C_OBJECTTYPE_GROUPS, v_newid, C_OBJECTTYPE_GROUPS, p_newconnectionid, v_oldname, v_row.GROUP_NAME, v_namespace);
    v_ret := copy_group_members(v_originalid, v_newid, p_newconnectionid);   
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_groups_cascade;

FUNCTION copy_all_users_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_USERS WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_USERS.ID%TYPE := NULL;
  v_originalid MD_USERS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_USERS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_USERS, 'USERNAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_USERS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_USERS,   v_newid,   C_OBJECTTYPE_USERS, p_newconnectionid, v_row.USERNAME, v_row.USERNAME, C_NS_USERS);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_users_cascade;

FUNCTION copy_all_other_objects_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_OTHER_OBJECTS WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_OTHER_OBJECTS.ID%TYPE := NULL;
  v_originalid MD_OTHER_OBJECTS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_OTHER_OBJECTS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_OTHER_OBJECTS, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_OTHER_OBJECTS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_OTHER_OBJECTS,   v_newid,   C_OBJECTTYPE_OTHER_OBJECTS, p_newconnectionid, v_row.NAME, v_row.NAME, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_other_objects_cascade;

FUNCTION copy_all_tablespaces_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_TABLESPACES WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_TABLESPACES.ID%TYPE := NULL;
  v_originalid MD_TABLESPACES.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_TABLESPACES%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_TABLESPACES, 'TABLESPACE_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_TABLESPACES VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_TABLESPACES,   v_newid,   C_OBJECTTYPE_TABLESPACES, p_newconnectionid, v_row.TABLESPACE_NAME, v_row.TABLESPACE_NAME, C_NS_TABLESPACES);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_tablespaces_cascade;

FUNCTION copy_all_udds_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_USER_DEFINED_DATA_TYPES WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_USER_DEFINED_DATA_TYPES.ID%TYPE := NULL;
  v_originalid MD_USER_DEFINED_DATA_TYPES.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_USER_DEFINED_DATA_TYPES%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_UDDT, 'DATA_TYPE_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_USER_DEFINED_DATA_TYPES VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_UDDT,   v_newid,   C_OBJECTTYPE_UDDT, p_newconnectionid, v_row.DATA_TYPE_NAME, v_row.DATA_TYPE_NAME, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_udds_cascade;

FUNCTION copy_child_procedures(p_oldpackageid MD_PACKAGES.ID%TYPE, p_newpackageid MD_PACKAGES.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_STORED_PROGRAMS WHERE PACKAGE_ID_FK = ' || p_oldpackageid;
  v_newid MD_STORED_PROGRAMS.ID%TYPE := NULL;
  v_originalid MD_STORED_PROGRAMS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_STORED_PROGRAMS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_STORED_PROGRAMS, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.PACKAGE_ID_FK := p_newpackageid;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_STORED_PROGRAMS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- No need for namespace here, the namespace is the package itself.
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
      VALUES(v_originalid,   C_OBJECTTYPE_STORED_PROGRAMS,   v_newid,   C_OBJECTTYPE_STORED_PROGRAMS, p_newconnectionid, v_row.NAME, v_row.NAME);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_child_procedures;
  
FUNCTION copy_all_packages_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_PACKAGES WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_PACKAGES.ID%TYPE := NULL;
  v_originalid MD_PACKAGES.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_PACKAGES%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_PACKAGES, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_PACKAGES VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_PACKAGES,   v_newid,   C_OBJECTTYPE_PACKAGES, p_newconnectionid, v_row.NAME, v_row.NAME, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
    v_ret := copy_child_procedures(v_originalid, v_newid, p_newschemaid, p_newconnectionid, p_filter_set);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_packages_cascade;

FUNCTION copy_all_unpackaged_sps(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_STORED_PROGRAMS WHERE SCHEMA_ID_FK = ' || p_oldschemaid ||' AND PACKAGE_ID_FK IS NULL';
  v_newid MD_STORED_PROGRAMS.ID%TYPE := NULL;
  v_originalid MD_STORED_PROGRAMS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_STORED_PROGRAMS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_STORED_PROGRAMS, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.schema_id_fk := p_newschemaid;
    INSERT INTO MD_STORED_PROGRAMS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- Non-packaged procedures belong in the schema objects namespace.
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid, C_OBJECTTYPE_STORED_PROGRAMS, v_newid, C_OBJECTTYPE_STORED_PROGRAMS, p_newconnectionid, v_row.NAME, v_row.NAME, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_unpackaged_sps;

FUNCTION copy_all_synonyms_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_SYNONYMS WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_SYNONYMS.ID%TYPE := NULL;
  v_originalid MD_SYNONYMS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_namespace MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE;
  v_row MD_SYNONYMS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_SYNONYMS, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SYNONYM_FOR_ID := find_object_copy(v_row.SYNONYM_FOR_ID, v_row.FOR_OBJECT_TYPE, p_newconnectionid);
    INSERT INTO MD_SYNONYMS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- Synonyms have two potential name spaces:  Private synonyms belong in the schema objects, while public 
	-- synonyms belong in their own namespace.
	IF v_row.PRIVATE_VISIBILITY = C_SYNONYM_PRIVATE THEN
		v_namespace := C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid);
	ELSE
		v_namespace := C_NS_PUBLIC_SYNONYMS;
        END IF;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid, C_OBJECTTYPE_SYNONYMS, v_newid, C_OBJECTTYPE_SYNONYMS, p_newconnectionid, v_row.NAME, v_row.NAME, v_namespace);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_synonyms_cascade;

FUNCTION copy_all_sequences_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_SEQUENCES WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_SEQUENCES.ID%TYPE := NULL;
  v_originalid MD_SEQUENCES.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_SEQUENCES%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_SEQUENCES, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    INSERT INTO MD_SEQUENCES VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, derived_connection_id_fk, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid, C_OBJECTTYPE_SEQUENCES, v_newid, C_OBJECTTYPE_SEQUENCES, p_newconnectionid, v_row.NAME, v_row.NAME, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_sequences_cascade;

FUNCTION copy_user_privileges(p_olduserid MD_PRIVILEGES.ID%TYPE, p_newuserid MD_PRIVILEGES.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR curs is SELECT * FROM MD_USER_PRIVILEGES WHERE PRIVILEGE_ID_FK = p_olduserid;
  v_newid MD_USER_PRIVILEGES.ID%TYPE;
  v_count NUMBER := 0;
  v_originalid MD_USER_PRIVILEGES.ID%TYPE;
  v_ret NUMBER;
BEGIN
  FOR v_row IN curs LOOP
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.USER_ID_FK := find_object_copy(v_row.USER_ID_FK , C_OBJECTTYPE_USERS, p_newconnectionid);
    v_row.PRIVILEGE_ID_FK := p_newuserid;
    INSERT INTO MD_USER_PRIVILEGES values v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK)
      VALUES(v_originalid, C_OBJECTTYPE_USER_PRIVILEGES, v_newid, C_OBJECTTYPE_USER_PRIVILEGES, p_newconnectionid);
  END LOOP;
  return v_count;
END copy_user_privileges;

FUNCTION copy_all_privileges_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_PRIVILEGES WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_PRIVILEGES.ID%TYPE := NULL;
  v_originalid MD_PRIVILEGES.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_PRIVILEGES%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_PRIVILEGES, 'PRIVILEGE_NAME' ,'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs into v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.PRIVELEGE_OBJECT_ID := find_object_copy(v_row.PRIVELEGE_OBJECT_ID , v_row.PRIVELEGEOBJECTTYPE, p_newconnectionid);
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_PRIVILEGES VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    -- No need to pass on the identifiers to the derivatives as no need to worry about the clashes for the same.
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_PRIVILEGES,   v_newid,   C_OBJECTTYPE_PRIVILEGES, p_newconnectionid, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
    v_ret := copy_user_privileges(v_originalid, v_newid, p_newconnectionid);
  END LOOP;
  CLOSE cv_curs;
  RETURN v_count;
END copy_all_privileges_cascade;

FUNCTION copy_all_cross_schema_objects(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  v_ret NUMBER;
BEGIN
-- DD; Can't do this until all schema tables are done
-- There may be foreign keys between schema
  v_ret := copy_all_constraints_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_groups_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_other_objects_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_privileges_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  -- Do synonyms last: This way, we can be sure that the oject for which it is a synonym
  -- has already been copied.
  v_ret := copy_all_synonyms_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  return v_ret;
END copy_all_cross_schema_objects;

FUNCTION copy_all_schema_objects(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  v_ret NUMBER;
BEGIN
  v_ret := copy_all_tables_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_views_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_users_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_tablespaces_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_udds_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_packages_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_unpackaged_sps(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_sequences_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  -- TODO: Roles are wrong in the model right now.  I need to fix these up.
  --v_ret := copy_all_roles_cascade(p_oldschemaid, p_newschemaid);
  return v_ret;  
END copy_all_schema_objects;

FUNCTION copy_catalogs_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE, 
                                   p_catalogid MD_CATALOGS.ID%TYPE, 
                                   p_newcatalogid MD_CATALOGS.ID%TYPE, 
                                   p_newconnectionid MD_CONNECTIONS.ID%TYPE, 
                                   p_filter_set MIGR_FILTER_SET :=NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_newid NUMBER;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_newName MD_SCHEMAS.NAME%TYPE;
  v_filt MIGR_FILTER;
  v_selectStmt VARCHAR2(4000) := 'SELECT a.id schema_id, A.name schema_name, b.id catalog_id, B.CATALOG_NAME, B.DUMMY_FLAG, A.type, A.character_set, A.version_tag 
      FROM MD_SCHEMAS A, MD_CATALOGS B
      WHERE 
      	A.CATALOG_ID_FK = B.ID 
        AND B.ID =' || p_catalogid  || 
        ' AND CONNECTION_ID_FK = ' || p_connectionid ;
--  v_schemaid MD_SCHEMAS.ID%TYPE;
--  v_schemaname MD_SCHEMAS.NAME%TYPE;
--  v_catalogid MD_CATALOGS.ID%TYPE;
--  v_catalogname MD_CATALOGS.CATALOG_NAME%TYPE;
--  v_catalogdummy MD_CATALOGS.DUMMY_FLAG%TYPE;
--  v_schematype MD_SCHEMAS.TYPE%TYPE;
--  v_schemacharset MD_SCHEMAS.CHARACTER_SET%TYPE;
--  v_schemaversiontag MD_SCHEMAS.VERSION_TAG%TYPE;
  
  v_derivedRec  DERIVATIVE_REC;
  v_derivedRec2 DERIVATIVE_REC2;
BEGIN
  --v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_CATALOGS, 'B.CATALOG_NAME', 'B.ID', v_selectStmt);
  -- NOTE: May need to apply a schema filter here too
  --v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_SCHEMAS, 'A.NAME', 'A.ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    --FETCH cv_curs INTO v_schemaid, v_schemaname, v_catalogid, v_catalogname, v_catalogdummy, v_schematype, v_schemacharset, v_schemaversiontag;
    FETCH cv_curs INTO v_derivedRec;
    EXIT WHEN cv_curs%NOTFOUND;
    
    /*
     schema_id          NUMBER,
     schema_name        VARCHAR2(4000 BYTE),
     catalog_id         NUMBER,
     catalog_name       VARCHAR2(4000 BYTE),
     dummy_flag         CHAR(1 BYTE),
     character_set      VARCHAR2(4000 BYTE),
     version_tag        VARCHAR2(40 BYTE)
    
    */
    -- TODO: Handle wrapping here.
    if v_derivedRec.dummy_flag  <> C_DUMMYFLAG_TRUE then
      v_newName := v_derivedRec.schema_name || '_' || v_derivedRec.catalog_name;
	else
	  v_newName := v_derivedRec.schema_name;
	end if;
    INSERT INTO MD_SCHEMAS(CATALOG_ID_FK, NAME, TYPE, CHARACTER_SET, VERSION_TAG)
    VALUES (p_newcatalogid,  v_newName, v_derivedRec.cap_type, v_derivedRec.character_set, v_derivedRec.version_tag)
    RETURNING ID INTO v_newid;
    -- Here's and interesting situation.  What will we do with the additional properties?
    -- I can coalesce them such that they are in the condensed catalog/schema pair
    -- But their order could (will) contain duplicates.....
    v_ret := copy_additional_properties(p_catalogid, v_newid, p_newconnectionid);
    v_ret := copy_additional_properties(v_derivedRec.schema_id, v_newid, p_newconnectionid);
	-- No Need for namespace stuff for catalogs.
    INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK,
      ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
    VALUES (v_derivedRec.schema_id, C_OBJECTTYPE_SCHEMAS, v_newid, C_OBJECTTYPE_SCHEMAS, p_newconnectionid, v_derivedRec.schema_name, v_newName);
    INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
    VALUES (v_derivedRec.catalog_id, C_OBJECTTYPE_CATALOGS, v_newid, C_OBJECTTYPE_SCHEMAS, p_newconnectionid, v_derivedRec.catalog_name, v_newName);
    -- TODO: ADD THE FILTER TO THE PARAMETERS BELOW
    v_ret := copy_all_schema_objects(v_derivedRec.schema_id, v_newid, p_newconnectionid, p_filter_set);
    v_count := v_count + 1;
    v_newName :='';
  END LOOP;
  CLOSE cv_curs;
  -- Now...Once all of the schema objects have been done, we have to copy all of those objects that could cross
  -- schema boundaries.  So we need to loop through them again
v_selectStmt := 'SELECT SRC_ID, DERIVED_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = ' 
  					|| '''' || C_OBJECTTYPE_SCHEMAS || ''' AND DERIVED_TYPE = ''' || C_OBJECTTYPE_SCHEMAS ||''''
  					--|| ' AND DERIVED_CONNECTION_ID_FK = ' || p_newconnectionid
                      || ' AND DERIVED_ID IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CATALOG_ID = ' || p_newcatalogid || ' AND CONNECTION_ID = ' || p_newconnectionid || ')';
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs into v_derivedRec2;
    EXIT when cv_curs%NOTFOUND;
    v_ret := copy_all_cross_schema_objects(v_derivedRec2.schemaid, v_derivedRec2.newid, p_newconnectionid, p_filter_set);
  END LOOP;
  CLOSE cv_curs;  					
  return v_count;
END copy_catalogs_cascade;

FUNCTION remove_duplicate_indexes(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR v_curs IS select  index_id_fk, sum(md_index_details.column_id_fk * md_index_details.detail_order) simplehash from md_index_details 
    where index_id_fk in (select id from md_indexes where table_id_fk in (select table_id from mgv_all_tables where connection_id = p_connectionid)) 
    group by index_id_fk
    order by simplehash, index_id_fk;
  v_lasthash NUMBER :=0;
  v_currenthash NUMBER :=0;
  v_currentid MD_INDEX_DETAILS.INDEX_ID_FK%TYPE;
  v_lastid MD_INDEX_DETAILS.INDEX_ID_FK%TYPE;
  v_count NUMBER := 0;
  v_sql VARCHAR(255);
BEGIN
  OPEN v_curs;
  LOOP
    FETCH v_curs into v_currentid, v_currenthash;
    EXIT WHEN v_curs%NOTFOUND;
    if v_currenthash = v_lasthash THEN
      -- dbms_output.put_line('Index ' || TO_CHAR(v_currentid) || ' is a duplicate');
      v_sql := 'DELETE FROM MD_INDEXES WHERE ID = ' || v_currentid;
      EXECUTE IMMEDIATE v_sql;
      --dbms_output.put_line('DELETE FROM MD_INDEXES WHERE ID = ' || v_currentid);
      v_sql := 'UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = ''DUPIND'', DERIVED_ID = ' || TO_CHAR(v_lastid)  || ' WHERE DERIVED_ID = ' || TO_CHAR(v_currentid);
      EXECUTE IMMEDIATE v_sql;
      -- dbms_output.put_line('UPDATE MD_DERIVATIVES SET DERIVED_ID = ' || TO_CHAR(v_lastid)  || ' WHERE DERIVED_ID = ' || TO_CHAR(v_currentid));
      v_count := v_count + 1;
    else
      v_lasthash := v_currenthash;
      v_lastid := v_currentid;
    end if;
  END LOOP;
  CLOSE v_curs;
  return v_count;    
END remove_duplicate_indexes;

FUNCTION remove_indexes_used_elsewhere(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR v_curs IS
    select INDEX_ID_FK from 
      (select  index_id_fk, sum(md_index_details.column_id_fk * md_index_details.detail_order) simplehash from md_index_details 
       where index_id_fk in (select id from md_indexes where table_id_fk in (select table_id from mgv_all_tables where connection_id = p_connectionid)) 
       group by index_id_fk
       order by simplehash) a
    WHERE A.SIMPLEHASH 
    IN
    (
      SELECT b.simplehash FROM 
      (
        SELECT SUM(MD_CONSTRAINT_DETAILS.COLUMN_ID_FK * MD_CONSTRAINT_DETAILS.DETAIL_ORDER) simplehash from md_constraint_details
        where constraint_id_fk in (select id from md_constraints where table_id_fk in (select table_id from mgv_all_tables where connection_id = p_connectionid))
        group by constraint_id_fk
        order by simplehash
      ) b
     );
  v_currentId MD_INDEX_DETAILS.INDEX_ID_FK%TYPE;     
  v_sql VARCHAR2(255);
  v_count NUMBER := 0;
BEGIN
  OPEN v_curs;
  LOOP
    FETCH v_curs into v_currentid;
    EXIT WHEN v_curs%NOTFOUND;
      v_sql := 'DELETE FROM MD_INDEXES WHERE ID = ' || v_currentid;
      EXECUTE IMMEDIATE v_sql;
      --dbms_output.put_line('DELETE FROM MD_INDEXES WHERE ID = ' || v_currentid);
      v_sql := 'DELETE FROM MD_DERIVATIVES WHERE DERIVED_ID = ' || TO_CHAR(v_currentid);
      EXECUTE IMMEDIATE v_sql;
      -- dbms_output.put_line('UPDATE MD_DERIVATIVES SET DERIVED_ID = ' || TO_CHAR(v_lastid)  || ' WHERE DERIVED_ID = ' || TO_CHAR(v_currentid));
      v_count := v_count + 1;
  END LOOP;
  CLOSE v_curs;
  RETURN v_count;
END remove_indexes_used_elsewhere;    

PROCEDURE cut_lob_indexes_to_25(p_connectionId MD_CONNECTIONS.ID%TYPE)
IS
  CURSOR v_curs (context MD_ADDITIONAL_PROPERTIES.VALUE%TYPE, ctxcat MD_ADDITIONAL_PROPERTIES.VALUE%TYPE) is 
    SELECT * FROM MD_INDEXES WHERE 
    TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid)
    AND LENGTH(INDEX_NAME) > 25 AND  
    ( EXISTS (SELECT 1 FROM MD_ADDITIONAL_PROPERTIES WHERE ( VALUE = context 
    OR VALUE = ctxcat ) AND REF_ID_FK = MD_INDEXES.ID ) )
    FOR UPDATE OF INDEX_NAME;
  v_numIndexCount INTEGER := 1;
  v_newName MD_INDEXES.INDEX_NAME%TYPE;
  v_row MD_INDEXES%ROWTYPE;
BEGIN
-- totierne: for each lob index cut to 23 or 22 or 21 to put _XXX up to 25 chars (should be bytes)
  OPEN v_curs (C_INDEXTYPE_CONTEXT, C_INDEXTYPE_CTXCAT);
  LOOP
    FETCH v_curs INTO v_row;
    EXIT WHEN v_curs%NOTFOUND;
    v_newName := MIGRATION_TRANSFORMER.add_suffix(v_row.INDEX_NAME, '_' || TO_CHAR(v_numIndexCount), 25);
    update MD_INDEXES SET index_name = v_newName where current of v_curs;
    v_numIndexCount := v_numIndexCount + 1;
  END LOOP;
  CLOSE v_curs;
  commit;
END cut_lob_indexes_to_25;

FUNCTION fixupTextIndexes(p_connectionId MD_CONNECTIONS.ID%TYPE) return NUMBER
IS
  CURSOR v_curs is
    select index_id_fk, count(*) numcols from md_index_details where
    index_id_fk in (
      select c.id
      from md_columns a, md_index_details b, md_indexes c
      where b.column_id_fk = a.id
      and column_type in ('BLOB', 'CLOB')
      and b.index_id_fk = c.id
      and c.table_id_fk in (select table_id from mgv_all_tables where connection_id = p_connectionid)
    ) group by index_id_fk;
  v_indexId MD_INDEXES.ID%TYPE;
  v_numCols INTEGER;
  v_extendedIndexType MD_ADDITIONAL_PROPERTIES.VALUE%TYPE;
BEGIN        
  OPEN v_curs;
  LOOP
    FETCH v_curs into v_indexId, v_numCols;
    EXIT WHEN v_curs%NOTFOUND;
    IF v_numCols = 1 THEN
      v_extendedIndexType := C_INDEXTYPE_CONTEXT;
    ELSE
      v_extendedIndexType := C_INDEXTYPE_CTXCAT;
    END IF;
    INSERT INTO MD_ADDITIONAL_PROPERTIES(CONNECTION_ID_FK ,REF_ID_FK, REF_TYPE, PROP_KEY, VALUE)
    VALUES (p_connectionId, v_indexId, C_OBJECTTYPE_INDEXES, C_PROPKEY_EXTENDEDINDEXTYPE, v_extendedIndexType);
    COMMIT;
  END LOOP;
  -- NCLOBs cannot be indexed.  They aren't allowed in normal indexes, and they aren't allowed in TEXT 
  -- indexes.   The only thing to do here is to remove it.
  -- TODO: We can't just do this silently.
   -- Mark THE derivative RECORD AS DELETEd.
  UPDATE md_derivatives SET DERIVATIVE_REASON = 'NCLOBIND' WHERE DERIVED_TYPE = 'MD_INDEXES' AND DERIVED_CONNECTION_ID_FK = p_connectionid
      AND  DERIVED_ID IN 
             (SELECT C.ID   FROM MD_COLUMNS A, MD_INDEX_DETAILS B, MD_INDEXES C, MGV_ALL_TABLES D
                 WHERE B.COLUMN_ID_FK = A.ID AND COLUMN_TYPE ='NCLOB' AND B.INDEX_ID_FK = C.ID
                  AND C.TABLE_ID_FK = D.TABLE_ID AND D.CONNECTION_ID = p_connectionid);
  DELETE FROM MD_INDEXES WHERE ID IN
             (SELECT C.ID   FROM MD_COLUMNS A, MD_INDEX_DETAILS B, MD_INDEXES C, MGV_ALL_TABLES D
                 WHERE B.COLUMN_ID_FK = A.ID AND COLUMN_TYPE ='NCLOB' AND B.INDEX_ID_FK = C.ID
                  AND C.TABLE_ID_FK = D.TABLE_ID AND D.CONNECTION_ID = p_connectionid);
  -- cut blob/clob index string to 25 characters with _nn incrementing marker
  cut_lob_indexes_to_25(p_connectionId);
  CLOSE v_curs;
  return 0;
END fixupTextIndexes;

PROCEDURE createDummyScrTblPerSchema_ee(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS                               
  v_qualified_native_name VARCHAR2(300);
  n_newtblid NUMBER;
  tbltrigRec MD_TRIGGERS%ROWTYPE;
  n_newtrigId MD_TRIGGERS."ID"%TYPE;
  origtrigId MD_TRIGGERS."ID"%TYPE;
  CURSOR curtblTrig(schId MD_SCHEMAS."ID"%TYPE) IS SELECT * FROM MD_TRIGGERS 
                                       WHERE TRIGGER_ON_FLAG = 'T'
                                           AND TABLE_OR_VIEW_ID_FK IN (
                                                SELECT "ID" 
                                                FROM MD_TABLES
                                                WHERE SCHEMA_ID_FK = schId);
                                                  
BEGIN
   SELECT A.catalog_name || '.' || B."NAME" || 'DUMMY' INTO v_qualified_native_name
             FROM MD_CATALOGS A, MD_SCHEMAS B
             WHERE A."ID" = B.catalog_id_fk
                   AND B."ID" = schemaId;

   -- insert 1 DUMMY table per schema.  We don't want to create peer records in md_tables for each table entry
   INSERT INTO MD_TABLES(schema_id_fk, table_name, qualified_native_name)
                  VALUES(new_schemaId, 'DUMMY', v_qualified_native_name)
                  RETURNING "ID" INTO n_newtblid;
   -- There is no additional property to copy as this is a dummy table with no src peer
   -- This table is used to attached all the translated triggers
                  
   -- insert corresponding row into md_derivatives
   INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK,
               ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
                   VALUES (n_newtblid, C_OBJECTTYPE_TABLES, n_newtblId, C_OBJECTTYPE_TABLES, p_scratchConn, 'DUMMY', 'DUMMY');  
                   
   --copy_all_tbl_trigs_ee
   OPEN curtblTrig(schemaId);
   FETCH curtblTrig INTO tbltrigRec;
   LOOP
      EXIT WHEN curtblTrig%NOTFOUND;
      origtrigId := tbltrigRec."ID";
      tbltrigRec."ID" := NULL;
      tbltrigRec.table_or_view_id_fk := n_newtblid;
      INSERT INTO MD_TRIGGERS VALUES tbltrigRec RETURNING "ID" INTO n_newtrigId;

      -- insert corresponding row into md_derivatives
      INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK,
               ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
                   VALUES (origtrigId, C_OBJECTTYPE_TRIGGERS, n_newtrigId, C_OBJECTTYPE_TRIGGERS, p_scratchConn, tbltrigRec.TRIGGER_NAME, tbltrigRec.TRIGGER_NAME);  

      
      FETCH curtblTrig INTO tbltrigRec;
   END LOOP;
   CLOSE curtblTrig;
                                     
END createDummyScrTblPerSchema_ee;

PROCEDURE copy_all_views_ee(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS                         
   CURSOR curViews(schId MD_SCHEMAS."ID"%TYPE) IS SELECT * FROM MD_VIEWS WHERE SCHEMA_ID_FK = schId;
   viewRec MD_VIEWS%ROWTYPE;
   n_newVwid MD_VIEWS."ID"%TYPE;
   norigVwid MD_VIEWS."ID"%TYPE;
   n_ret NUMBER;
   
  vwtrigRec MD_TRIGGERS%ROWTYPE;
  n_newtrigId MD_TRIGGERS."ID"%TYPE;
  origtrigId MD_TRIGGERS."ID"%TYPE;
  CURSOR curvwTrig(schId MD_SCHEMAS."ID"%TYPE) IS SELECT * FROM MD_TRIGGERS 
                                       WHERE TRIGGER_ON_FLAG = 'V'
                                           AND TABLE_OR_VIEW_ID_FK IN (
                                                SELECT "ID" 
                                                FROM MD_TABLES
                                                WHERE SCHEMA_ID_FK = schId);   
BEGIN
   OPEN curViews(schemaId);
   FETCH curViews INTO viewRec;
   LOOP
      EXIT WHEN curViews%NOTFOUND;
      norigVwid := viewRec."ID";
      viewRec."ID" := NULL;
      viewRec.SCHEMA_ID_FK := new_schemaId;
      INSERT INTO MD_VIEWS VALUES viewRec RETURNING "ID" INTO n_newVwId;
      n_ret := copy_additional_properties(viewRec."ID", n_newVwId, p_scratchConn);
      
      INSERT INTO MD_DERIVATIVES(src_id, 
                                 src_type, 
                                 derived_id, 
                                 derived_type, 
                                 DERIVED_CONNECTION_ID_FK, 
                                 ORIGINAL_IDENTIFIER, 
                                 NEW_IDENTIFIER, 
                                 DERIVED_OBJECT_NAMESPACE)
                           VALUES(norigVwid,   
                                  C_OBJECTTYPE_VIEWS,   
                                  n_newVwId,   
                                  C_OBJECTTYPE_VIEWS, 
                                  p_scratchConn, viewRec.VIEW_NAME, viewRec.VIEW_NAME, C_NS_SCHEMA_OBJS || TO_CHAR(new_schemaId));
                                  
      -- Handle view triggers
      OPEN curvwTrig(schemaId);
      FETCH curvwTrig INTO vwtrigRec;
      LOOP
         EXIT WHEN curvwTrig%NOTFOUND;
         origtrigId := vwtrigRec."ID";
         vwtrigRec."ID" := NULL;
         vwtrigRec.table_or_view_id_fk := n_newVwId;
         
         INSERT INTO MD_TRIGGERS VALUES vwtrigRec RETURNING "ID" INTO n_newtrigId;
         
         INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK,
               ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
                   VALUES (origtrigId, C_OBJECTTYPE_TRIGGERS, n_newtrigId, C_OBJECTTYPE_TRIGGERS, p_scratchConn, vwtrigRec.TRIGGER_NAME, vwtrigRec.TRIGGER_NAME);           
         
         FETCH curvwTrig INTO vwtrigRec;         
      END LOOP; -- end vw trigger loop
      CLOSE curvwTrig;
      
      FETCH curViews INTO viewRec;
      --copy_all_tbl_trigs_ee      
   END LOOP; -- end vw loop
   CLOSE curViews;
END copy_all_views_ee;

PROCEDURE copy_all_unpackaged_sps_ee(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS              
   CURSOR curSps(schId MD_SCHEMAS."ID"%TYPE) IS SELECT * FROM MD_STORED_PROGRAMS WHERE SCHEMA_ID_FK = schId;
   spRec MD_STORED_PROGRAMS%ROWTYPE;
   n_newSpid MD_STORED_PROGRAMS."ID"%TYPE;
   norigSpid MD_STORED_PROGRAMS."ID"%TYPE;
   n_ret NUMBER;
BEGIN
   OPEN curSps(schemaId);
   FETCH curSps INTO spRec;
   LOOP
      EXIT WHEN curSps%NOTFOUND;
      norigSpid := spRec."ID";
      spRec."ID" := NULL;
      spRec.schema_id_fk := new_schemaId;

      INSERT INTO MD_STORED_PROGRAMS VALUES spRec RETURNING "ID" INTO n_newSpid;
      n_ret := copy_additional_properties(spRec."ID", n_newSpid, p_scratchConn);
      
      INSERT INTO MD_DERIVATIVES(src_id, 
                                 src_type, 
                                 derived_id, 
                                 derived_type, 
                                 DERIVED_CONNECTION_ID_FK, 
                                 ORIGINAL_IDENTIFIER, 
                                 NEW_IDENTIFIER, 
                                 DERIVED_OBJECT_NAMESPACE)
                           VALUES(norigSpid,   
                                  C_OBJECTTYPE_STORED_PROGRAMS,   
                                  n_newSpid,   
                                  C_OBJECTTYPE_STORED_PROGRAMS, 
                                  p_scratchConn, spRec."NAME", spRec."NAME", C_NS_SCHEMA_OBJS || TO_CHAR(new_schemaId));
      FETCH curSps INTO spRec;
   END LOOP;
   CLOSE curSps;
END copy_all_unpackaged_sps_ee;

PROCEDURE copy_all_tbl_trigs_ee(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS                                 
BEGIN
   NULL;
END copy_all_tbl_trigs_ee;

PROCEDURE copy_all_vw_trigs_ee(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS                                 
BEGIN
   NULL;
END copy_all_vw_trigs_ee;

PROCEDURE createIndexEntry(tableId MD_TABLES."ID"%TYPE, 
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS
   CURSOR curIndexes(tableId MD_TABLES."ID"%TYPE) IS SELECT * FROM md_indexes WHERE table_id_fk = tableId;
   idxRow MD_INDEXES%ROWTYPE;

BEGIN
   OPEN curIndexes(tableId);
   FETCH curIndexes INTO idxRow;
   
   LOOP
      EXIT WHEN curIndexes%NOTFOUND;

      INSERT INTO MD_DERIVATIVES(src_id, 
                                 src_type, 
                                 derived_id, 
                                 derived_type, 
                                 DERIVED_CONNECTION_ID_FK, 
                                 ORIGINAL_IDENTIFIER, 
                                 NEW_IDENTIFIER, 
                                 DERIVED_OBJECT_NAMESPACE)
                           VALUES
                           (
                              idxRow."ID",
                              C_OBJECTTYPE_INDEXES,
                              idxRow."ID",
                              'MD_INDEXES',
                              p_scratchConn,
                              idxRow.index_name,
                              idxRow.index_name,
                              C_OBJECTTYPE_INDEXES || TO_CHAR(tableId)         
                           );      
      FETCH curIndexes INTO idxRow;
   END LOOP;
   CLOSE curIndexes;

END;

PROCEDURE createColumnEntry(tableId MD_TABLES."ID"%TYPE, 
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS
   CURSOR curColumns(tableId MD_TABLES."ID"%TYPE) IS SELECT * FROM md_columns WHERE table_id_fk = tableId;
   colRow MD_COLUMNS%ROWTYPE;
BEGIN
   OPEN curColumns(tableId);
   FETCH curColumns INTO colRow;
   
   LOOP
      EXIT WHEN curColumns%NOTFOUND;

      INSERT INTO MD_DERIVATIVES(src_id, 
                                 src_type, 
                                 derived_id, 
                                 derived_type, 
                                 DERIVED_CONNECTION_ID_FK, 
                                 ORIGINAL_IDENTIFIER, 
                                 NEW_IDENTIFIER, 
                                 DERIVED_OBJECT_NAMESPACE)
                           VALUES
                           (
                              colRow."ID",
                              C_OBJECTTYPE_COLUMNS,
                              colRow."ID",
                              'MD_COLUMNS',
                              p_scratchConn,
                              colRow.column_name,
                              colRow.column_name,
                              C_OBJECTTYPE_COLUMNS || TO_CHAR(tableId)         
                           );      
      FETCH curColumns INTO colRow;
   END LOOP;
   CLOSE curColumns;
END;


PROCEDURE createTableEntry(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS
   CURSOR curTables(schemaId MD_SCHEMAS."ID"%TYPE) IS SELECT * FROM md_tables WHERE schema_id_fk = schemaId;
   tblRow MD_TABLES%ROWTYPE;
BEGIN
   OPEN curTables(schemaId);
   FETCH curTables INTO tblRow;
   
   LOOP
      EXIT WHEN curTables%NOTFOUND;
      
      INSERT INTO MD_DERIVATIVES(src_id, 
                                 src_type, 
                                 derived_id, 
                                 derived_type, 
                                 DERIVED_CONNECTION_ID_FK, 
                                 ORIGINAL_IDENTIFIER, 
                                 NEW_IDENTIFIER, 
                                 DERIVED_OBJECT_NAMESPACE)
                           VALUES
                           (
                              tblRow."ID",
                              C_OBJECTTYPE_TABLES,
                              tblRow."ID",
                              'MD_TABLES',
                              p_scratchConn,
                              tblRow.table_name,
                              tblRow.table_name,
                              C_NS_SCHEMA_OBJS || TO_CHAR(new_schemaid)         
                           );      
      createColumnEntry(tblRow."ID", p_scratchConn);      
      createIndexEntry(tblRow."ID", p_scratchConn);      
      FETCH curTables INTO tblRow;
   END LOOP;
   CLOSE curTables;
END;
    
    
PROCEDURE createConstraintEntry(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS
BEGIN
   NULL;
END;


PROCEDURE copy_schema_objects_ee(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS                                 
BEGIN
    --This create scratch model for table triggers as well
    createDummyScrTblPerSchema_ee(schemaId,   
                                 new_schemaId,
                                 p_scratchConn);
    -- Make md_derivatives entry only for the following objects -- begin 
    createTableEntry(schemaId, new_schemaId, p_scratchConn);
    createConstraintEntry(schemaId, new_schemaId, p_scratchConn);    
    -- Make md_derivatives entry only for the following objects -- end
    
    --This create scratch model for view triggers as well                                 
    copy_all_views_ee(schemaId, 
                   new_schemaId,
                   p_scratchConn);
                   
    copy_all_unpackaged_sps_ee(schemaId, 
                 new_schemaId,
                 p_scratchConn);                                    
END copy_schema_objects_ee;

-- p_connectionid -- scratch model connection id
PROCEDURE copy_catalogs_cascade_ee(p_connectionid MD_CONNECTIONS.ID%TYPE)
IS
   CURSOR curDerivatives(conId MD_CONNECTIONS."ID"%TYPE) IS
                SELECT *
                       FROM MD_DERIVATIVES 
                       WHERE DERIVED_CONNECTION_ID_FK = conId
                       AND SRC_TYPE = C_OBJECTTYPE_CATALOGS;
   recDerived MD_DERIVATIVES%ROWTYPE;
   
   CURSOR curSchemas(catId MD_SCHEMAS.CATALOG_ID_FK%TYPE) IS
                SELECT * FROM MD_SCHEMAS WHERE CATALOG_ID_FK = catId;
   recSchema MD_SCHEMAS%ROWTYPE;
   
   ncatId MD_SCHEMAS.CATALOG_ID_FK%TYPE;
   n_newschId MD_SCHEMAS."ID"%TYPE;
   v_ret NUMBER;
   v_catalogdummy MD_CATALOGS.DUMMY_FLAG%TYPE;
   v_catalogname VARCHAR2(300);
   v_newName VARCHAR2(300); 
BEGIN
   OPEN curDerivatives(p_connectionid);
   FETCH curDerivatives INTO recDerived;
   LOOP -- for each of the catalog process its schemas
      EXIT WHEN curDerivatives%NOTFOUND;
      SELECT dummy_flag, catalog_name INTO v_catalogdummy, v_catalogname FROM MD_CATALOGS WHERE "ID" = recDerived.src_id;
      ncatId := recDerived.src_id;
      OPEN curSchemas(ncatId);
      FETCH curSchemas INTO recSchema;
      LOOP
         EXIT WHEN curSchemas%NOTFOUND;
         
         v_newName := recSchema."NAME" || '_' || v_catalogname;
         
         INSERT INTO MD_SCHEMAS(CATALOG_ID_FK, "NAME", "TYPE", CHARACTER_SET, VERSION_TAG)
                          VALUES (recDerived.derived_id, 
                                  v_newName, 
                                  recSchema."TYPE",
                                  recSchema.CHARACTER_SET, 
                                  recSchema.VERSION_TAG)
                          RETURNING "ID" INTO n_newschId;
         v_ret := copy_additional_properties(ncatId, n_newschId, p_connectionid);                          
         v_ret := copy_additional_properties(recSchema."ID", n_newschId, p_connectionid);
         
	       -- No Need for namespace stuff for catalogs.
         INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK,
               ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
                   VALUES (recSchema."ID", C_OBJECTTYPE_SCHEMAS, n_newschId, C_OBJECTTYPE_SCHEMAS, p_connectionid, recSchema."NAME", v_newName);
    
         INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
                   VALUES (recDerived.src_id, C_OBJECTTYPE_CATALOGS, n_newschId, C_OBJECTTYPE_SCHEMAS, p_connectionid, v_catalogname, v_newName);         
                   
         copy_schema_objects_ee(recSchema."ID", n_newschId, p_connectionId);
         FETCH curSchemas INTO recSchema;
      END LOOP; -- end schema loop
      CLOSE curSchemas;
      
      FETCH curDerivatives INTO recDerived;
   END LOOP;  -- end catalog loop
   CLOSE curDerivatives;
END copy_catalogs_cascade_ee;

FUNCTION copy_connection_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL, p_scratchModel BOOLEAN := FALSE) RETURN NUMBER
IS
  v_newConnectionId MD_CONNECTIONS.ID%TYPE;
  v_numProps NUMBER;
  v_catalogId MD_CATALOGS.ID%TYPE;
  v_catalogName MD_CATALOGS.CATALOG_NAME%TYPE;
  v_numCatalogs NUMBER;
  v_numDuplicateIndexes NUMBER;
  v_sql VARCHAR(255);   
  
  CURSOR curDerivatives(conId MD_CONNECTIONS."ID"%TYPE) IS
                SELECT distinct 
                           id,
                           src_id,
                           src_type,
                           derived_id,
                           derived_type,
                           derived_connection_id_fk,
                           transformed,
                           original_identifier,
                           new_identifier,
                           derived_object_namespace,
                           derivative_reason,
                           security_group_id,
                           created_on,
                           created_by,
                           last_updated_on,
                           last_updated_by
                       FROM MD_DERIVATIVES 
                       WHERE DERIVED_CONNECTION_ID_FK = conId
                       AND SRC_TYPE = C_OBJECTTYPE_CATALOGS;
                       
   recDerived MD_DERIVATIVES%ROWTYPE;
  
  
BEGIN
	
  --DROP ANY EXISTING CONVERTED MODEL, AS WE ONLY HAVE A ONE TO ONE RELATIONSHIP WITH CAPTURED AND CONVERTED MODELS NOW
  DELETE FROM Md_Connections C 
  WHERE C.Type = 'CONVERTED' --only want to delete CONVERTED MODELS
  AND C.Id IN ( -- delete all converted models associated with this captured model
  SELECT d.derived_id FROM md_derivatives d WHERE d.src_id =  p_connectionid
  );
  
  -- The connection doesn't use the filter, because it is called for a single connection.
  v_newConnectionId := copy_connection(p_connectionid, p_scratchModel);
  -- Don't forget its additional props
  v_numProps := copy_additional_properties(p_connectionid, v_newConnectionId, v_newConnectionId);
  -- OK - Next coalesce the schema/catalogs
  
  IF p_scratchModel = FALSE 
  THEN
      --v_catalogId := create_dummy_catalog(v_newConnectionId);
      --select CATALOG_NAME INTO v_catalogName FROM MD_CATALOGS WHERE CONNECTION_ID_FK = p_connectionid;
      --v_sql := 'UPDATE MD_CATALOGS SET CATALOG_NAME = ''' || v_catalogName  || ''' WHERE ID = ' || TO_CHAR(v_catalogId);
      --EXECUTE IMMEDIATE v_sql;
      create_dummy_catalogs(p_connectionid, v_newConnectionId, FALSE);
      
      OPEN curDerivatives(v_newConnectionId);
      
      LOOP
            FETCH curDerivatives INTO recDerived;
            EXIT WHEN curDerivatives%NOTFOUND;
           --v_numCatalogs := copy_catalogs_cascade(p_connectionid, v_catalogid, v_newConnectionId, p_filter_set);
           v_numCatalogs := copy_catalogs_cascade(p_connectionid, recDerived.src_id, recDerived.derived_id, v_newConnectionId, p_filter_set);
           --FETCH curDerivatives INTO recDerived;
      END LOOP;
      CLOSE curDerivatives;
      v_numDuplicateIndexes := remove_duplicate_indexes(v_newConnectionId);
      v_numDuplicateIndexes := v_numDuplicateIndexes + remove_indexes_used_elsewhere(v_newConnectionId);
  ELSE -- enterprise capture
      create_dummy_catalogs(p_connectionid, v_newConnectionId, TRUE);
      copy_catalogs_cascade_ee(v_newConnectionId);
  END IF;
  COMMIT;
  return v_newConnectionId;
END copy_connection_cascade;

PROCEDURE update_derivative_record(p_orig VARCHAR2, p_new VARCHAR2, p_derivedid MD_DERIVATIVES.DERIVED_ID%TYPE,
p_derivedtype MD_DERIVATIVES.DERIVED_TYPE%TYPE, p_connectionid MD_DERIVATIVES.DERIVED_CONNECTION_ID_FK%TYPE)
IS	
BEGIN
    UPDATE MD_DERIVATIVES SET TRANSFORMED = C_TRANSFORMED_TRUE, ORIGINAL_IDENTIFIER = p_orig, NEW_IDENTIFIER = p_new
      WHERE DERIVED_ID = p_derivedid
      AND DERIVED_TYPE = p_derivedtype
      AND DERIVED_CONNECTION_ID_FK = p_connectionid;
END update_derivative_record;

/*
 * This procedure is like update_derivative_record except it should be used at name clash stage
 * basically, this will work the same as update_derivative_record except in those cases where
 * there is already a derivative record.  In this latter case, we want ORIGINAL_IDENTIFIER preserved
 * (this is called when there is a possiblity that we've carried out a second transformation
 */
PROCEDURE second_update_derivative(p_orig VARCHAR2, p_new VARCHAR2, p_derivedid MD_DERIVATIVES.DERIVED_ID%TYPE,
p_derivedtype MD_DERIVATIVES.DERIVED_TYPE%TYPE, p_connectionid MD_DERIVATIVES.DERIVED_CONNECTION_ID_FK%TYPE)
IS
  v_firstOriginal MD_DERIVATIVES.ORIGINAL_IDENTIFIER%TYPE;
BEGIN
  -- see if p_orig is already the new identifier
  select ORIGINAL_IDENTIFIER INTO v_firstOriginal FROM MD_DERIVATIVES
      WHERE DERIVED_ID = p_derivedid
      AND DERIVED_TYPE = p_derivedtype
      AND NEW_IDENTIFIER = p_orig
      AND DERIVED_CONNECTION_ID_FK = p_connectionid;
  if v_firstOriginal IS NULL then
    update_derivative_record(p_orig, p_new, p_derivedid, p_derivedtype, p_connectionid);
  else
    update_derivative_record(v_firstOriginal, p_new, p_derivedid, p_derivedtype, p_connectionid);
  end if;
EXCEPTION
  when NO_DATA_FOUND THEN
    update_derivative_record(p_orig, p_new, p_derivedid, p_derivedtype, p_connectionid);
  WHEN TOO_MANY_ROWS THEN
    dbms_output.put_line(TO_CHAR(p_derivedid) || ' ' || TO_CHAR(p_derivedtype) || ' '|| TO_CHAR(p_connectionid));
  
END second_update_derivative;

FUNCTION transform_column_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                 p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
    SELECT * FROM MD_COLUMNS
    WHERE TABLE_ID_FK IN
    (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = connid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(COLUMN_NAME) != COLUMN_NAME 
    FOR UPDATE OF COLUMN_NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
    SELECT c.*, d.NEW_IDENTIFIER FROM MD_COLUMNS c, MD_DERIVATIVES d
    WHERE (c.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
       WHERE SRC_TYPE= C_OBJECTTYPE_COLUMNS AND DERIVED_CONNECTION_ID_FK = connid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(d.NEW_IDENTIFIER) != COLUMN_NAME
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH
    FOR UPDATE OF COLUMN_NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_rec.NEW_IDENTIFIER);

    update_derivative_record(v_rec.COLUMN_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_COLUMNS, p_connectionid);    
    IF p_scratchModel = FALSE -- Update md_columns only for non migration estimation models
    THEN
        UPDATE MD_COLUMNS SET COLUMN_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_COLUMNS, v_count);
  --return v_count;
END transform_column_identifiers;

FUNCTION transform_constraint_idents(p_connectionid MD_CONNECTIONS.ID%TYPE, 
                                     p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_CONSTRAINTS
  WHERE TABLE_ID_FK IN
    (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = connid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT c.*, d.NEW_IDENTIFIER FROM MD_CONSTRAINTS c, MD_DERIVATIVES d
  WHERE (c.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
       WHERE SRC_TYPE = C_OBJECTTYPE_CONSTRAINTS AND DERIVED_CONNECTION_ID_FK = connid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(d.NEW_IDENTIFIER) != c.NAME
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH 
    FOR UPDATE OF NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_CONSTRAINTS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN    
       UPDATE MD_CONSTRAINTS SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_CONSTRAINTS, v_count);
END transform_constraint_idents;

FUNCTION transform_group_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                          p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_GROUPS WHERE
   SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(GROUP_NAME) != GROUP_NAME
    FOR UPDATE OF GROUP_NAME;
*/    

  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_GROUPS WHERE
   ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES 
       WHERE SRC_TYPE = C_OBJECTTYPE_GROUPS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(GROUP_NAME) != GROUP_NAME
    FOR UPDATE OF GROUP_NAME;
  v_rec MD_GROUPS%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_rec.GROUP_NAME);
    
    update_derivative_record(v_rec.GROUP_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_GROUPS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN    
       UPDATE MD_GROUPS SET GROUP_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_GROUPS, v_count);
END transform_group_identifiers;

FUNCTION transform_index_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_INDEXES WHERE TABLE_ID_FK IN
    (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||INDEX_NAME) != INDEX_NAME
    FOR UPDATE OF INDEX_NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT i.*, d.NEW_IDENTIFIER FROM MD_INDEXES i, MD_DERIVATIVES d WHERE (i.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE = C_OBJECTTYPE_INDEXES AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||d.NEW_IDENTIFIER) != i.INDEX_NAME
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH 
    FOR UPDATE OF INDEX_NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.INDEX_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_INDEXES, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN    
        UPDATE MD_INDEXES SET INDEX_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  commit;
  CLOSE v_curs;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_INDEXES, v_count);
END transform_index_identifiers;

FUNCTION transform_othobj_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                          p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_OTHER_OBJECTS  WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_OTHER_OBJECTS  WHERE ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE = C_OBJECTTYPE_OTHER_OBJECTS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
  v_rec MD_OTHER_OBJECTS%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NAME);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_OTHER_OBJECTS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_OTHER_OBJECTS SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_OTHER_OBJECTS, v_count);
END transform_othobj_identifiers;

FUNCTION transform_package_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                        p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_PACKAGES  WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_PACKAGES  WHERE ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES 
    WHERE SRC_TYPE = C_OBJECTTYPE_PACKAGES AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
  v_rec MD_PACKAGES%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NAME);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_PACKAGES, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_PACKAGES SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_PACKAGES, v_count);
END transform_package_identifiers;

FUNCTION transform_schema_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                         p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_SCHEMAS WHERE ID IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT s.*, d.NEW_IDENTIFIER FROM MD_SCHEMAS s, MD_DERIVATIVES d WHERE (s.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE = C_OBJECTTYPE_SCHEMAS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(d.NEW_IDENTIFIER) != NAME 
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH 
    FOR UPDATE OF NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName:= MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_SCHEMAS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_SCHEMAS SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_SCHEMAS, v_count);
END transform_schema_identifiers;

FUNCTION transform_sequence_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                           p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_SEQUENCES WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT s.*, d.NEW_IDENTIFIER FROM MD_SEQUENCES s, MD_DERIVATIVES d WHERE (s.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE = C_OBJECTTYPE_SEQUENCES AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||d.NEW_IDENTIFIER) != NAME
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH
    FOR UPDATE OF NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_SEQUENCES, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_SEQUENCES SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_SEQUENCES, v_count);
END transform_sequence_identifiers;

FUNCTION transform_sproc_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                         p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_STORED_PROGRAMS WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT sp.*, d.NEW_IDENTIFIER FROM MD_STORED_PROGRAMS sp, MD_DERIVATIVES d WHERE (sp.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = C_OBJECTTYPE_STORED_PROGRAMS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||d.NEW_IDENTIFIER) != sp.NAME 
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH 
    FOR UPDATE OF NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_STORED_PROGRAMS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_STORED_PROGRAMS SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_STORED_PROGRAMS, v_count);
END transform_sproc_identifiers;

FUNCTION transform_synonym_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                       p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_SYNONYMS WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_SYNONYMS WHERE ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES 
       WHERE SRC_TYPE =  C_OBJECTTYPE_SYNONYMS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
  v_rec MD_SYNONYMS%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NAME);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_SYNONYMS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_SYNONYMS SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_SYNONYMS, v_count);
END transform_synonym_identifiers;

FUNCTION transform_table_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_TABLES WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||TABLE_NAME) != TABLE_NAME
    FOR UPDATE OF TABLE_NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT t.*, d.NEW_IDENTIFIER FROM MD_TABLES t, MD_DERIVATIVES d WHERE (t.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE = C_OBJECTTYPE_TABLES AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||d.NEW_IDENTIFIER) != TABLE_NAME 
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH 
    FOR UPDATE OF TABLE_NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.TABLE_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_TABLES, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_TABLES SET TABLE_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_TABLES, v_count);
END transform_table_identifiers;

FUNCTION transform_view_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_VIEWS WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||VIEW_NAME) != VIEW_NAME
    FOR UPDATE OF VIEW_NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT v.*, d.NEW_IDENTIFIER FROM MD_VIEWS v, MD_DERIVATIVES d WHERE (v.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = C_OBJECTTYPE_VIEWS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||d.NEW_IDENTIFIER) != VIEW_NAME
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH 
    FOR UPDATE OF VIEW_NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.VIEW_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_VIEWS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_VIEWS SET VIEW_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_VIEWS, v_count);
END transform_view_identifiers;

FUNCTION transform_tablespace_idents(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_TABLESPACES WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(TABLESPACE_NAME) != TABLESPACE_NAME
    FOR UPDATE OF TABLESPACE_NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_TABLESPACES WHERE ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE = C_OBJECTTYPE_TABLESPACES AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(TABLESPACE_NAME) != TABLESPACE_NAME
    FOR UPDATE OF TABLESPACE_NAME;
  v_rec MD_TABLESPACES%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_rec.TABLESPACE_NAME);
    
    update_derivative_record(v_rec.TABLESPACE_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_TABLESPACES, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_TABLESPACES SET TABLESPACE_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_TABLESPACES, v_count);
END transform_tablespace_idents;

FUNCTION transform_trigger_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                       p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs IS 
  SELECT * FROM MD_TRIGGERS  WHERE TABLE_OR_VIEW_ID_FK IN
    (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||TRIGGER_NAME) != TRIGGER_NAME
    FOR UPDATE OF TRIGGER_NAME;
  CURSOR v_view_trigger_curs IS 
    SELECT * FROM MD_TRIGGERS  WHERE TABLE_OR_VIEW_ID_FK IN
    (SELECT VIEW_ID FROM MGV_ALL_VIEWS WHERE CONNECTION_ID =  p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||TRIGGER_NAME) != TRIGGER_NAME
    FOR UPDATE OF TRIGGER_NAME;
*/    
  CURSOR v_curs IS 
  SELECT t.*, d.NEW_IDENTIFIER FROM MD_TRIGGERS t, MD_DERIVATIVES d WHERE (t.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE =  C_OBJECTTYPE_TRIGGERS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||d.NEW_IDENTIFIER) != t.TRIGGER_NAME
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH
    FOR UPDATE OF TRIGGER_NAME;

  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs;
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NEW_IDENTIFIER);

    update_derivative_record(v_rec.TRIGGER_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_TRIGGERS, p_connectionid);
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_TRIGGERS SET TRIGGER_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;       

  END LOOP;
  CLOSE v_curs;
  /*
  OPEN v_view_trigger_curs;
  LOOP
    FETCH v_view_trigger_curs INTO v_rec;
    EXIT WHEN v_view_trigger_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.TRIGGER_NAME);
    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_TRIGGERS SET TRIGGER_NAME = v_newName WHERE CURRENT OF v_view_trigger_curs;
    END IF;
    
    update_derivative_record(v_rec.TRIGGER_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_TRIGGERS, p_connectionid);
  END LOOP;
  CLOSE v_view_trigger_curs;
  */
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_TRIGGERS, v_count);
END transform_trigger_identifiers;

FUNCTION transform_uddt_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                      p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_USER_DEFINED_DATA_TYPES WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||DATA_TYPE_NAME) != DATA_TYPE_NAME
    FOR UPDATE OF DATA_TYPE_NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_USER_DEFINED_DATA_TYPES WHERE ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = C_OBJECTTYPE_UDDT AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||DATA_TYPE_NAME) != DATA_TYPE_NAME
    FOR UPDATE OF DATA_TYPE_NAME;
  v_rec MD_USER_DEFINED_DATA_TYPES%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.DATA_TYPE_NAME);
    
    update_derivative_record(v_rec.DATA_TYPE_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_UDDT, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_USER_DEFINED_DATA_TYPES SET DATA_TYPE_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_UDDT, v_count);
END transform_uddt_identifiers;

FUNCTION transform_user_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                    p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_USERS WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(USERNAME) != USERNAME
    FOR UPDATE OF USERNAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_USERS WHERE ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = C_OBJECTTYPE_USERS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(USERNAME) != USERNAME
    FOR UPDATE OF USERNAME;
  v_rec MD_USERS%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_rec.USERNAME);
    
    update_derivative_record(v_rec.USERNAME, v_newName, v_rec.ID, C_OBJECTTYPE_USERS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_USERS SET USERNAME = v_newName WHERE CURRENT OF v_curs;
    END IF;

  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_USERS, v_count);
END transform_user_identifiers;

PROCEDURE rename_duplicate_index_names(p_connectionid MD_CONNECTIONS.ID%TYPE, p_scratchModel BOOLEAN := FALSE)
IS
    CURSOR v_curs IS
    select * from md_derivatives a 
          where a.derived_connection_id_fk = p_connectionid
                and 1 < (select count(*) 
                          from md_derivatives b 
                              where a.new_identifier = b.new_identifier 
                                  and a.derived_type='MD_INDEXES'
                                      and a.derived_connection_id_fk = b.derived_connection_id_fk)
                                      order by new_identifier;
                                          
  v_row MD_DERIVATIVES%ROWTYPE;
  v_newName MD_INDEXES.INDEX_NAME%TYPE;

  v_id MD_DERIVATIVES.DERIVED_ID%TYPE;

  v_curName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
  v_count NUMBER := 1;
BEGIN
  v_curName := 'dsa;lkjsd;alskj;';
  OPEN v_curs;
  LOOP
    FETCH v_curs INTO v_row;
    EXIT WHEN v_curs%NOTFOUND;
    

   IF UPPER(v_row.NEW_IDENTIFIER) = UPPER(v_curName) THEN
      v_newName := MIGRATION_TRANSFORMER.ADD_SUFFIX(v_row.NEW_IDENTIFIER, '_' || TO_CHAR(v_count), 30);
      v_count := v_count + 1;
      
      if p_scratchModel = FALSE
      THEN
         update MD_INDEXES SET index_name = v_newName where id = v_row.DERIVED_ID;
      END IF;
      second_update_derivative(v_row.NEW_IDENTIFIER, v_newName, v_row.DERIVED_ID, C_OBJECTTYPE_INDEXES, p_connectionid);
    else
      v_curName := v_row.NEW_IDENTIFIER;
      v_count := 1;
    END IF;
  END LOOP;
  CLOSE v_curs;
  commit;
END rename_duplicate_index_names;

PROCEDURE fixup_duplicate_identifier(p_connectionid MD_CONNECTIONS.ID%TYPE, 
                                      p_mdrec_id MD_DERIVATIVES.ID%TYPE,
                                      p_derived_type MD_DERIVATIVES.DERIVED_TYPE%TYPE,
                                      p_derived_id MD_DERIVATIVES.DERIVED_ID%TYPE,
                                      p_new_identifier MD_DERIVATIVES.NEW_IDENTIFIER%TYPE,
                                      p_suffix INTEGER, 
                                      p_scratchModel BOOLEAN := FALSE)
IS
	v_transform_identifier MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
	v_did_a_transform CHAR(1) := 'Y';
	--v_underscoresuffixsize NUMBER;
	--v_underscoresuffix VARCHAR2(100);
  --v_sizebeforeprefix NUMBER;
BEGIN
  --v_underscoresuffix := '_' || TO_CHAR(p_suffix);
  --v_underscoresuffixsize := LENGTH(v_underscoresuffix);
  --v_sizebeforeprefix := 30 - v_underscoresuffixsize;
  v_transform_identifier := MIGRATION_TRANSFORMER.ADD_SUFFIX(p_new_identifier, '_' || TO_CHAR(p_suffix) ,30);
  
  IF p_scratchModel = FALSE
  THEN
     CASE p_derived_type
      WHEN C_OBJECTTYPE_CONNECTIONS THEN
        UPDATE MD_CONNECTIONS SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_CATALOGS THEN
        UPDATE MD_CATALOGS SET CATALOG_NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_SCHEMAS THEN
        UPDATE MD_SCHEMAS SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_TABLES THEN
        UPDATE MD_TABLES SET TABLE_NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_CONSTRAINTS THEN
        UPDATE MD_CONSTRAINTS SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_INDEXES THEN
        UPDATE MD_INDEXES SET INDEX_NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_TRIGGERS THEN
        UPDATE MD_TRIGGERS SET TRIGGER_NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_VIEWS THEN
        UPDATE MD_VIEWS SET VIEW_NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_USERS THEN
        UPDATE MD_USERS SET USERNAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_GROUPS THEN
        UPDATE MD_GROUPS SET GROUP_NAME  = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_OTHER_OBJECTS THEN
        UPDATE MD_OTHER_OBJECTS SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_TABLESPACES THEN
        UPDATE MD_TABLESPACES SET TABLESPACE_NAME  = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_UDDT THEN
        UPDATE MD_USER_DEFINED_DATA_TYPES SET DATA_TYPE_NAME  = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_STORED_PROGRAMS THEN
        UPDATE MD_STORED_PROGRAMS SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_PACKAGES THEN
        UPDATE MD_PACKAGES SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_SYNONYMS THEN
        UPDATE MD_SYNONYMS SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_SEQUENCES THEN
        UPDATE MD_SEQUENCES SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      ELSE
        -- Handle column namespace here.
        IF SUBSTR(P_DERIVED_TYPE,1, LENGTH(C_OBJECTTYPE_COLUMNS)) = C_OBJECTTYPE_COLUMNS THEN
          UPDATE MD_COLUMNS SET COLUMN_NAME = v_transform_identifier WHERE ID = p_derived_id;
        ELSE
          v_did_a_transform := 'N';
        END IF;
      END CASE;
  END IF; -- end if scratch model
  
	IF v_did_a_transform = 'Y' THEN
	  UPDATE MD_DERIVATIVES SET NEW_IDENTIFIER = v_transform_identifier WHERE ID = p_mdrec_id;
	  commit;
    END IF;
    commit;
END fixup_duplicate_identifier;

FUNCTION getClashCount(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN INTEGER 
IS
  v_clashCount INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_clashCount FROM md_derivatives a
    where rowid > (
      select min(rowid) from md_derivatives b
      where
        b.derived_connection_id_fk = p_connectionid
        AND b.derived_connection_id_fk = a.derived_connection_id_fk
        AND UPPER(b.new_identifier) = UPPER(a.new_identifier)--  Uppercasing the name so that case sensitve names are caught (see bug 6922052)
        AND b.derived_object_namespace = a.derived_object_namespace);
  RETURN v_clashCount;
END getClashCount;

PROCEDURE transform_clashes(p_connectionid MD_CONNECTIONS.ID%TYPE, p_scratchModel BOOLEAN := FALSE)
IS
  CURSOR v_curs IS
    select id,derived_type, derived_id, UPPER(new_identifier) --  Uppercasing the name so that case sensitve names are caught (see bug 6922052)
    from md_derivatives a
    where rowid > (
      select min(rowid) from md_derivatives b
      where
        b.derived_connection_id_fk = p_connectionid
        AND b.derived_connection_id_fk = a.derived_connection_id_fk
        AND UPPER(b.new_identifier) = UPPER(a.new_identifier) --  Uppercasing the name so that case sensitve names are caught (see bug 6922052)
        AND b.derived_object_namespace = a.derived_object_namespace)
        ORDER BY new_identifier, derived_type;
  v_derived_type MD_DERIVATIVES.DERIVED_TYPE%TYPE;
  v_curr_type v_derived_type%TYPE := '~~dasdddfl;';
  v_derived_id MD_DERIVATIVES.DERIVED_ID%TYPE;
  v_new_identifier MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
  v_curr_identifier v_new_identifier%TYPE := '~~~~asdasnc';
  v_suffix INTEGER := 0;
  v_innerSuffix INTEGER;
  v_clashCount INTEGER;
  v_mdrec_id MD_DERIVATIVES.ID%TYPE;
BEGIN

  rename_duplicate_index_names(p_connectionid, p_scratchModel);
  
  v_clashCount := getClashCount(p_connectionid);
  WHILE v_clashCount > 0 
  LOOP
	v_suffix := v_suffix + 1;
	v_innerSuffix := v_suffix; 
    -- Now lets see if there are any identifier clashes
    OPEN v_curs;
    LOOP 
      FETCH v_curs into v_mdrec_id, v_derived_type, v_derived_id, v_new_identifier;
      EXIT WHEN v_curs%NOTFOUND;
 	  IF v_derived_type = v_curr_type AND v_new_identifier = v_curr_identifier THEN
		  v_innerSuffix := v_innerSuffix + 1;
	  else
		  v_curr_type := v_derived_type;
		  v_curr_identifier := v_new_identifier;
	  END IF;
      -- We have to fix up all of these identifiers
      fixup_duplicate_identifier(p_connectionid, v_mdrec_id, v_derived_type, v_derived_id, v_new_identifier, v_innerSuffix, p_scratchModel);
    END LOOP;
	CLOSE v_curs;
    v_clashCount := getClashCount(p_connectionid);
  END LOOP;
END transform_clashes;

FUNCTION transform_all_identifiers_x(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                             p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_ARRAY
IS
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_ARRAY;
  v_rec NAME_AND_COUNT_T;
BEGIN
  v_ret := NAME_AND_COUNT_ARRAY();
  -- We need to update identifiers on pretty much the whole schema
  -- MD_COLUMNS
  v_rec := transform_column_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  
  -- MD_CONSTRAINTS
  v_rec := transform_constraint_idents(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_GROUPS
  v_rec := transform_group_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_INDEXES
  v_rec := transform_index_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_OTHER_OBJECTS
  v_rec := transform_othobj_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_PACKAGES
  v_rec := transform_package_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_SCHEMAS
  v_rec := transform_schema_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_SEQUENCES
  v_rec := transform_sequence_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_STORED_PROGRAMS
  v_rec := transform_sproc_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_SYNONYMS
  v_rec := transform_synonym_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_TABLES
  v_rec := transform_table_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_TABLESPACES
  v_rec := transform_tablespace_idents(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_TRIGGERS
  v_rec := transform_trigger_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_USER_DEFINED_DATA_TYPES
  v_rec := transform_uddt_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_USERS
  v_rec := transform_user_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  /*
  UPDATE MD_USERS SET USERNAME = MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(USERNAME) WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(USERNAME) != USERNAME;
  dbms_output.put_line(SQL%ROWCOUNT || ' USER names updated');
  */
  -- MD_VIEWS
  v_rec := transform_view_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  transform_clashes(p_connectionid, p_scratchModel);
  -- TODO: Something meaningful if all goes wrong
  return v_ret;
  COMMIT;
END transform_all_identifiers_x;

FUNCTION transform_all_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE, p_prefixName VARCHAR2, p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_ARRAY
IS
BEGIN
v_prefixName := p_prefixName;
RETURN  transform_all_identifiers_x(p_connectionid, p_scratchModel);
END transform_all_identifiers;

FUNCTION rule_specificity(p_precision MIGR_DATATYPE_TRANSFORM_RULE.SOURCE_PRECISION%TYPE, p_scale MIGR_DATATYPE_TRANSFORM_RULE.SOURCE_SCALE%TYPE) RETURN INTEGER
IS
BEGIN
  IF p_precision is NULL then 
    return 1;
  END IF;
  IF p_scale is NULL then
    return 2;
  END IF;
  return 3;
END rule_specificity;

FUNCTION addToWhereClause(p_whereclause VARCHAR2, p_toAdd VARCHAR2) return VARCHAR2
IS
BEGIN
  IF p_whereclause is NULL then
    return p_toAdd;
  else
    return p_whereclause || ' AND ' || p_toAdd;
  END IF;
END addToWhereClause;

FUNCTION precision_val(p_srcPrecision MD_COLUMNS.PRECISION%TYPE, p_newDataType VARCHAR2) RETURN VARCHAR2
IS
  v_newDataType VARCHAR2(255);
  v_ret VARCHAR2(255);
BEGIN
  v_newDataType := UPPER(to_char(p_newDataType));
  -- Assume that no precision should be present
  v_ret := 'NULL';
  -- No see what the new data type is and ensure that a precision is required
  IF v_newDataType = 'VARCHAR2' OR
     v_newDataType = 'NVARCHAR2' OR
     v_newDataType = 'NUMBER' OR
     v_newDataType = 'TIMESTAMP' OR
     v_newDataType = 'INTERVAL YEAR' OR
     v_newDataType = 'INTERVAL DAY' OR
     v_newDataType = 'UROWID' OR
     v_newDataType = 'CHAR' OR
     v_newDataType = 'RAW' OR
     v_newDataType = 'NCHAR' THEN
     v_ret := p_srcPrecision;
  END IF;
  return v_ret;
END precision_val;

FUNCTION scale_val(p_srcPrecision MD_COLUMNS.SCALE%TYPE, p_newDataType VARCHAR2) RETURN VARCHAR2
IS
  v_newDataType VARCHAR2(255);
  v_ret VARCHAR2(255);
BEGIN
  v_newDataType := UPPER(to_char(p_newDataType));
  v_ret := 'NULL';
  IF v_newDataType = 'NUMBER' THEN
    v_ret := p_srcPrecision;
  END IF;
  return v_ret;
END scale_val;


FUNCTION check_for_invalid_data_types(p_connectionid MD_CONNECTIONS.ID%TYPE, p_numbytesperchar INTEGER) RETURN NUMBER
IS
BEGIN
    -- First, for char(n) columns, drop back to varchar2 - this could go up to 4k.
    -- If its even greater than this, it will be caught later on and made into a CLOB.
    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
        AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'CHAR' AND PRECISION > 2000
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET COLUMN_TYPE = 'VARCHAR2' WHERE COLUMN_TYPE = 'CHAR' AND PRECISION > 2000
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    -- We'll do something similar for NCHARs
    IF p_numbytesperchar = 1 THEN
        UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
          AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NCHAR' AND PRECISION > 2000 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
        UPDATE MD_COLUMNS SET COLUMN_TYPE = 'NVARCHAR2' WHERE COLUMN_TYPE = 'NCHAR' AND PRECISION > 2000 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    ELSE   
        -- 2 bytes per char - max is actually 1k          
        UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
          AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NCHAR' AND PRECISION > 1000 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
        UPDATE MD_COLUMNS SET COLUMN_TYPE = 'NVARCHAR2' WHERE COLUMN_TYPE = 'NCHAR' AND PRECISION > 1000 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    END IF;            
    -- VARCHAR or VARCHAR2 can't go above 4000.  If they do, they need to fallback to a CLOB
    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'VARCHAR' AND PRECISION > 4000 
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET COLUMN_TYPE = 'CLOB', PRECISION = NULL, SCALE = NULL WHERE COLUMN_TYPE = 'VARCHAR' AND PRECISION > 4000 
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS  WHERE COLUMN_TYPE = 'VARCHAR2' AND PRECISION > 4000 
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET COLUMN_TYPE = 'CLOB', PRECISION = NULL, SCALE = NULL WHERE COLUMN_TYPE = 'VARCHAR2' AND PRECISION > 4000 
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    -- NUMBER has a max precision of 38, and scale must be between -84 and 127
    -- We can only narrow this.  

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NUMBER' AND PRECISION > 38
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET PRECISION = 38 WHERE COLUMN_TYPE = 'NUMBER' AND PRECISION > 38
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NUMBER' AND SCALE < -84
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET SCALE = -84 WHERE COLUMN_TYPE = 'NUMBER' AND SCALE < -84
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NUMBER' AND SCALE > 127
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET SCALE = 127 WHERE COLUMN_TYPE = 'NUMBER' AND SCALE > 127
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    -- NVARCHAR has a max of 4000 bytes.  But its definition depends on the character set in use.
    IF  p_numbytesperchar = 1 THEN
        UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
          AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NVARCHAR2' AND PRECISION > 4000 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
        UPDATE MD_COLUMNS SET COLUMN_TYPE = 'NCLOB', PRECISION = NULL, SCALE = NULL WHERE COLUMN_TYPE = 'NVARCHAR2' AND PRECISION > 4000 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    ELSE
        UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
          AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NVARCHAR2' AND PRECISION > 2000 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
        UPDATE MD_COLUMNS SET COLUMN_TYPE = 'NCLOB', PRECISION = NULL, SCALE = NULL WHERE COLUMN_TYPE = 'NVARCHAR2' AND PRECISION > 2000 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    END IF;            
    -- TIMESTAMP has a max size of 9

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'TIMESTAMP' AND PRECISION > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET PRECISION = 9 WHERE COLUMN_TYPE = 'TIMESTAMP' AND PRECISION > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'INTERVAL YEAR' AND PRECISION > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET PRECISION = 9 WHERE COLUMN_TYPE = 'INTERVAL YEAR' AND PRECISION > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'INTERVAL DAY' AND PRECISION > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET PRECISION = 9 WHERE COLUMN_TYPE = 'INTERVAL DAY' AND PRECISION > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'INTERVAL DAY' AND SCALE > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET SCALE = 9 WHERE COLUMN_TYPE = 'INTERVAL DAY' AND SCALE > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'UROWID' AND PRECISION > 4000
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET PRECISION = 4000 WHERE COLUMN_TYPE = 'UROWID' AND PRECISION > 4000
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    -- Too large RAW?  Make it a CLOB        

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'RAW' AND PRECISION > 2000
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET COLUMN_TYPE = 'BLOB', PRECISION = NULL WHERE COLUMN_TYPE = 'RAW' AND PRECISION > 2000
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    commit;
    RETURN 0;        
END check_for_invalid_data_types;

FUNCTION transform_datatypes(p_connectionid MD_CONNECTIONS.ID%TYPE, p_mapid MIGR_DATATYPE_TRANSFORM_MAP.ID%TYPE, p_numbytesperchar INTEGER) RETURN NUMBER
IS
  v_projectid MD_PROJECTS.ID%TYPE;
  v_mapProjectid MD_PROJECTS.ID%TYPE;
  CURSOR v_curs(mapid MIGR_DATATYPE_TRANSFORM_MAP.ID%TYPE) IS
    SELECT * FROM MIGR_DATATYPE_TRANSFORM_RULE WHERE map_ID_fk = mapid
    ORDER BY     DECODE(source_precision,
            NULL, 0,
            1) +
    DECODE(source_scale,
            NULL, 0,
            1)  DESC;
  v_rule MIGR_DATATYPE_TRANSFORM_RULE%ROWTYPE;
  v_whereClause VARCHAR2(4000);
  v_updateClause VARCHAR2(4000);
  v_count NUMBER := 0;
  v_ret NUMBER;
BEGIN
  -- We should only work with our "own" maps.  I.e. The map should be part of this project.
  SELECT project_id_fk into v_projectid from MD_CONNECTIONS where id = p_connectionid;
  SELECT project_id_fk into v_mapProjectid from MIGR_DATATYPE_TRANSFORM_MAP where id = p_mapid;
  IF v_projectid != v_mapProjectid then 
    -- TODO.  Some nice RAISE_APPLICATION_ERROR stuff here.
    return 0;
  END IF;
  -- OK We can work with our map
  OPEN v_curs(p_mapid);
  LOOP
    fetch v_curs INTO v_rule;
    EXIT WHEN v_curs%NOTFOUND;
    v_whereClause := 'UPPER(COLUMN_TYPE) = ''' || UPPER(v_rule.SOURCE_DATA_TYPE_NAME) || '''';
    if v_rule.SOURCE_PRECISION is not NULL then
      v_whereClause := addToWhereClause(v_whereClause, 'PRECISION = ' || to_char(v_rule.source_precision));
      IF v_rule.SOURCE_SCALE is not NULL then
        v_whereClause := addToWhereClause(v_whereClause, 'SCALE = ' || to_char(v_rule.source_scale));
      end IF;
    END IF;
    v_whereClause := addToWhereClause(v_whereClause, 'table_id_fk in (SELECT table_id from MGV_ALL_TABLES WHERE connection_id = ' || to_char(p_connectionid) || ')');
    v_whereClause := addTowhereclause(v_whereClause, 'DATATYPE_TRANSFORMED_FLAG IS NULL');
    v_updateClause := 'UPDATE MD_COLUMNS SET COLUMN_TYPE = ''' || v_rule.TARGET_DATA_TYPE_NAME || ''', DATATYPE_TRANSFORMED_FLAG=''Y''';
    IF v_rule.TARGET_PRECISION is not NULL then
      v_updateClause := v_updateClause || ', PRECISION = ' || precision_val(v_rule.TARGET_PRECISION, v_rule.TARGET_DATA_TYPE_NAME);
      IF v_rule.TARGET_SCALE is not NULL then
        -- The rule says change it to a specific scale, but we may override this is the data type shouldn't have a scale
        v_updateClause := v_updateClause || ', SCALE = ' || scale_val(v_rule.TARGET_SCALE, v_rule.TARGET_DATA_TYPE_NAME);
      ELSE
        -- There was no mention on the rule to touch the scale, so we should leave it alone...
        -- ..unless of course the data type forbids having it.
        IF scale_val(1, v_rule.TARGET_DATA_TYPE_NAME) = 'NULL' THEN
          v_updateClause := v_updateClause || ', SCALE = NULL';
        END IF;
      END IF;
    ELSE
      -- There was no metion on the rul to touch the precision, so we should leave it alone...
      -- ..unless of course the data type forbids having it.
      IF precision_val(1, v_rule.TARGET_DATA_TYPE_NAME) = 'NULL' THEN
        v_updateClause := v_updateClause || ', PRECISION = NULL';
      END IF;
      IF scale_val(1, v_rule.TARGET_DATA_TYPE_NAME) = 'NULL' THEN
        v_updateClause := v_updateClause || ', SCALE = NULL';
      END IF;
    END IF;
    v_updateClause := v_updateClause || ' WHERE ' || v_whereClause;
    dbms_output.put_line(v_updateClause);
    EXECUTE IMMEDIATE v_updateClause;
    v_count := v_count + SQL%ROWCOUNT;
  END LOOP;
  CLOSE v_curs;
  COMMIT;
  -- OK.  Lets see if we've made any columns invalid.
  v_ret := check_for_invalid_data_types(p_connectionid, p_numbytesperchar);  
  -- Now that we know the data types of the index columns, we may have flag some of the indexes
  -- as text indexes.
  v_ret := fixupTextIndexes(p_connectionid);

  RETURN v_count;
END transform_datatypes;

FUNCTION GET_IDENTITY_TRIGGER(v_triggerName VARCHAR2 , v_tableName VARCHAR2  , 
v_ColumnName VARCHAR2  ,v_seqName VARCHAR2 ,v_emulationPkgNamePrefix VARCHAR2 ) RETURN VARCHAR2
as
 v_identityClause VARCHAR2(200);
BEGIN

IF v_emulationpkgnameprefix = 'mysql_utilities.' THEN
  v_identityclause := '    --used to emulate LAST_INSERT_ID()'|| chr(10) || '    --'||v_emulationpkgnameprefix || 'identity := v_newVal; '|| chr(10) ;
ELSE
  v_identityclause := '    -- save this to emulate @@identity'|| chr(10) || '   '||v_emulationpkgnameprefix || 'identity := v_newVal; '|| chr(10) ;
END IF;
       
return 'CREATE OR REPLACE TRIGGER ' || v_triggerName || ' BEFORE INSERT ON ' || v_tableName || CHR(10) ||
       'FOR EACH ROW' || CHR(10) ||
       'DECLARE ' || CHR(10)||
       'v_newVal NUMBER(12) := 0;' ||CHR(10) ||
	   'v_incval NUMBER(12) := 0;'||CHR(10) ||
       'BEGIN' || CHR(10) ||
       '  IF INSERTING AND :new.' || v_ColumnName || ' IS NULL THEN' || CHR(10) ||
       '    SELECT  ' || v_seqName || '.NEXTVAL INTO v_newVal FROM DUAL;' || CHR(10) ||
	   '    -- If this is the first time this table have been inserted into (sequence == 1)' || CHR(10) ||
	   '    IF v_newVal = 1 THEN ' || CHR(10) ||
	   '      --get the max indentity value from the table' || CHR(10) ||
	   '      SELECT NVL(max(' || v_ColumnName || '),0) INTO v_newVal FROM ' || v_tableName || ';'|| CHR(10) || 
	   '      v_newVal := v_newVal + 1;' || CHR(10) || 
	   '      --set the sequence to that value'|| CHR(10) || 
	   '      LOOP'|| CHR(10) || 
	   '           EXIT WHEN v_incval>=v_newVal;'|| CHR(10) || 
	   '           SELECT ' || v_seqName || '.nextval INTO v_incval FROM dual;'|| CHR(10) || 
       '      END LOOP;'|| CHR(10) || 
       '    END IF;'|| chr(10) ||    
       v_identityClause
      ||
       '   -- assign the value from the sequence to emulate the identity column'|| CHR(10) || 
       '   :new.' || v_ColumnName || ' := v_newVal;'|| CHR(10) || 
       '  END IF;' || CHR(10) ||
       'END;' || CHR(10);
END GET_IDENTITY_TRIGGER;

FUNCTION get_plugin_name(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN VARCHAR2
IS
  CURSOR v_pluginNameCur IS SELECT value FROM MD_ADDITIONAL_PROPERTIES WHERE prop_key='PLUGIN_ID' AND connection_id_fk = p_connectionid;
  v_pluginName MD_ADDITIONAL_PROPERTIES.VALUE%TYPE;
  BEGIN
	  OPEN v_pluginNameCur;
	  FETCH v_pluginNameCur INTO v_pluginName;
	  CLOSE v_pluginNameCur;
	  RETURN v_pluginName;
END get_plugin_name;	  
	  
FUNCTION get_emulation_pkg_name(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN VARCHAR2
AS
v_pkgName VARCHAR2(1000);
v_pluginName MD_ADDITIONAL_PROPERTIES.VALUE%TYPE;
BEGIN
	v_pluginName := get_plugin_name(p_connectionid);
	IF LOWER(v_pluginName) LIKE '%sqlserver%'THEN
	  	v_pkgName := 'utils.';
	  ELSIF LOWER(v_pluginName) LIKE '%access%'THEN
	    v_pkgName := 'msaccess_utilities.';
	  ELSIF LOWER(v_pluginName) LIKE '%sybase%'THEN
	    v_pkgName := 'utils.';
	  ELSIF LOWER(v_pluginName) LIKE '%mysql%' THEN
	    v_pkgName := 'mysql_utilities.';
	  ELSIF LOWER(v_pluginName) LIKE '%db2%' THEN
	    v_pkgName := 'db2_utilities.';
	END IF;
  RETURN v_pkgName;
END get_emulation_pkg_name;

FUNCTION transform_identity_columns(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR v_curs IS SELECT a.schema_id_fk, a.id tableid, a.TABLE_NAME, b.id, b.column_name
                   FROM md_tables a, md_columns b WHERE b.id IN
                     (SELECT ref_id_fk FROM md_additional_properties WHERE prop_key = C_PROPKEY_SEEDVALUE)
                   AND table_id_fk IN (SELECT table_id FROM mgv_all_tables WHERE connection_id = p_connectionid)
                   AND a.id = b.table_id_fk
                   AND b.id NOT IN (SELECT SRC_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = C_OBJECTTYPE_COLUMNS AND DERIVED_TYPE = C_OBJECTTYPE_SEQUENCES AND 
                                    DERIVED_CONNECTION_ID_FK = p_connectionid);  
  	v_schemaId MD_SCHEMAS.ID%TYPE;
	v_tableId MD_TABLES.ID%TYPE;
        v_tableName MD_TABLES.TABLE_NAME%TYPE;
	v_columnId MD_COLUMNS.ID%TYPE;
	v_columnName MD_COLUMNS.COLUMN_NAME%TYPE;
	v_row MD_ADDITIONAL_PROPERTIES%ROWTYPE;
	v_seedValue NUMBER;
	-- Default the increment to 1 if it is not supplied.
	v_increment NUMBER := 1;
	v_lastVal NUMBER := NULL;
	v_retId MD_SEQUENCES.ID%TYPE;
	v_retSeqId MD_SEQUENCES.ID%TYPE;
	v_seqName MD_SEQUENCES.NAME%TYPE;
        v_trgName MD_TRIGGERS.TRIGGER_NAME%TYPE;
	v_triggerText VARCHAR2(4000);
        v_lob CLOB;
	v_transRet NAME_AND_COUNT_T;
	v_dbTypeCurs VARCHAR2(1000);
	v_emulationPkgNamePrefix VARCHAR2(100) := '';
BEGIN
  -- Auxillary, get the emulation package name
  v_emulationPkgNamePrefix := get_emulation_pkg_name(p_connectionid);
  
  OPEN v_curs;
  LOOP
  	FETCH v_curs into v_schemaId, v_tableId, v_tableName, v_columnId, v_columnName;
  	EXIT WHEN v_curs%NOTFOUND;
  	-- The above query excludes already created sequences, so we should be ok.
  	-- create the sequence:
  	-- 1. Get the seedvalue, increment, lastvalue if present
  	FOR v_row in (SELECT * FROM MD_ADDITIONAL_PROPERTIES WHERE REF_ID_FK = v_columnId)
  	LOOP
  	  IF v_row.PROP_KEY = C_PROPKEY_SEEDVALUE THEN
  	    v_seedValue := TO_NUMBER(v_row.VALUE);
          END IF;
  	  IF v_row.PROP_KEY = C_PROPKEY_INCREMENT THEN
  	    v_increment := TO_NUMBER(v_row.VALUE);
          END IF;
  	  IF v_row.PROP_KEY = C_PROPKEY_LASTVALUE THEN
  	    v_lastVal := TO_NUMBER(v_row.VALUE);
  	  END IF;
  	END LOOP;
  	-- Note: We'll start our sequence where the source left off.
  	IF v_lastVal IS NOT NULL THEN
  	  v_seedValue := v_lastVal;
  	END IF;
      
  	-- 2. Create the sequence
  	-- Note: I'm adding _SEQ to the column name for now. We'll have to use the collision manager in the
  	-- future.
  	v_seqName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_tableName || '_' || v_columnName || '_SEQ');
  	INSERT INTO MD_SEQUENCES(SCHEMA_ID_FK, NAME, SEQ_START, INCR)
  	  VALUES (v_schemaId, v_seqName, v_seedValue, v_increment)
  	  RETURNING ID INTO v_retId;
  	v_retSeqId := v_retId;
  	-- And of course a new derivative record
  	INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
  	  VALUES(v_columnId, C_OBJECTTYPE_COLUMNS, v_retId, C_OBJECTTYPE_SEQUENCES, p_connectionId, C_TRANSFORMED_TRUE, NULL, v_seqName, C_NS_SCHEMA_OBJS || TO_CHAR(v_schemaId));
  	-- Create the trigger
        v_trgName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_tableName || '_' || v_columnName || '_TRG');
  	v_triggerText := GET_IDENTITY_TRIGGER(v_trgName, v_tableName , v_ColumnName ,v_seqName ,v_emulationPkgNamePrefix);
  	-- Note: I'm adding _TRG to the column name for now.We'll have to use the collsion manager in the futre.
  	INSERT INTO MD_TRIGGERS(TABLE_OR_VIEW_ID_FK, TRIGGER_ON_FLAG, TRIGGER_NAME, TRIGGER_TIMING, TRIGGER_OPERATION, NATIVE_SQL, LANGUAGE)
  	  VALUES(v_tableId, 'T', v_trgName, 'BEFORE', 'INSERT OR UPDATE', EMPTY_CLOB(), C_LANGUAGEID_ORACLE)
  	  RETURNING ID INTO v_retId;
  	INSERT INTO MD_ADDITIONAL_PROPERTIES ( CONNECTION_ID_FK, REF_ID_FK, REF_TYPE, PROP_KEY, VALUE )
       VALUES (p_connectionid, v_retId, C_OBJECTTYPE_TRIGGERS, C_PROPKEY_TRIGGER_REWRITE, '');
    INSERT INTO MD_ADDITIONAL_PROPERTIES ( CONNECTION_ID_FK, REF_ID_FK, REF_TYPE, PROP_KEY, VALUE )
       VALUES (p_connectionid, v_retId, C_OBJECTTYPE_TRIGGERS, C_PROPKEY_SEQUENCEID, TO_CHAR(v_retSeqId));	
  	INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
  	  VALUES(v_columnId, C_OBJECTTYPE_COLUMNS, v_retId, C_OBJECTTYPE_TRIGGERS, p_connectionId, C_TRANSFORMED_TRUE, NULL, v_trgName, C_NS_SCHEMA_OBJS || TO_CHAR(v_schemaId));
        SELECT NATIVE_SQL INTO v_lob FROM MD_TRIGGERS WHERE ID = v_retId;          
        DBMS_LOB.OPEN(v_lob, DBMS_LOB.LOB_READWRITE);
        DBMS_LOB.WRITE(v_lob, LENGTH(v_triggerText), 1, v_triggerText);
        DBMS_LOB.CLOSE(v_lob);
  END LOOP;
  COMMIT;
  CLOSE v_curs;
  RETURN 0;
END transform_identity_columns;




FUNCTION transform_rewrite_trigger(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR v_curs is SELECT ID, TABLE_OR_VIEW_ID_FK, TRIGGER_ON_FLAG, TRIGGER_NAME,
    TRIGGER_TIMING, TRIGGER_OPERATION, TRIGGER_EVENT, NATIVE_SQL, NATIVE_KEY,
    LANGUAGE, COMMENTS from MD_TRIGGERS where ID in
    (SELECT REF_ID_FK from MD_ADDITIONAL_PROPERTIES
    WHERE CONNECTION_ID_FK = p_connectionid and PROP_KEY = C_PROPKEY_TRIGGER_REWRITE);
  
  v_rowTriggers MD_TRIGGERS%ROWTYPE;
  v_tableName MD_TABLES.TABLE_NAME%TYPE;
	v_columnName MD_COLUMNS.COLUMN_NAME%TYPE;
	v_retId MD_SEQUENCES.ID%TYPE;
  v_retSeqId MD_SEQUENCES.ID%TYPE;
	v_seqName MD_SEQUENCES.NAME%TYPE;
  v_seqName2 MD_SEQUENCES.NAME%TYPE;
	v_triggerText VARCHAR2(4000);
  v_lob CLOB;
  v_projectName VARCHAR2(100);
  v_emulationPkgNamePrefix VARCHAR2(100) := '';
BEGIN
  -- Auxillary, get the emulation package name
  v_emulationPkgNamePrefix := get_emulation_pkg_name(p_connectionid);
  
  open v_curs;
  loop
    fetch v_curs into v_rowTriggers.ID, v_rowTriggers.TABLE_OR_VIEW_ID_FK, v_rowTriggers.TRIGGER_ON_FLAG, v_rowTriggers.TRIGGER_NAME,
    v_rowTriggers.TRIGGER_TIMING, v_rowTriggers.TRIGGER_OPERATION, v_rowTriggers.TRIGGER_EVENT, v_rowTriggers.NATIVE_SQL, v_rowTriggers.NATIVE_KEY,
    v_rowTriggers.LANGUAGE, v_rowTriggers.COMMENTS ;
    EXIT WHEN v_curs%NOTFOUND;
    update MD_TRIGGERS set native_sql = empty_clob() where id = v_rowTriggers.ID;

    -- get table and column name from the derivative of this trigger
    select T.TABLE_NAME, C.COLUMN_NAME into v_tableName, v_columnName from MD_TABLES T,
      MD_COLUMNS C where C.TABLE_ID_FK = T.ID and C.ID =
      (select SRC_ID from MD_DERIVATIVES where DERIVED_ID =  v_rowTriggers.ID and SRC_TYPE =
      C_OBJECTTYPE_COLUMNS and DERIVED_CONNECTION_ID_FK = p_connectionid);
    -- get sequence name from id got from additional property
    select s.NAME into v_seqName from MD_SEQUENCES s where s.ID =
      (select TO_NUMBER(VALUE) from MD_ADDITIONAL_PROPERTIES where CONNECTION_ID_FK = p_connectionid
      AND REF_ID_FK = v_rowTriggers.ID and PROP_KEY = C_PROPKEY_SEQUENCEID);
      v_triggerText := GET_IDENTITY_TRIGGER(v_rowTriggers.TRIGGER_NAME, v_tableName , v_ColumnName ,v_seqName ,v_emulationPkgNamePrefix);
    SELECT NATIVE_SQL INTO v_lob FROM MD_TRIGGERS WHERE ID = v_rowTriggers.ID;          
    DBMS_LOB.OPEN(v_lob, DBMS_LOB.LOB_READWRITE);
    DBMS_LOB.WRITE(v_lob, LENGTH(v_triggerText), 1, v_triggerText);
    DBMS_LOB.CLOSE(v_lob);
  END LOOP;
  COMMIT;
  CLOSE v_curs;
  return 0;
END transform_rewrite_trigger;

PROCEDURE RefreshLineCountViews(p_connectionId MD_CONNECTIONS.ID%TYPE DEFAULT NULL)
IS
BEGIN
	 	UPDATE (select s.*, ltrim(rtrim(s.native_sql,' ' ||'  '|| chr(10)||chr(13)),' ' ||'  '|| chr(10)||chr(13)) trimmed from md_stored_programs s)  x
	 	SET LINECOUNT = LENGTH(trimmed) -  LENGTH(replace(trimmed,chr(10))) +1
	 	WHERE linecount IS NULL;
	 	
	 	UPDATE (select s.*, ltrim(rtrim(s.native_sql,' ' ||'  '|| chr(10)||chr(13)),' ' ||'  '|| chr(10)||chr(13)) trimmed from md_views s)  x
	 	SET LINECOUNT = LENGTH(trimmed) -  LENGTH(replace(trimmed,chr(10))) +1
	 	WHERE linecount IS NULL;
	 	
	 	UPDATE (select s.*, ltrim(rtrim(s.native_sql,' ' ||'  '|| chr(10)||chr(13)),' ' ||'  '|| chr(10)||chr(13)) trimmed from md_triggers s)  x
	 	SET LINECOUNT = LENGTH(trimmed) -  LENGTH(replace(trimmed,chr(10))) +1 
	 	WHERE linecount IS NULL;
END;

FUNCTION gatherConnectionStats(p_connectionId MD_CONNECTIONS.ID%TYPE,p_comments MD_CONNECTIONS.COMMENTS%TYPE) RETURN NUMBER
IS
	v_numCatalogs INTEGER := 0;
	v_numColumns INTEGER := 0;
	v_numConstraints INTEGER := 0;
	v_numGroups INTEGER := 0;
	v_numRoles INTEGER := 0;
	v_numIndexes INTEGER := 0;
	v_numOtherObjects INTEGER := 0;
	v_numPackages INTEGER := 0;
	v_numPrivileges INTEGER := 0;
	v_numSchemas INTEGER := 0;
	v_numSequences INTEGER := 0;
	v_numStoredPrograms INTEGER := 0;
	v_numSynonyms INTEGER := 0;
	v_numTables INTEGER := 0;
	v_numTableSpaces INTEGER := 0;
	v_numTriggers INTEGER := 0;
	v_numUserDefinedDataTypes INTEGER := 0;
	v_numUsers INTEGER := 0;
	v_numViews INTEGER := 0;
BEGIN
	SELECT COUNT(*) INTO v_numCatalogs FROM MD_CATALOGS  WHERE CONNECTION_ID_FK = p_connectionId;
	SELECT COUNT(*) INTO v_numColumns FROM MD_COLUMNS WHERE TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numConstraints FROM MD_CONSTRAINTS WHERE  TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numGroups FROM MD_GROUPS WHERE GROUP_FLAG = 'G' AND SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId); 
	SELECT COUNT(*) INTO v_numRoles FROM MD_GROUPS WHERE GROUP_FLAG = 'R' AND SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numIndexes FROM MD_INDEXES  WHERE TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numOtherObjects FROM MD_OTHER_OBJECTS WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numPackages FROM MD_PACKAGES WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);  
	SELECT COUNT(*) INTO v_numPrivileges FROM MD_PRIVILEGES WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numSchemas FROM MD_SCHEMAS WHERE CATALOG_ID_FK IN (SELECT CATALOG_ID FROM MGV_ALL_CATALOGS WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numSequences FROM MD_SEQUENCES WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numStoredPrograms FROM MD_STORED_PROGRAMS WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numSynonyms FROM MD_SYNONYMS WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numTables FROM MD_TABLES WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numTableSpaces FROM MD_TABLESPACES WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numTriggers FROM MD_TRIGGERS WHERE TABLE_OR_VIEW_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionId
                                                                                          UNION SELECT VIEW_ID FROM MGV_ALL_VIEWS WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numUserDefinedDataTypes FROM MD_USER_DEFINED_DATA_TYPES WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numUsers FROM MD_USERS WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numViews FROM MD_VIEWS WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
  	UPDATE MD_CONNECTIONS SET  
		NUM_CATALOGS = v_numCatalogs,
		NUM_COLUMNS = v_numColumns,
		NUM_CONSTRAINTS = v_numConstraints,
		NUM_GROUPS = v_numGroups,
		NUM_ROLES = v_numRoles,
		NUM_INDEXES = v_numIndexes,
		NUM_OTHER_OBJECTS = v_numOtherObjects,
		NUM_PACKAGES = v_numPackages,
		NUM_PRIVILEGES = v_numPrivileges,
		NUM_SCHEMAS = v_numSchemas,
		NUM_SEQUENCES = v_numSequences,
		NUM_STORED_PROGRAMS = v_numStoredPrograms,
		NUM_SYNONYMS = v_numSynonyms,
		NUM_TABLES = v_numTables,
		NUM_TABLESPACES = v_numTableSpaces,
		NUM_TRIGGERS = v_numTriggers,
		NUM_USER_DEFINED_DATA_TYPES = v_numUserDefinedDataTypes,
		num_users = v_numusers,
        num_views = v_numviews,
        COMMENTS = COMMENTS || p_comments    
	WHERE ID = p_connectionId;
	COMMIT;
    RefreshLineCountViews(p_connectionId);
	COMMIT;
	RETURN 0;
END gatherConnectionStats;

--
-- Procedures that start with "insert_*" insert a copy of MD_* values into MD_DERIVATIVES table.
-- MD_* are MD_COLUMNS, MD_CONSTRAINTS, MD_TABLES, MD_TRIGGERS, MD_INDEXES, MD_SEQUENCES, MD_STORED_PROGRAMS 
-- AND MD_VIEWS
--
PROCEDURE insert_all_columns(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_tableid MD_TABLES.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_COLUMNS%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_COLUMNS WHERE TABLE_ID_FK = ' || p_tableid;
  v_newName MD_COLUMNS.COLUMN_NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;
BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.COLUMN_NAME);
    if v_row.COLUMN_NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_COLUMNS, v_row.id, C_OBJECTTYPE_COLUMNS, p_connectionid, v_transformed,
                  v_row.COLUMN_NAME, v_newName, C_OBJECTTYPE_COLUMNS || TO_CHAR(p_tableid), C_CONNECTIONTYPE_SCRATCH);
    
  END LOOP;
  close cv_curs;
END insert_all_columns;

PROCEDURE insert_all_indexes(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_tableid MD_TABLES.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_INDEXES%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_INDEXES WHERE MD_INDEXES.TABLE_ID_FK = ' || p_tableid;
  v_newName MD_INDEXES.INDEX_NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;
BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.INDEX_NAME);
    if v_row.INDEX_NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_INDEXES, v_row.id, C_OBJECTTYPE_INDEXES, p_connectionid, v_transformed,
                  v_row.INDEX_NAME, v_newName, C_OBJECTTYPE_INDEXES || TO_CHAR(p_tableid), C_CONNECTIONTYPE_SCRATCH);
    
  END LOOP;
  close cv_curs;
END insert_all_indexes;

PROCEDURE insert_all_table_triggers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_tableid MD_TABLES.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_TRIGGERS%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_TRIGGERS WHERE MD_TRIGGERS.TABLE_OR_VIEW_ID_FK = ' || p_tableid;
  v_newName MD_TRIGGERS.TRIGGER_NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;
BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.TRIGGER_NAME);
    if v_row.TRIGGER_NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_TRIGGERS, v_row.id, C_OBJECTTYPE_TRIGGERS, p_connectionid, v_transformed,
                  v_row.TRIGGER_NAME, v_newName, C_NS_DB_TRIGGERS || TO_CHAR(p_tableid), C_CONNECTIONTYPE_SCRATCH);
    
  END LOOP;
  close cv_curs;
END insert_all_table_triggers;

PROCEDURE insert_all_constraints(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                 p_tableid MD_TABLES.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_CONSTRAINTS%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_CONSTRAINTS WHERE MD_CONSTRAINTS.TABLE_ID_FK = ' || p_tableid;
  v_newName MD_CONSTRAINTS.NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;
BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.NAME);
    if v_row.NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_CONSTRAINTS, v_row.id, C_OBJECTTYPE_CONSTRAINTS, p_connectionid, v_transformed,
                  v_row.NAME, v_newName, C_NS_CONSTRAINTS || TO_CHAR(p_tableid), C_CONNECTIONTYPE_SCRATCH);
    
  END LOOP;
  close cv_curs;
END insert_all_constraints;


PROCEDURE insert_all_tables_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                    p_schemaid MD_SCHEMAS.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_TABLES%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_TABLES where SCHEMA_ID_FK = ' || p_schemaid;
  v_newName MD_TABLES.TABLE_NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;

BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.TABLE_NAME);
    if v_row.TABLE_NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_TABLES, v_row.id, C_OBJECTTYPE_TABLES, p_connectionid, v_transformed,
                  v_row.TABLE_NAME, v_newName, C_NS_SCHEMA_OBJS || TO_CHAR(p_schemaid), C_CONNECTIONTYPE_SCRATCH);
                  
     insert_all_columns(p_connectionid, v_row.id);
     insert_all_indexes(p_connectionid, v_row.id);
     insert_all_table_triggers(p_connectionid, v_row.id);
     insert_all_constraints(p_connectionid, v_row.id);
     
  END LOOP;
  close cv_curs;	
END insert_all_tables_cascade;

PROCEDURE insert_all_views(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                    p_schemaid MD_SCHEMAS.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_VIEWS%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_VIEWS WHERE SCHEMA_ID_FK = ' || p_schemaid;
  v_newName MD_VIEWS.VIEW_NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;

BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.VIEW_NAME);
    if v_row.VIEW_NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_VIEWS, v_row.id, C_OBJECTTYPE_VIEWS, p_connectionid, v_transformed,
                  v_row.VIEW_NAME, v_newName, C_NS_SCHEMA_OBJS || TO_CHAR(p_schemaid), C_CONNECTIONTYPE_SCRATCH);
     
  END LOOP;
  close cv_curs;	
END insert_all_views;

PROCEDURE insert_all_sequences(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                    p_schemaid MD_SCHEMAS.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_SEQUENCES%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_SEQUENCES WHERE SCHEMA_ID_FK = ' || p_schemaid;
  v_newName MD_SEQUENCES.NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;

BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.NAME);
    if v_row.NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_SEQUENCES, v_row.id, C_OBJECTTYPE_SEQUENCES, p_connectionid, v_transformed,
                  v_row.NAME, v_newName, C_NS_SCHEMA_OBJS || TO_CHAR(p_schemaid), C_CONNECTIONTYPE_SCRATCH);
     
  END LOOP;
  close cv_curs;	
END insert_all_sequences;

PROCEDURE insert_all_unpackaged_sps(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                    p_schemaid MD_SCHEMAS.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_STORED_PROGRAMS%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_STORED_PROGRAMS WHERE SCHEMA_ID_FK = ' || p_schemaid || ' AND PACKAGE_ID_FK IS NULL';
  v_newName MD_STORED_PROGRAMS.NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;

BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.NAME);
    if v_row.NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_STORED_PROGRAMS, v_row.id, C_OBJECTTYPE_STORED_PROGRAMS, p_connectionid, v_transformed,
                  v_row.NAME, v_newName, C_NS_SCHEMA_OBJS || TO_CHAR(p_schemaid), C_CONNECTIONTYPE_SCRATCH);
     
  END LOOP;
  close cv_curs;	
END insert_all_unpackaged_sps;


PROCEDURE insert_all_schobjs_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                            p_schemaid MD_SCHEMAS.ID%TYPE)
IS 
BEGIN
  insert_all_tables_cascade(p_connectionid, p_schemaid);
  insert_all_views(p_connectionid, p_schemaid);
  insert_all_sequences(p_connectionid, p_schemaid);
  insert_all_unpackaged_sps(p_connectionid, p_schemaid);
END insert_all_schobjs_cascade;	  
                                              

PROCEDURE insert_catalogs_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                  p_catalogid MD_CATALOGS.ID%TYPE)
IS
  cv_curs REF_CURSOR; 
  v_selectStmt VARCHAR2(4000) := 'SELECT a.id schema_id, A.name schema_name, b.id catalog_id, B.CATALOG_NAME, B.DUMMY_FLAG, A.type, A.character_set, A.version_tag 
      FROM MD_SCHEMAS A, MD_CATALOGS B
      WHERE 
      	A.CATALOG_ID_FK = B.ID 
        AND B.ID =' || p_catalogid  || 
        ' AND CONNECTION_ID_FK = ' || p_connectionid ;
  v_derivedRec  DERIVATIVE_REC;
  v_newName MD_SCHEMAS.NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;
BEGIN
   OPEN cv_curs FOR v_selectStmt;
   LOOP
     FETCH cv_curs INTO v_derivedRec;
     EXIT WHEN cv_curs%NOTFOUND;
     
     if v_derivedRec.dummy_flag  <> C_DUMMYFLAG_TRUE then
        v_newName := v_derivedRec.schema_name || '_' || v_derivedRec.catalog_name;
        v_transformed := C_TRANSFORMED_TRUE;
     else
	    v_newName := v_derivedRec.schema_name;
     end if;
     
     if v_newName <> MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_newName) then
        v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_newName);
        v_transformed := C_TRANSFORMED_TRUE;
     end if;
     
     INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES (v_derivedRec.schema_id, C_OBJECTTYPE_SCHEMAS, v_derivedRec.schema_id, C_OBJECTTYPE_SCHEMAS, p_connectionid, v_transformed,
                  v_derivedRec.schema_name, v_newName, C_NS_DATABASE, C_CONNECTIONTYPE_SCRATCH);
     
     INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_derivedRec.catalog_id, C_OBJECTTYPE_CATALOGS, v_derivedRec.catalog_id, C_OBJECTTYPE_SCHEMAS, p_connectionid, v_transformed, 
                  v_derivedRec.catalog_name, v_newName, NULL, C_CONNECTIONTYPE_SCRATCH);
      
     insert_all_schobjs_cascade(p_connectionid, v_derivedRec.schema_id);
     
   END LOOP;
   close cv_curs;
END insert_catalogs_cascade;


PROCEDURE insert_connection_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE)
IS
  v_connectionsRow MD_CONNECTIONS%ROWTYPE;
  v_origName MD_CONNECTIONS.NAME%TYPE;
  v_newName MD_CONNECTIONS.NAME%TYPE;
  v_id MD_CONNECTIONS.ID%TYPE;
  v_catid MD_CATALOGS.ID%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;
  cv_curs REF_CURSOR;
    
BEGIN
  SELECT * INTO v_connectionsRow from MD_CONNECTIONS WHERE "ID" = p_connectionid;
      v_origName := v_connectionsRow.NAME;
      v_newName := v_origName;
      v_id := v_connectionsRow.ID;
      
      if v_newName <> MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_newName) then
        v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_newName);
        v_transformed := C_TRANSFORMED_TRUE;
      end if;
      
      INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                      ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_id , C_OBJECTTYPE_CONNECTIONS, v_id, C_OBJECTTYPE_CONNECTIONS, v_id, v_transformed, 
                      v_origName, v_newName, '', C_CONNECTIONTYPE_SCRATCH);
  
  OPEN cv_curs FOR 'SELECT id from MD_CATALOGS where connection_id_fk ='|| v_connectionsRow.id;
  LOOP
    FETCH cv_curs INTO v_catid;
    EXIT WHEN cv_curs%NOTFOUND;
                       
      insert_catalogs_cascade(v_id, v_catid);
   END LOOP;   
END insert_connection_cascade;

PROCEDURE populate_derivatives_table(p_connectionid MD_CONNECTIONS.ID%TYPE)
IS
BEGIN
  insert_connection_cascade(p_connectionid);
END populate_derivatives_table;

--
-- reverts NEW_IDENTIFIER values back to their default(derived) values in MD_DERIVATIVES table.
--
PROCEDURE revert_derivatives_table(p_connectionid MD_CONNECTIONS.ID%TYPE)
IS
  cv_curs REF_CURSOR;  
  v_row MD_DERIVATIVES%ROWTYPE;
  v_origName MD_DERIVATIVES.ORIGINAL_IDENTIFIER%TYPE;
  v_derivedName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_DERIVATIVES 
         WHERE DERIVED_CONNECTION_ID_FK = ' || p_connectionid ;
BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_transformed := NULL;
    v_derivedName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.ORIGINAL_IDENTIFIER);
    if v_row.NEW_IDENTIFIER <> v_derivedName then
      if v_row.ORIGINAL_IDENTIFIER <> v_derivedName then
         v_transformed := C_TRANSFORMED_TRUE;
      end if;
      
      UPDATE MD_DERIVATIVES SET TRANSFORMED = v_transformed, NEW_IDENTIFIER = v_derivedName WHERE 
         SRC_ID = v_row.SRC_ID and DERIVED_CONNECTION_ID_FK = p_connectionid ;
    end if;
  END LOOP;
  CLOSE cv_curs;
END revert_derivatives_table;


-- One time initialisation
begin
NULL;
end;

/
--------------------------------------------------------
--  DDL for Package Body MIGRATION_REPORT
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "OSMUNDO"."MIGRATION_REPORT" AS
--Function getCaptureStatus
FUNCTION getCaptureStatus(srcid IN NUMBER)  RETURN VARCHAR2 IS
status VARCHAR(20) default ' ';
BEGIN
  select decode((select count(*) from migrlog where ref_object_id=srcid and severity>800),0,'Passed','Failed') into status from dual;
  return status;
END getCaptureStatus;
--Function getConvertStatus
FUNCTION getConvertStatus(srcid IN NUMBER,convert_conn_id IN NUMBER)  RETURN VARCHAR2 IS
status VARCHAR(20) default ' ';
ifconvert NUMBER default 0;
BEGIN
  SELECT count(*) into ifconvert FROM md_derivatives WHERE src_id=srcid and derived_connection_id_fk=convert_conn_id;
  IF ifconvert=0 THEN
      RETURN 'NotConverted';
  ELSIF getCaptureStatus(srcid)='Failed' THEN
     RETURN 'Failed';
  ELSE
   BEGIN
    SELECT 
   decode((SELECT DISTINCT severity from migrlog 
                  WHERE  ref_object_id IN (SELECT derived_id FROM md_derivatives WHERE src_id=srcid and derived_connection_id_fk= convert_conn_id) 
                         and severity=1000
           UNION
           SELECT DISTINCT severity from migrlog 
                  WHERE ref_object_id IN (SELECT derived_id FROM md_derivatives where src_id=srcid and derived_connection_id_fk=convert_conn_id)
                  AND severity=900 
                  AND logtext like '%limitation%'),
                  null,'Passed',1000,'Failed',900,'Limitation',' ') 
  into status from dual;
  return status;
  END;
  END IF;
END getConvertStatus;
--Function getGenerateStatus
FUNCTION getGenerateStatus(srcid IN number,convert_conn_id IN NUMBER)  RETURN VARCHAR2 IS
status VARCHAR(20) default ' ';

BEGIN
   status:=getConvertStatus(srcid,convert_conn_id);   
   IF status='NotConverted' THEN
      RETURN 'NotGenerated';
   ELSIF  status='Failed'  THEN
      RETURN 'Failed';      
   ELSE
     BEGIN
        SELECT 
           decode((SELECT count(*) FROM migrlog 
                   WHERE ref_object_id IN (SELECT derived_id FROM md_derivatives WHERE src_id=srcid and derived_connection_id_fk=convert_conn_id) 
                         AND phase='Generate'
                         AND severity>800),
                    0,'Passed','Failed')
             INTO status FROM dual;
        RETURN status;
    END;
   END IF;
END getGenerateStatus;
--migration details for each objects
FUNCTION getDetails(capture_conn_id IN NUMBER,convert_conn_id IN NUMBER) RETURN migr_report_detail_table PIPELINED IS
BEGIN
FOR cur IN (
    select allobjs.ObjID captured_id,
           allobjs.ObjName captured_name,
           md.new_identifier converted_name,
           allobjs.ObjType captured_type,
           decode(md.derived_type,'MD_INDEXES', substr(md.derived_type,4, length(md.derived_type)-5),substr(md.derived_type,4, length(md.derived_type)-4)) converted_type,
           allobjs.CaptureStatus capture_status,
           allobjs.ConvertStatus convert_status,
           allobjs.GenerateStatus generate_status,
           decode(mlog.logtext,null,' ',mlog.logtext) logtext from (
 --schema
     SELECT md_schemas.id ObjID,md_schemas.name ObjName,'SCHEMA' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_schemas.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_schemas.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_schemas.id,convert_conn_id) GenerateStatus
       FROM md_schemas,md_catalogs
       WHERE md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id
--table
UNION ALL
      SELECT md_tables.id ObjID,md_tables.table_name ObjName,'TABLE' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_tables.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_tables.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_tables.id,convert_conn_id) GenerateStatus
       FROM md_tables,md_schemas,md_catalogs
       WHERE md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id
--view
UNION ALL
      SELECT md_views.id ObjID,md_views.view_name ObjName,'View' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_views.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_views.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_views.id,convert_conn_id) GenerateStatus
       FROM md_views,md_schemas,md_catalogs
       WHERE md_views.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id
--storedprogram
UNION ALL
      SELECT md_stored_programs.id ObjID,md_stored_programs.name ObjName,'STORED_PROGRAM' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_stored_programs.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_stored_programs.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_stored_programs.id,convert_conn_id) GenerateStatus
       FROM md_stored_programs,md_schemas,md_catalogs
       WHERE md_stored_programs.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id
--index
UNION ALL
      SELECT md_indexes.id ObjID,md_indexes.index_name ObjName,'INDEX' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_indexes.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_indexes.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_indexes.id,convert_conn_id) GenerateStatus
       FROM md_indexes, md_tables,md_schemas,md_catalogs
       WHERE md_indexes.table_id_fk= md_tables.id
            AND md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id
UNION ALL
      SELECT md_constraints.id ObjID,md_constraints.name ObjName,'CONSTRAINT' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_constraints.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_constraints.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_constraints.id,convert_conn_id) GenerateStatus
       FROM md_constraints, md_tables,md_schemas,md_catalogs
       WHERE md_constraints.table_id_fk= md_tables.id
            AND md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id  
UNION ALL
      SELECT md_triggers.id ObjID,md_triggers.trigger_name ObjName,'TRIGGER' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_triggers.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_triggers.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_triggers.id,convert_conn_id) GenerateStatus
       FROM md_triggers, md_tables,md_schemas,md_catalogs
       WHERE md_triggers.table_or_view_id_fk=md_tables.id
            AND md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id 
UNION ALL
       SELECT md_triggers.id ObjID,md_triggers.trigger_name ObjName,'TRIGGER' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_triggers.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_triggers.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_triggers.id,convert_conn_id) GenerateStatus
       FROM md_triggers, md_views,md_schemas,md_catalogs
       WHERE md_triggers.table_or_view_id_fk=md_views.id
            AND md_views.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id
  ) allobjs left join (select md_derivatives.src_id,migrlog.logtext 
                        from migrlog,md_derivatives 
                        where migrlog.ref_object_id = md_derivatives.derived_id or migrlog.ref_object_id=md_derivatives.src_id) mlog 
                                on allobjs.objid=mlog.src_id  left join md_derivatives md on allobjs.objid=md.src_id
    ) 
  LOOP
     PIPE ROW(MIGR_REPORT_DETAIL_ROW(cur.captured_id,
                              cur.captured_name,
                              cur.converted_name,
                              cur.captured_type,
                              cur.converted_type,
                              cur.capture_status,
                              cur.convert_status,
                              cur.generate_status,
                              cur.logtext
                              ));       
    
  END LOOP;  
  RETURN;
 END getDetails; 

--migration summary
FUNCTION getSum(capture_conn_id IN NUMBER,convert_conn_id IN NUMBER) RETURN migr_report_sum_table PIPELINED IS
--
capture_passed_schema number default 0;
capture_passed_table number default 0;
capture_passed_view number default 0;
capture_passed_sp number default 0;
capture_passed_index number default 0;
capture_passed_constraint number default 0;
capture_passed_trigger number default 0;
--
capture_failed_schema number default 0;
capture_failed_table number default 0;
capture_failed_view number default 0;
capture_failed_sp number default 0;
capture_failed_index number default 0;
capture_failed_constraint number default 0;
capture_failed_trigger number default 0;
--
convert_passed_schema number default 0;
convert_passed_table number default 0;
convert_passed_view number default 0;
convert_passed_sp number default 0;
convert_passed_index number default 0;
convert_passed_constraint number default 0;
convert_passed_trigger number default 0;
--
convert_limit_schema number default 0;
convert_limit_table number default 0;
convert_limit_view number default 0;
convert_limit_sp number default 0;
convert_limit_index number default 0;
convert_limit_constraint number default 0;
convert_limit_trigger number default 0;
--
convert_failed_schema number default 0;
convert_failed_table number default 0;
convert_failed_view number default 0;
convert_failed_sp number default 0;
convert_failed_index number default 0;
convert_failed_constraint number default 0;
convert_failed_trigger number default 0;
--
convert_not_schema number default 0;
convert_not_table number default 0;
convert_not_view number default 0;
convert_not_sp number default 0;
convert_not_index number default 0;
convert_not_constraint number default 0;
convert_not_trigger number default 0;
--
generate_passed_schema number default 0;
generate_passed_table number default 0;
generate_passed_view number default 0;
generate_passed_sp number default 0;
generate_passed_index number default 0;
generate_passed_constraint number default 0;
generate_passed_trigger number default 0;
--
generate_failed_schema number default 0;
generate_failed_table number default 0;
generate_failed_view number default 0;
generate_failed_sp number default 0;
generate_failed_index number default 0;
generate_failed_constraint number default 0;
generate_failed_trigger number default 0;
--
generate_not_schema number default 0;
generate_not_table number default 0;
generate_not_view number default 0;
generate_not_sp number default 0;
generate_not_index number default 0;
generate_not_constraint number default 0;
generate_not_trigger number default 0;
--CURSORS
--SCHEMAS CURSOR
CURSOR schema_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_schemas.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_schemas.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_schemas.id,did) GenerateStatus
       FROM md_schemas,md_catalogs
       WHERE md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;
--TABLES CURSOR
CURSOR table_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_tables.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_tables.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_tables.id,did) GenerateStatus
       FROM md_tables,md_schemas,md_catalogs
       WHERE md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;
--VIEWS CURSOR
CURSOR view_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_views.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_views.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_views.id,did) GenerateStatus
       FROM md_views,md_schemas,md_catalogs
       WHERE md_views.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;
--STORED_PROGRAMS CURSOR
CURSOR sp_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_stored_programs.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_stored_programs.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_stored_programs.id,did) GenerateStatus
       FROM md_stored_programs,md_schemas,md_catalogs
       WHERE md_stored_programs.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;
--INDEXES CURSOR
CURSOR index_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_indexes.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_indexes.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_indexes.id,did) GenerateStatus
       FROM md_indexes, md_tables,md_schemas,md_catalogs
       WHERE md_indexes.table_id_fk= md_tables.id
            AND md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;
--CONSTRAINTS CURSOR
CURSOR constraint_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_constraints.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_constraints.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_constraints.id,did) GenerateStatus
       FROM md_constraints, md_tables,md_schemas,md_catalogs
       WHERE md_constraints.table_id_fk= md_tables.id
            AND md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;  
--TRIGGERS CURSOR
CURSOR trigger_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_triggers.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_triggers.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_triggers.id,did) GenerateStatus
       FROM md_triggers, md_tables,md_schemas,md_catalogs
       WHERE md_triggers.table_or_view_id_fk=md_tables.id
            AND md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid 
       UNION ALL
       SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_triggers.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_triggers.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_triggers.id,did) GenerateStatus
       FROM md_triggers, md_views,md_schemas,md_catalogs
       WHERE md_triggers.table_or_view_id_fk=md_views.id
            AND md_views.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;
BEGIN
 --count
 --schemas
 FOR cur IN schema_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_schema:=capture_failed_schema+1;
                ELSE capture_passed_schema:=capture_passed_schema+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_schema:=convert_failed_schema+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_schema:=convert_limit_schema+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_schema:=convert_passed_schema+1;
                 ELSE   convert_not_schema:=convert_not_schema+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_schema:=generate_failed_schema+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_schema:=generate_passed_schema+1;
                ELSE  generate_not_schema:=generate_not_schema+1;
                END IF;            
 END LOOP;
 --tables
 FOR cur IN table_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_table:=capture_failed_table+1;
                ELSE capture_passed_table:=capture_passed_table+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_table:=convert_failed_table+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_table:=convert_limit_table+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_table:=convert_passed_table+1;
                 ELSE   convert_not_table:=convert_not_table+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_table:=generate_failed_table+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_table:=generate_passed_table+1;
                ELSE  generate_not_table:=generate_not_table+1;
                END IF;            
 END LOOP;
 --views
 FOR cur IN view_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_view:=capture_failed_view+1;
                ELSE capture_passed_view:=capture_passed_view+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_view:=convert_failed_view+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_view:=convert_limit_view+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_view:=convert_passed_view+1;
                 ELSE   convert_not_view:=convert_not_view+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_view:=generate_failed_view+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_view:=generate_passed_view+1;
                ELSE  generate_not_view:=generate_not_view+1;
                END IF;            
 END LOOP;
 --stored programs
 FOR cur IN sp_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_sp:=capture_failed_sp+1;
                ELSE capture_passed_sp:=capture_passed_sp+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_sp:=convert_failed_sp+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_sp:=convert_limit_sp+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_sp:=convert_passed_sp+1;
                 ELSE   convert_not_sp:=convert_not_sp+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_sp:=generate_failed_sp+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_sp:=generate_passed_sp+1;
                ELSE  generate_not_sp:=generate_not_sp+1;
                END IF;            
 END LOOP;
 --index
 FOR cur IN index_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_index:=capture_failed_index+1;
                ELSE capture_passed_index:=capture_passed_index+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_index:=convert_failed_index+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_index:=convert_limit_index+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_index:=convert_passed_index+1;
                 ELSE   convert_not_index:=convert_not_index+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_index:=generate_failed_index+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_index:=generate_passed_index+1;
                ELSE  generate_not_index:=generate_not_index+1;
                END IF;            
 END LOOP;
 --constraints
 FOR cur IN constraint_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_constraint:=capture_failed_constraint+1;
                ELSE capture_passed_constraint:=capture_passed_constraint+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_constraint:=convert_failed_constraint+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_constraint:=convert_limit_constraint+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_constraint:=convert_passed_constraint+1;
                 ELSE   convert_not_constraint:=convert_not_constraint+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_constraint:=generate_failed_constraint+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_constraint:=generate_passed_constraint+1;
                ELSE  generate_not_constraint:=generate_not_constraint+1;
                END IF;            
 END LOOP;
 --triggers
 FOR cur IN trigger_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_trigger:=capture_failed_trigger+1;
                ELSE capture_passed_trigger:=capture_passed_trigger+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_trigger:=convert_failed_trigger+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_trigger:=convert_limit_trigger+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_trigger:=convert_passed_trigger+1;
                 ELSE   convert_not_trigger:=convert_not_trigger+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_trigger:=generate_failed_trigger+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_trigger:=generate_passed_trigger+1;
                ELSE  generate_not_trigger:=generate_not_trigger+1;
                END IF;            
 END LOOP; 
 --source exists row
  FOR cur IN (  
      SELECT 
        'Source Exists' Label,
         num_schemas,
         num_tables,
         num_indexes,
         num_constraints,
         num_views,
         num_stored_programs,        
         num_triggers
         FROM  md_connections
         WHERE type IS NULL and id=capture_conn_id
 )
 LOOP
   PIPE ROW(MIGR_REPORT_SUM_ROW(
           cur.Label, 
           cur.num_schemas,
           cur.num_tables,
           cur.num_indexes,
           cur.num_constraints,
           cur.num_views,
           cur.num_triggers,
           cur.num_stored_programs
             ));
 END LOOP; 
   PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Capture Passed', 
           capture_passed_schema,
           capture_passed_table,
           capture_passed_index,
           capture_passed_constraint,
           capture_passed_view,
           capture_passed_trigger,
           capture_passed_sp
             ));
  PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Capture Failed', 
           capture_failed_schema,
           capture_failed_table,
           capture_failed_index,
           capture_failed_constraint,
           capture_failed_view,
           capture_failed_trigger,
           capture_failed_sp
             ));
             
  PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Convert Passed', 
           convert_passed_schema,
           convert_passed_table,
           convert_passed_index,
           convert_passed_constraint,
           convert_passed_view,
           convert_passed_trigger,
           convert_passed_sp
             ));
  PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Convert Limitation', 
           convert_limit_schema,
           convert_limit_table,
           convert_limit_index,
           convert_limit_constraint,
           convert_limit_view,
           convert_limit_trigger,
           convert_limit_sp
             ));
  PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Convert Failed', 
           convert_failed_schema,
           convert_failed_table,
           convert_failed_index,
           convert_failed_constraint,
           convert_failed_view,
           convert_failed_trigger,
           convert_failed_sp
             ));
             
  PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Generate Passed', 
           generate_passed_schema,
           generate_passed_table,
           generate_passed_index,
           generate_passed_constraint,
           generate_passed_view,
           generate_passed_trigger,
           generate_passed_sp
             ));
  PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Generate Failed', 
           generate_failed_schema,
           generate_failed_table,
           generate_failed_index,
           generate_failed_constraint,
           generate_failed_view,
           generate_failed_trigger,
           generate_failed_sp
             )); 
  RETURN;
END getSum;
END MIGRATION_REPORT;

/
--------------------------------------------------------
--  DDL for Package Body MIGRATION_TRANSFORMER
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "OSMUNDO"."MIGRATION_TRANSFORMER" AS
  -- Maximum length of an identifier
  MAX_IDENTIFIER_LEN NUMBER:=30;
C_DISALLOWED_CHARS   CONSTANT NVARCHAR2(100) := ' .@`!"%^&*()-+=[]{};:,.<>?/~'''||UNISTR('\00A3');

--PRIVATE FUNCTION
FUNCTION truncateStringByteSize(p_work VARCHAR2, p_bsize NUMBER) RETURN VARCHAR2
IS
v_work VARCHAR2(4000);
v_bsize NUMBER(10);
BEGIN
 IF LENGTHB(p_work) <= p_bsize THEN
    return p_work;
  END IF;
  v_work := p_work;
  v_work := SUBSTRB(v_work, 1, p_bsize);
  WHILE INSTRC(p_work, v_work , 1, 1) <> 1 LOOP -- a character has been cut in half or in 2/3 or 3/4 by substrb (multibyte can have up to 4 bytes) 
  --note each left over corrupt byte can be a single character
   BEGIN
     v_bsize := LENGTHB(v_work);
  	 v_work := SUBSTRB(v_work, 1, v_bsize-1);
   END;
  END LOOP; 
  return v_work;
END;

FUNCTION add_suffix(p_work VARCHAR2, p_suffix VARCHAR2, p_maxlen NUMBER) RETURN VARCHAR2
IS
  v_suflen NUMBER := LENGTHB(p_suffix);
  v_truncamount NUMBER;
BEGIN
  IF LENGTHB(p_work) < p_maxlen - v_suflen THEN
    RETURN p_work || p_suffix;
  END IF;
  v_truncamount := LENGTHB(p_work) + v_suflen - p_maxlen;
  RETURN truncateStringByteSize(p_work, LENGTHB(p_work)-v_truncamount) || p_suffix;
END add_suffix;
  

FUNCTION check_identifier_length(p_ident VARCHAR2) RETURN VARCHAR2
IS
  v_work VARCHAR2(4000);
BEGIN
  return truncateStringByteSize(p_ident,  MAX_IDENTIFIER_LEN);
END;

FUNCTION check_reserved_word(p_work VARCHAR2) RETURN VARCHAR2
IS
  v_count NUMBER := 0;
BEGIN
  SELECT COUNT(*) INTO v_count FROM MIGRATION_RESERVED_WORDS WHERE KEYWORD = UPPER(p_work);
  IF v_count > 0 THEN
    -- It is a reserved word
    RETURN add_suffix(p_work, '_', MAX_IDENTIFIER_LEN);
  END IF;
  RETURN p_work;
END check_reserved_word;

FUNCTION sys_check(p_work VARCHAR2) RETURN VARCHAR2
IS
BEGIN
  IF LENGTH(p_work) < 4 THEN
    return p_work;
  END IF;
  IF SUBSTR(p_work, 1, 4) <> 'SYS_' THEN
    return p_work;
  END IF;
  RETURN 'SIS_' || SUBSTR(p_work, 5);
END sys_check;

FUNCTION first_char_check(p_work NVARCHAR2) RETURN NVARCHAR2
/**
 * Never want to start with anything but AlphaNumeri
 */
IS
  v_firstChar NCHAR(1);
  v_allowed NCHAR(200);
BEGIN
  v_allowed := C_DISALLOWED_CHARS || '0123456789_$#';
  v_firstChar := SUBSTR(p_work,1,1);
  if INSTR(v_allowed, v_firstChar) > 0 THEN
    return 'A' ||p_work;
  END IF;
  return p_work;
END first_char_check;



FUNCTION lTrimNonAlphaNumeric(p_work NVARCHAR2) RETURN NVARCHAR2
/**
 *Remove all non alphanumeric characters from the start 
 */
IS
  v_testChar VARCHAR2(2000);
  v_index NUMBER;
  v_work NVARCHAR2(4000):=p_work;
  v_forbiddenChars VARCHAR2(100);
  v_firstgoodchar NUMBER;
BEGIN
  v_forbiddenChars := C_DISALLOWED_CHARS ||'_$#';
   FOR v_index in 1..LENGTH(v_work) LOOP
    v_testChar := SUBSTR(p_work, v_index, 1);
    IF INSTR(v_forbiddenChars, v_testChar) <= 0 THEN
      v_firstgoodchar := v_index;
      EXIT;--make sure to leave loop now as first real char reached
    END IF;
  END LOOP;
  return substr(p_work,v_firstgoodchar);
END lTrimNonAlphaNumeric;

FUNCTION removeQuotes(p_work NVARCHAR2) RETURN NVARCHAR2
/**
 * Removed Quotes around a identifier name
 */
IS
  v_firstChar NCHAR(1);
  v_lastChar NCHAR(1);
  v_quote NCHAR(200):= '"[]'; -- strip these from start and end;
  v_work NVARCHAR2(4000) := p_work;
BEGIN
  v_firstChar := SUBSTR(v_work,1,1);
  v_lastChar  := SUBSTR(v_work,LENGTH(v_work),1);
  if INSTR(v_quote, v_firstChar) > 0 THEN
  	v_work := SUBSTR(v_work, 2);
  	if INSTR(v_quote, v_lastChar) > 0 THEN
  	  v_work := SUBSTR(v_work,0,LENGTH(v_work)-1);
      return v_work;
    END IF;
      return v_work;
  END IF;
  return v_work;
END removeQuotes;


FUNCTION check_allowed_chars(p_work NVARCHAR2) RETURN NVARCHAR2
/* The documentation states 
 * "Nonquoted identifiers can contain only alphanumeric characters from your database character set and the
 *  underscore (_), dollar sign ($), and pound sign (#). Database links can also contain periods (.) and "at" signs (@).
 *  Oracle strongly discourages you from using $ and # in nonquoted identifiers."
 *  Heres a couple of gotchas
 *  1) We don't know where we will be generated to, so dunno what that database character set will be
 *  2) We've now way of knowing if a character is alphanumeric on the character set.
 * So... Here's what we'll do
 *  1) given that its come from a database, we'll assume with was alphanumeric
 *  2) We'll remove any "regular" symbol characters (i.e. one's on my keyboard!)
 *  3) We'll be storing in NVARCHAR2 in the hope that this will preserve everything.
 * 
 */
IS
  v_testChar VARCHAR2(2000);
  v_index NUMBER;
  -- Folowing syntax is a workaround for a problem with wrap.  Do not change it.
  v_forbiddenChars NVARCHAR2(100) := C_DISALLOWED_CHARS;
  v_work VARCHAR2(4000) := p_work;
  v_endswithunderscore boolean := FALSE;
BEGIN
  IF INSTR('_',SUBSTR(p_work, LENGTH(p_work))) >0 THEN
    v_endswithunderscore := TRUE;
  END IF;
  
 
  FOR v_index in 1..LENGTH(v_work) LOOP
    v_testChar := SUBSTR(p_work, v_index, 1);
     
    --check for existing underscores.these existed in the original and should be preserved as later we remove multiple underscores
    --bug:10405027
    IF v_testChar = '_' THEN
    	v_work :=SUBSTR(v_work,1,v_index-1)||'!' || SUBSTR(v_work,v_index+1);
    ELSIF INSTR(v_forbiddenChars, v_testChar) > 0 THEN
      v_work := SUBSTR(v_work, 1, v_index-1) || '_' || SUBSTR(v_work, v_index+1);
    END IF;
  END LOOP;
 
  --NOW REMOVE DOUBLE UNDERSCORES see bug 6647397
  v_work := replace(replace (replace (v_work,'__','_'),'__','_'),'__','_');--replace 2 underscores with 1 underscore
 
  --bug:10405027 , original underscore and a new one
  v_work := replace(v_work,'!_','_');
  v_work := replace(v_work,'_!','_'); 
  	
  --NOW ADD BACK IN EXISTING ORGINAL UNDERSCORES bug:10405027
  v_work := replace(v_work,'!','_');
  
  --REMOVE THE LT CHAR IF IT IS AN UNDERSCORE
  IF v_endswithunderscore=false AND INSTR('_',SUBSTR(v_Work,LENGTH(v_work))) > 0 THEN
    v_work := SUBSTR(v_work,0,LENGTH(v_work)-1);
  END IF;
  return v_work;
END check_allowed_chars;

FUNCTION transform_identifier(p_identifier NVARCHAR2)  RETURN NVARCHAR2
IS
  v_work VARCHAR2(4000);
BEGIN
  v_work := p_identifier;
  
  -- There are 10 rules defined for identifier naming:
  -- See http://st-doc.us.oracle.com/10/102/server.102/b14200/sql_elements008.htm#i27570
 
  v_work := removeQuotes(v_work);
  v_work := lTrimNonAlphaNumeric(v_work);
  IF v_work is null THEN
    v_work := getNameForNullCase(p_identifier);	 ---bug no. 8904200 
  END IF;
  
  --moving this to first as we can shrink the size of the name if they have more than 1 invalid char in a row.
  --see bug 6647397
   -- 5. Must begin withan alpha character from your character set
  v_work := first_char_check(v_work);
   -- 6. Alphanumeric characters from your database charset plus '_', '$', '#' only
  v_work := check_allowed_chars(v_work);
  -- 1. Length
  v_work := check_identifier_length(v_work);
  -- 2. Reserved words
  v_work := check_reserved_word(v_work);
  -- 3. "Special words" -I've handled these in reserved words, but still have to check if it starts with SYS
  v_work := sys_check(v_work);
  -- 4. "You should use ASCII characters in database names, global database names, and database link names,
  --    because ASCII characters provide optimal compatibility across different platforms and operating systems."
  -- This doesn't apply as we are not doing anything with DB names
  -- 7. Name collisions; we'll handle this at a higher level.
  -- 8. Nonquoted identifiers are case insensitive.  This is a doubl edged sword: If we use quoted, we can possible
  --    Keep it similar to the source platform.  However this is not how it is typically done in Oracle.
  -- 9. Columns in the same table.  See point 7. above.
  -- 10. All about overloading for functions and parameters.  We don't have to handle this here either, at this
  --     Should all be done by parsing technology.
  return v_work;
END transform_identifier;
FUNCTION fix_all_schema_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  v_ret NUMBER;
BEGIN
  v_ret := 0;
  -- First, we transform all identifiers to meet our rules
  -- Then, we need to see if we've caused any collisions in the process
  -- And if so, fix them
  -- Right now, this is a dummy stub.
  return v_ret;
END fix_all_schema_identifiers;

FUNCTION fix_all_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  v_ret NUMBER;
BEGIN
  v_ret := fix_all_schema_identifiers(p_connectionid);
  return v_ret;
END fix_all_identifiers;  

FUNCTION getNameForNullCase(p_work NVARCHAR2) RETURN NVARCHAR2
IS
  v_work VARCHAR2(4000);
  v_testChar VARCHAR2(2000);
  v_index NUMBER;
BEGIN
  FOR v_index in 1..LENGTH(p_work) LOOP
    v_testchar := SUBSTR(p_work,v_index,1);
    v_work := v_work || getDisallowedCharsNames(v_testchar);
  END LOOP;
  return v_work;
END;

FUNCTION getDisallowedCharsNames(p_work NVARCHAR2) RETURN VARCHAR2
IS
  v_work VARCHAR2(4000) := p_work;
BEGIN
  ----' .@`!"%^&*()-+=[]{};:,.<>?/~''' 
    v_work := ( CASE p_work
    WHEN '.' THEN 'DOT'
    WHEN '@' THEN 'AT'
    WHEN '`' THEN 'APOSTROPHE'
    WHEN '!' THEN 'EXCLAMATION'
    WHEN '"' THEN 'D_QUOTE'
    WHEN '%' THEN 'PERCENT'
    WHEN '^' THEN 'CARET'
    WHEN '&' THEN 'AMPERSAND'
    WHEN '*' THEN 'STAR'
    WHEN '(' THEN 'LEFTPARENTHESIS'
    WHEN ')' THEN 'RIGHTPARANTHESIS'
    WHEN '-' THEN 'MINUS'
    WHEN '+' THEN 'PLUS'
    WHEN '=' THEN 'EQUAL'
    WHEN '[' THEN 'LEFTSQUARE_B'
    WHEN ']' THEN 'RIGHTSQUARE_B'
    WHEN '{' THEN 'LEFTCURLY_B'
    WHEN '}' THEN 'RIGHTCURLY_B'
    WHEN ';' THEN 'COLON'
    WHEN ':' THEN 'SEMICOLON'
    WHEN ',' THEN 'COMMA'
    WHEN '<' THEN 'LESSTHAN'
    WHEN '>' THEN 'GREATERTHAN'
    WHEN '?' THEN 'QUESTIONMARK'
    WHEN '~' THEN 'TILDE'
    WHEN '/' THEN 'BACKSLASH'
    WHEN '''' THEN 'S_QUOTE'
    WHEN '$' THEN 'DOLLAR'
    ELSE 'UNKNOWN'
    END);
    return v_work;
END;

END;

/
--------------------------------------------------------
--  DDL for Package Body OFS
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "OSMUNDO"."OFS" is
  type VC2_array is
    table of OFS_ITEMS.name%type index by pls_integer;

  -- Set of routines to raise exceptions and check conditions.
  procedure select_error(p_msg varchar2, p_path in varchar2) is
  begin
    raise_application_error(-20000, p_msg ||
      '. path=' || p_path);
  end;

  procedure unknown_attr_error(p_attr varchar2) is
  begin
    raise_application_error(-20000, 'OFS-9: Unknown attribute.' ||
      '. attr=' || p_attr);
  end;

  procedure path_not_found_error(p_path in varchar2) is
  begin
    select_error('OFS-7: Path not found', p_path);
  end;

  procedure check_is_file(p_type in OFS_ITEMS.item_type%type,
                          p_filename in varchar2) is
  begin
    if p_type <> 'F' then
      select_error('OFS-8: OFS item must be file', p_filename);
    end if;
  end;

  procedure check_is_directory(p_type in OFS_ITEMS.item_type%type,
                               p_filename in varchar2) is
  begin
    if p_type <> 'D' then
      select_error('OFS-10: OFS item must be directory', p_filename);
    end if;
  end;

  procedure already_locked_error(p_filename in varchar2) is
  begin
    select_error('OFS-13: File is already locked', p_filename);
  end;

  procedure already_unlocked_error(p_filename in varchar2) is
  begin
    select_error('OFS-14: File is already unlocked', p_filename);
  end;

  function unquote_name(p_name in varchar2) return varchar2 is
  begin
    if SubStr(p_name, 1, 1) = '"' and
       SubStr(p_name, Length(p_name), 1) = '"' then
      return SubStr(p_name, 2, Length(p_name) - 2);
    else
      return p_name;
    end if;
  end;

  -- Parses path
  -- p_path      The path to parse.
  -- p_raise_exc If True, then raise exception if path is not found.
  --             If False, then function return False if path not found.
  -- p_last_item Returns p_path last OFS item info.
  -- p_no_items  Returns collection of p_path not found names.
  -- Returns     True, if p_path found, else False.
  function path_to_item(p_path in varchar2,
                        p_raise_exc in boolean,
                        p_last_item out OFS_ITEMS%rowtype,
                        p_no_items out VC2_array) return boolean is
    path        varchar2(1000);
    item_name   OFS_ITEMS.name%type;
    i           pls_integer;
    prev_i      pls_integer;
    j           pls_integer;
    path_exists boolean;
  begin
    path := unquote_name(p_path);
    if path is null or path = '\' then
      path := '\*';
    else
      if SubStr(path, 1, 1) <> '\' then
        path := '\' || path;
      end if;
      if SubStr(path, Length(path), 1) = '\' then
        path := SubStr(path, 1, Length(path) - 1);
      end if;
    end if;
    prev_i := 1;
    path_exists := true;
    j := 1;
    p_last_item.id := 0;
    loop
      i := Instr(path, '\', prev_i + 1);
      if i = 0 then
        item_name := unquote_name(SubStr(path, prev_i + 1, Length(path)));
      else
        item_name := unquote_name(SubStr(path, prev_i + 1, i - (prev_i + 1)));
      end if;
      if path_exists then
        begin
          select *
            into p_last_item
            from OFS_ITEMS
            where parent_id = p_last_item.id and Upper(name) = Upper(item_name);
        exception
          when no_data_found then
            if p_raise_exc then
              path_not_found_error(p_path);
            end if;
            path_exists := false;
        end;
      end if;
      if not path_exists then
        p_no_items(j) := item_name;
        j := j + 1;
      end if;
      exit when i = 0;
      prev_i := i;
    end loop;
    return path_exists;
  end;

  -- Convert DOS file mask into Oracle LIKE mask
  function mask_to_like(p_mask in varchar2) return varchar2 is
    ch  char;
    res varchar2(300);
  begin
    if (p_mask is null) or (p_mask = '*.*') then
      return '%';
    else
      res := '';
      for i in 1 .. Length(p_mask) loop
        ch := SubStr(p_mask, i, 1);
        if ch = '?' then
          res := res || '_';
        elsif ch = '*' then
          res := res || '%';
        elsif (ch = '_') or (ch = '%') or (ch = '\') then
          res := res || '\' || ch;
        else
          res := res || ch;
        end if;
      end loop;
      return res;
    end if;
  end;

  -- Get directory entries.
  -- %param p_path    \dir1\dir2
  -- %param p_mask    hello*.da?[; mask2[; ...]]
  -- %param p_alldirs 'Y' - include all subdirs, 'N' - subdirs according mask
  -- %param p_crs     cursor with the matching directory entries
  procedure get_dir(p_path    in varchar2,
                    p_mask    in varchar2,
                    p_alldirs in varchar2,
                    p_crs     in out dir_cursor) is
    item       OFS_ITEMS%rowtype;
    no_items   VC2_array;
    ora_mask   varchar2(300);
    dir_q      varchar2(1000);
    i          pls_integer;
    prev_i     pls_integer;
    first_mask boolean;
  begin
    if not path_to_item(p_path, true, item, no_items) then
      return;
    end if;
    check_is_directory(item.item_type, p_path);
    dir_q :=
      'select ITEM_TYPE, NAME, DATE_CREATED, CREATED_BY,' ||
      ' DATE_MODIFIED, MODIFIED_BY, READ_ONLY, COMPRESSED,' ||
      ' dbms_lob.getlength(DATA) as DATA_LENGTH, LOCKED_BY, DATE_LOCKED ' ||
      'from OFS_ITEMS i ' ||
      'where PARENT_ID = :PID and PARENT_ID <> ID';
    prev_i := 0;
    first_mask := true;
    loop
      i := Instr(p_mask, ';', prev_i + 1);
      if i = 0 then
        ora_mask := SubStr(p_mask, prev_i + 1, Length(p_mask));
      else
        ora_mask := SubStr(p_mask, prev_i + 1, i - (prev_i + 1));
      end if;
      if Length(ora_mask) <> 0 then
        ora_mask := Upper(mask_to_like(ora_mask));
        if first_mask then
          dir_q := dir_q || ' and (';
          first_mask := false;
        else
          dir_q := dir_q || ' or ';
        end if;
        dir_q := dir_q || 'Upper(NAME) like ''' || ora_mask || ''' escape ''\''';
      end if;
      exit when i = 0;
      prev_i := i;
    end loop;
    if not first_mask and p_alldirs = 'Y' then
      dir_q := dir_q || ' or ITEM_TYPE = ''D''';
    end if;
    if not first_mask then
      dir_q := dir_q || ')';
    end if;
    dir_q := dir_q || ' order by ITEM_TYPE, NAME';
    open p_crs for dir_q using item.id;
  end;

  -- Read file data.
  -- %param p_filename \dir1\dir2\file.ext
  function read_file(p_filename in varchar2) return blob is
    item     OFS_ITEMS%rowtype;
    no_items VC2_array;
  begin
    if path_to_item(p_filename, true, item, no_items) then
      check_is_file(item.item_type, p_filename);
      if ofs_compress.is_active and item.compressed = 'Y' then
        return ofs_compress.uncomp(item.data);
      else
        return item.data;
      end if;
    else
      return null;
    end if;
  end;

  -- Write file data.
  -- File must be unlocked or locked by current OS user and not read_only.
  -- For new files, parent directory must not be read_only. New files in a
  -- compressed directory are implicitly compressed.
  -- %param p_filename \dir1\dir2\file.ext
  -- %param p_data temporary BLOB with all file data
  procedure write_file(p_filename in varchar2,
                       p_data     in blob) is
    item     OFS_ITEMS%rowtype;
    no_items VC2_array;
  begin
    if path_to_item(p_filename, false, item, no_items) then
      check_is_file(item.item_type, p_filename);
      update OFS_ITEMS
        set modified_by = OFS_private.os_user
        where id = item.id;
    else
      if no_items.count > 1 then
        path_not_found_error(p_filename);
      end if;
      insert into OFS_ITEMS (parent_id, item_type, name, data)
        values (item.id, 'F', no_items(1), empty_blob())
        returning data into item.data;
    end if;
    if ofs_compress.is_active and item.compressed = 'Y' then
      ofs_compress.comp(p_data, item.data);
    else
      dbms_lob.trim(item.data, 0);
      dbms_lob.append(item.data, p_data);
    end if;
  end;

  -- Create directory.
  -- Parent directory must not be read_only.
  -- %param p_dirname \dir1\dir
  procedure create_dir(p_dirname in varchar2) is
    item     OFS_ITEMS%rowtype;
    no_items VC2_array;
  begin
    if path_to_item(p_dirname, false, item, no_items) then
      check_is_directory(item.item_type, p_dirname);
      select_error('OFS-11: Specified directory already exists', p_dirname);
    else
      for i in 1 .. no_items.count loop
        insert into OFS_ITEMS (parent_id, item_type, name)
          values (item.id, 'D', no_items(i))
          returning id into item.id;
      end loop;
    end if;
  end;

  -- Delete file or directory.
  -- File must be unlocked or locked by current OS user and not read_only.
  -- Directory must not be read_only.
  -- Parent directory must not be read_only.
  -- %param p_dirname \dir1\dir or \dir1\file.ext
  procedure delete(p_itemname in varchar2) is
    item     OFS_ITEMS%rowtype;
    no_items VC2_array;
  begin
    if path_to_item(p_itemname, true, item, no_items) then
      delete from OFS_ITEMS
        where id = item.id;
    end if;
  end;

  -- Set file or directory attribute.
  -- File must be unlocked or locked by current OS user.
  -- Compression is ignored on Oracle9.2 or earlier (utl_compress dependency).
  -- %param p_itemname The name of the file or directory
  -- %param p_attrname 'READ_ONLY', 'COMPRESSED' or 'LOCKED'
  -- %param p_value    'Y' or 'N'
  procedure set_attr(p_itemname in varchar2,
                     p_attrname in varchar2,
                     p_value    in varchar2) is
    item     OFS_ITEMS%rowtype;
    no_items VC2_array;
    attrname varchar2(20);
    val      char(1);
    temp_lob blob;
  begin
    if path_to_item(p_itemname, true, item, no_items) then
      attrname := Upper(p_attrname);
      val := Upper(p_value);
      if attrname = 'READ_ONLY' then
        if item.read_only <> val then
          update OFS_ITEMS
            set read_only = val
            where id = item.id;
        end if;
      elsif attrname = 'COMPRESSED' then
        if item.compressed <> val then
          update OFS_ITEMS
            set compressed = val
            where id = item.id;
          if ofs_compress.is_active then
            dbms_lob.createtemporary(temp_lob, false);
            begin
              dbms_lob.append(temp_lob, item.data);
              if val = 'Y' then
                ofs_compress.comp(temp_lob, item.data);
              else
                ofs_compress.uncomp(temp_lob, item.data);
              end if;
            exception when others then
              dbms_lob.freetemporary(temp_lob);
              raise;
            end;
            dbms_lob.freetemporary(temp_lob);
          end if;
        end if;
      elsif attrname = 'LOCKED' then
        check_is_file(item.item_type, p_itemname);
        if val = 'Y' then
          if Upper(item.locked_by) = Upper(OFS_private.os_user) then
            already_locked_error(p_itemname);
          end if;
          update OFS_ITEMS
            set locked_by = OFS_private.os_user
            where id = item.id;
        elsif val = 'N' then
          if item.locked_by is null then
            already_unlocked_error(p_itemname);
          end if;
          update OFS_ITEMS
            set locked_by = null
            where id = item.id;
        end if;
      else
        unknown_attr_error(p_attrname);
      end if;
    end if;
  end;

  -- Get file or directory attribute.
  -- %param p_itemname The name of the file or directory
  -- %param p_attrname 'READ_ONLY', 'COMPRESSED' or 'LOCKED'
  -- %return 'Y' or 'N'
  function get_attr(p_itemname in varchar2,
                    p_attrname in varchar2) return varchar2 is
    item     OFS_ITEMS%rowtype;
    no_items VC2_array;
    attrname varchar2(20);
  begin
    if path_to_item(p_itemname, true, item, no_items) then
      attrname := Upper(p_attrname);
      if attrname = 'READ_ONLY' then
        return item.read_only;
      elsif attrname = 'COMPRESSED' then
        return item.compressed;
      elsif attrname = 'LOCKED' then
        if item.locked_by is not null then
          return 'Y';
        else
          return 'N';
        end if;
      elsif attrname = 'ID' then
        return to_char(item.id);
      else
        unknown_attr_error(p_attrname);
      end if;
    else
      return null;
    end if;
  end;

  -- Get file or directory last modification date.
  function get_date(p_itemname in varchar2) return date is
    item     OFS_ITEMS%rowtype;
    no_items VC2_array;
  begin
    if path_to_item(p_itemname, true, item, no_items) then
      return item.date_modified;
    else
      return null;
    end if;
  end;

  -- Lock file.
  -- File must be unlocked and not read_only.
  -- %param p_filename \dir1\dir2\file.ext
  procedure lock_file(p_filename in varchar2) is
  begin
    set_attr(p_filename, 'LOCKED', 'Y');
  end;

  -- Unlock file.
  -- File must be locked by current OS user
  -- %param p_filename \dir1\dir2\file.ext
  procedure unlock_file(p_filename in varchar2) is
  begin
    set_attr(p_filename, 'LOCKED', 'N');
  end;

  -- Rename file or directory.
  -- File must be unlocked or locked by current OS user and not read_only.
  -- %param p_itemname \dir1\dir2\file.ext
  -- %param p_newname  newfile.ext
  procedure rename(p_itemname in varchar2, p_newname in varchar2) is
    item      OFS_ITEMS%rowtype;
    no_items  VC2_array;
    item_name OFS_ITEMS.NAME%type;
  begin
    item_name := unquote_name(p_newname);
    if Instr(item_name, '\') <> 0 then
      select_error('OFS-12: New name must be without path', p_newname);
    end if;
    if path_to_item(p_itemname, true, item, no_items) then
      update OFS_ITEMS
        set name = item_name
        where id = item.id;
    end if;
  end;

  -- Move file or directory.
  -- File must be unlocked or locked by current OS user and not read_only.
  -- %param p_itemname \dir1\dir2\file.ext
  -- %param p_newdir   \dir1\dir2
  procedure move(p_itemname in varchar2, p_newdir in varchar2) is
    item1     OFS_ITEMS%rowtype;
    no_items1 VC2_array;
    item2     OFS_ITEMS%rowtype;
    no_items2 VC2_array;
  begin
    if path_to_item(p_itemname, true, item1, no_items1) and
       path_to_item(p_newdir, true, item2, no_items2) then
      update OFS_ITEMS
        set parent_id = item2.id
        where id = item1.id;
    end if;
  end;

  -- Copy file or directory.
  -- File must be unlocked or locked by current OS user and not read_only.
  -- %param p_itemname \dir1\dir2\file.ext
  -- %param p_newdir   \dir1\dir2
  procedure copy(p_itemname in varchar2, p_newdir in varchar2) is
    item1     OFS_ITEMS%rowtype;
    no_items1 VC2_array;
    item2     OFS_ITEMS%rowtype;
    no_items2 VC2_array;
  begin
    if path_to_item(p_itemname, true, item1, no_items1) and
       path_to_item(p_newdir, true, item2, no_items2) then
      if item1.item_type = 'D' then
        create_dir(p_newdir || '\' || item1.name);
        for c in (select name from OFS_ITEMS where parent_id = item1.id) loop
          copy(p_itemname || '\' || c.name, p_newdir || '\' || item1.name);
        end loop;
      else
        write_file(p_newdir || '\' || item1.name, item1.data);
      end if;
    end if;
  end;

  -- Tests if a specified file exists.
  -- %param p_filename \dir1\dir2\file.ext
  function file_exists(p_filename in varchar2) return char is
    item     OFS_ITEMS%rowtype;
    no_items VC2_array;
  begin
    if path_to_item(p_filename, false, item, no_items) and
       (item.item_type = 'F') then
      return 'Y';
    else
      return 'N';
    end if;
  end;

  -- Tests if a specified directory exists.
  -- %param p_path \dir1\dir2
  function directory_exists(p_path in varchar2) return char is
    item     OFS_ITEMS%rowtype;
    no_items VC2_array;
  begin
    if path_to_item(p_path, false, item, no_items) and
       (item.item_type = 'D') then
      return 'Y';
    else
      return 'N';
    end if;
  end;

  procedure init_root is
    i OFS_ITEMS.id%type;
  begin
    select id
      into i
      from OFS_ITEMS
      where id = 0;
  exception
    when others then
      insert into OFS_ITEMS (id, parent_id, item_type, name)
        values (0, 0, 'D', '*');
  end;

  function os_user return varchar2 is
  begin
    return ofs_private.os_user;
  end;

end OFS;

/
--------------------------------------------------------
--  DDL for Package Body OFS_COMPRESS
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "OSMUNDO"."OFS_COMPRESS" is
  function is_active return boolean is
  begin
    return true;
  end;

  procedure comp(src in     blob,
                 dst in out nocopy blob) is
  begin
    utl_compress.lz_compress(src, dst, 6);
  end;

  function uncomp(src in blob) return blob is
  begin
    return utl_compress.lz_uncompress(src);
  end;

  procedure uncomp(src in     blob,
                   dst in out nocopy blob) is
  begin
    utl_compress.lz_uncompress(src, dst);
  end;
end;

/
--------------------------------------------------------
--  DDL for Package Body OFS_PRIVATE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "OSMUNDO"."OFS_PRIVATE" is
  type changed_ID_rec is
    record (
      id        OFS_ITEMS.id%type,
      parent_id OFS_ITEMS.id%type,
      op        char(1)
    );
  type changed_ID_array is
    table of changed_ID_rec index by pls_integer;

  changed_IDs    changed_ID_array;
  changed_ID_ind pls_integer;
  g_os_user      OFS_ITEMS.created_by%type;

  procedure change_error(p_msg varchar2, p_id in OFS_ITEMS.id%type,
                         p_op in char) is
  begin
    raise_application_error(-20000, p_msg ||
      '. Op=' || p_op || ', id=' || to_char(p_id));
  end;

  procedure change_clear is
  begin
    changed_IDs.delete;
    changed_ID_ind := 1;
  end;

  procedure change_register(p_id in OFS_ITEMS.id%type,
                            p_parent_id in OFS_ITEMS.id%type,
                            p_op in char) is
  begin
    changed_IDs(changed_ID_ind).id := p_id;
    changed_IDs(changed_ID_ind).parent_id := p_parent_id;
    changed_IDs(changed_ID_ind).op := p_op;
    changed_ID_ind := changed_ID_ind + 1;
  end;

  procedure change_verify is
    parent_item OFS_ITEMS%rowtype;
    n           integer;
  begin
    for i in 1 .. changed_ID_ind - 1 loop
      if changed_IDs(i).id <> 0 then
        begin
          select count(*)
            into n
            from OFS_ITEMS
            where id <> parent_id
            start with id = changed_IDs(i).id
            connect by prior id <> prior parent_id and id = prior parent_id;
        exception
          when others then
            change_error('OFS-1: Circular directory references not allowed',
              changed_IDs(i).id, changed_IDs(i).op);
        end;
        begin
          select *
            into parent_item
            from OFS_ITEMS
            where id = changed_IDs(i).parent_id;
          if parent_item.item_type <> 'D' then
            change_error('OFS-2: Parent OFS item must be directory',
              changed_IDs(i).id, changed_IDs(i).op);
          end if;
          if (changed_IDs(i).op in ('I', 'D')) and
             (parent_item.read_only = 'Y') then
            change_error('OFS-3: Parent directory is read-only',
              changed_IDs(i).id, changed_IDs(i).op);
          end if;
        exception
          when no_data_found then
            if changed_IDs(i).op <> 'D' then
              raise;
            end if;
        end;
      end if;
    end loop;
    change_clear;
  exception
    when others then
      change_clear;
      raise;
  end;

  procedure change_verify_row(p_new_id in OFS_ITEMS.id%type,
    p_new_item_type in OFS_ITEMS.item_type%type,
    p_old_item_type in OFS_ITEMS.item_type%type,
    p_old_locked_by in OFS_ITEMS.locked_by%type,
    p_new_locked_by in OFS_ITEMS.locked_by%type,
    p_old_read_only in OFS_ITEMS.read_only%type,
    p_new_read_only in OFS_ITEMS.read_only%type,
    p_op in char) is
  begin
    if p_new_item_type <> p_old_item_type then
      change_error('OFS-4: OFS item type cannot be changed', p_new_id, p_op);
    end if;
    if p_new_item_type = 'F' then
      if (p_old_locked_by is not null) and (p_old_locked_by <> os_user) then
        change_error('OFS-5: File is locked by ' || p_old_locked_by, p_new_id, p_op);
      end if;
      if not (p_old_locked_by is not null and p_new_locked_by is null) and
         (p_old_read_only = p_new_read_only) and (p_new_read_only = 'Y') then
        change_error('OFS-6: File is read-only', p_new_id, p_op);
      end if;
    elsif p_new_item_type = 'D' then
      if p_new_locked_by is not null then
        change_error('OFS-15: Cannot lock directory', p_new_id, p_op);
      end if;
      if (p_old_read_only = p_new_read_only) and (p_new_read_only = 'Y') then
        change_error('OFS-6: Directory is read-only', p_new_id, p_op);
      end if;
    end if;
  end;

  function os_user return varchar2 is
  begin
    return g_os_user;
  end;

  procedure set_os_user(p_user in varchar2) is
  begin
    g_os_user := p_user;
  end;

  procedure force_unlock(p_id in OFS_ITEMS.id%type) is
    prev_usr OFS_ITEMS.locked_by%type;
    usr      OFS_ITEMS.locked_by%type;
  begin
    select locked_by
      into usr
      from ofs_items
      where id = p_id;
    if usr is not null then
      prev_usr := os_user;
      set_os_user(usr);
      begin
        update ofs_items
          set locked_by = null, date_locked = null
          where id = p_id;
        set_os_user(prev_usr);
      exception
        when others then
          set_os_user(prev_usr);
          raise;
      end;
    end if;
  end;

  procedure test_count_recs(p_num in integer,
      p_ok_msg in varchar2, p_err_msg in varchar2) is
    n integer;
  begin
    select count(*)
      into n
      from ofs_items;
    if n <> p_num then
      dbms_output.put_line(substr(p_err_msg || '. Must be ' ||
        to_char(p_num) || ', is ' || to_char(n), 1, 255));
    else
      dbms_output.put_line(substr(p_ok_msg, 1, 255));
    end if;
  end;

  procedure test_count_cursor(p_crs in ofs.dir_cursor,
      p_num in integer, p_ok_msg in varchar2, p_err_msg in varchar2) is
    n integer;
    vitem_type ofs_items.item_type%type;
    vname ofs_items.name%type;
    vdate_created ofs_items.date_created%type;
    vcreated_by ofs_items.created_by%type;
    vdate_modified ofs_items.date_modified%type;
    vmodified_by ofs_items.modified_by%type;
    vread_only ofs_items.read_only%type;
    vcompressed ofs_items.compressed%type;
    vdata_length number;
    vlocked_by ofs_items.locked_by%type;
    vdate_locked ofs_items.date_locked%type;
  begin
    n := 0;
    loop
      fetch p_crs INTO vitem_type, vname, vdate_created, vcreated_by,
        vdate_modified, vmodified_by, vread_only, vcompressed,
        vdata_length, vlocked_by, vdate_locked;
      exit when p_crs%notfound;
      n := n + 1;
    end loop;
    close p_crs;
    if n <> p_num then
      dbms_output.put_line(substr(p_err_msg || '. Must be ' ||
        to_char(p_num) || ', is ' || to_char(n), 1, 255));
    else
      dbms_output.put_line(substr(p_ok_msg, 1, 255));
    end if;
  end;

  procedure test_error(p_error in varchar2,
      p_ok_msg in varchar2, p_err_msg in varchar2) is
  begin
    if instr(sqlerrm, p_error) <> 0 then
      dbms_output.put_line(substr(p_ok_msg, 1, 255));
    else
      dbms_output.put_line(substr(p_err_msg || '. ' || sqlerrm, 1, 255));
    end if;
  end;

  procedure test_attr(p_path in varchar2, p_attr in varchar2,
      p_val in varchar2, p_ok_msg in varchar2, p_err_msg in varchar2) is
    c char(1);
  begin
    c := ofs.get_attr(p_path, p_attr);
    if c = p_val then
      dbms_output.put_line(substr(p_ok_msg, 1, 255));
    else
      dbms_output.put_line(substr(p_err_msg || '. Must be [' ||
        p_val || '], is [' || c || ']', 1, 255));
    end if;
  end;

begin
  g_os_user := sys_context('USERENV', 'OS_USER');
end;

/
--------------------------------------------------------
--  DDL for Procedure PROC_LE_ARQUIVO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "OSMUNDO"."PROC_LE_ARQUIVO" is
begin
  

 declare
   -- nosso handler
   v_arq utl_file.file_type;
   -- recebe a linha lida do arquivo
   v_txt varchar2(200);
 begin
   -- diretÃ³rio oracle, nome do arquivo, r indica leitura
   v_arq := utl_file.fopen('C:\Teste' , 'teste.txt', 'r'); 
   -- loop de leitura
   loop
    -- pega linha do arquivo
     utl_file.get_line(v_arq, v_txt);
     -- imprime
     dbms_output.put_line(v_txt);
   end loop;
 exception  
   when NO_DATA_FOUND then
      -- quando nÃ£o existirem mais linhas no arquivo o mesmo Ã© fechado
      utl_file.fclose(v_arq);
  end;



end proc_le_arquivo;

/
--------------------------------------------------------
--  DDL for Synonymn DUAL
--------------------------------------------------------

  CREATE OR REPLACE PUBLIC SYNONYM "DUAL" FOR "SYS"."DUAL";
--------------------------------------------------------
--  DDL for Synonymn DBMS_LOCK
--------------------------------------------------------

  CREATE OR REPLACE PUBLIC SYNONYM "DBMS_LOCK" FOR "SYS"."DBMS_LOCK";
--------------------------------------------------------
--  DDL for Synonymn DBMS_OUTPUT
--------------------------------------------------------

  CREATE OR REPLACE PUBLIC SYNONYM "DBMS_OUTPUT" FOR "SYS"."DBMS_OUTPUT";
--------------------------------------------------------
--  DDL for Synonymn DBMS_RANDOM
--------------------------------------------------------

  CREATE OR REPLACE PUBLIC SYNONYM "DBMS_RANDOM" FOR "SYS"."DBMS_RANDOM";
--------------------------------------------------------
--  DDL for Synonymn DBMS_SQL
--------------------------------------------------------

  CREATE OR REPLACE PUBLIC SYNONYM "DBMS_SQL" FOR "SYS"."DBMS_SQL";
--------------------------------------------------------
--  DDL for Synonymn DBMS_UTILITY
--------------------------------------------------------

  CREATE OR REPLACE PUBLIC SYNONYM "DBMS_UTILITY" FOR "SYS"."DBMS_UTILITY";
--------------------------------------------------------
--  DDL for Synonymn DBMS_LOB
--------------------------------------------------------

  CREATE OR REPLACE PUBLIC SYNONYM "DBMS_LOB" FOR "SYS"."DBMS_LOB";
--------------------------------------------------------
--  DDL for Synonymn PLITBLM
--------------------------------------------------------

  CREATE OR REPLACE PUBLIC SYNONYM "PLITBLM" FOR "SYS"."PLITBLM";
--------------------------------------------------------
--  DDL for Synonymn UTL_COMPRESS
--------------------------------------------------------

  CREATE OR REPLACE PUBLIC SYNONYM "UTL_COMPRESS" FOR "SYS"."UTL_COMPRESS";
--------------------------------------------------------
--  DDL for Synonymn UTL_FILE
--------------------------------------------------------

  CREATE OR REPLACE PUBLIC SYNONYM "UTL_FILE" FOR "SYS"."UTL_FILE";
--------------------------------------------------------
--  DDL for Synonymn AVALIACAO_COORDENADOR
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "OSMUNDO"."AVALIACAO_COORDENADOR" FOR "SEMAD"."AVALIACAO_COORDENADOR";
--------------------------------------------------------
--  DDL for Synonymn F_G_PK_PLAQUETA_INATIVADA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "OSMUNDO"."F_G_PK_PLAQUETA_INATIVADA" FOR "SEMAD"."F_G_PK_PLAQUETA_INATIVADA";
--------------------------------------------------------
--  DDL for Synonymn V_ENTRADA_ESTOQUE_3
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "OSMUNDO"."V_ENTRADA_ESTOQUE_3" FOR "SEMAD"."V_ENTRADA_ESTOQUE_3";
